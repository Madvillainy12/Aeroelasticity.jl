var documenterSearchIndex = {"docs":
[{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [AerostructuralDynamics]\nPrivate = false","category":"page"},{"location":"library/#AerostructuralDynamics.AbstractModel","page":"Library","title":"AerostructuralDynamics.AbstractModel","text":"AbstractModel\n\nSupertype for all models.\n\n\n\n\n\n","category":"type"},{"location":"library/#AerostructuralDynamics.GEBT","page":"Library","title":"AerostructuralDynamics.GEBT","text":"GEBT <: AbstractModel\n\nGeometrically exact beam theory model, as implemented by the GXBeam package. State variables are as defined by GXBeam. Inputs correspond to the (non-follower) distributed aerodynamic loads on each beam element with distributed loads. When coupled with an aerodynamic model, the local beam y and z-axes should be aligned with the negative chordwise and positive normal directions, respectively.\n\nAt this point in time, this model doesn't accept any parameters.\n\n\n\n\n\n","category":"type"},{"location":"library/#AerostructuralDynamics.GEBT-Union{Tuple{TM}, Tuple{TV}, Tuple{TF}, Tuple{GXBeam.System{TF, TV, TM}, Any, Any, Any}} where {TF, TV, TM}","page":"Library","title":"AerostructuralDynamics.GEBT","text":"GEBT(system, assembly, prescribed_conditions, distributed_loads)\n\nConstruct a geometrically exact beam theory structural model.\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.LiftingLine","page":"Library","title":"AerostructuralDynamics.LiftingLine","text":"LiftingLine{N,T} <: AbstractModel\n\nLifting line model with N cross sections, using the aerodynamic models in T. State variables, inputs, and parameters correspond to the state variables, inputs, and parameters of each of the cross sections concatenated\n\n\n\n\n\n","category":"type"},{"location":"library/#AerostructuralDynamics.LiftingLine-Union{Tuple{Any}, Tuple{T}, Tuple{N}} where {N, T}","page":"Library","title":"AerostructuralDynamics.LiftingLine","text":"LiftingLine{N}(model)\n\nConstruct a lifting line aerodynamic model using N instances of model.\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.LiftingLine-Union{Tuple{T}, Tuple{N}} where {N, T<:Tuple{Vararg{Any, N}}}","page":"Library","title":"AerostructuralDynamics.LiftingLine","text":"LiftingLine(models)\n\nConstruct a lifting line aerodynamic model given a tuple of aerodynamic models.\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.Peters","page":"Library","title":"AerostructuralDynamics.Peters","text":"Peters{N,TF,SV,SA} <: AbstractModel\n\nPeter's finite state model with N state variables, inputs d = beginbmatrix u  dotv  dottheta  ddotthetaendbmatrix^T and parameters p_a = beginbmatrix a  b  rho  a_0  alpha_0 endbmatrix^T\n\n\n\n\n\n","category":"type"},{"location":"library/#AerostructuralDynamics.Peters-Union{Tuple{}, Tuple{N}} where N","page":"Library","title":"AerostructuralDynamics.Peters","text":"Peters{N,TF=Float64}()\n\nInitialize an object of type Peters which has N aerodynamic degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.QuasiSteady","page":"Library","title":"AerostructuralDynamics.QuasiSteady","text":"QuasiSteady{Order} <: NoStateModel\n\n2D quasi-steady aerodynamic model with parameters p_a = beginbmatrix a  b  rho  a_0  lpha_0 endbmatrix^T.\n\n\n\n\n\n","category":"type"},{"location":"library/#AerostructuralDynamics.QuasiSteady-Tuple{}","page":"Library","title":"AerostructuralDynamics.QuasiSteady","text":"QuasiSteady()\n\nInitialize an object of type QuasiSteady which represents a 2D quasi-steady aerodynamic model.\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.TypicalSection","page":"Library","title":"AerostructuralDynamics.TypicalSection","text":"TypicalSection <: AbstractModel\n\nTypical section structural model with state variables q = beginbmatrix h  Î¸  doth  dottheta endbmatrix^T, structural parameters p_s = beginbmatrix k_h  k_theta  m  S_theta  I_theta endbmatrix^T, and aerodynamic loads r = beginbmatrix L  M endbmatrix^T\n\n\n\n\n\n","category":"type"},{"location":"library/#AerostructuralDynamics.Wagner","page":"Library","title":"AerostructuralDynamics.Wagner","text":"Wagner{TF} <: AbstractModel\n\nAerodynamic model based on Wagner's function with state variables d = beginbmatrix lambda_1  lambda_2 endbmatrix^T, inputs d = beginbmatrix u  v  dottheta endbmatrix^T and parameters p_a = beginbmatrix a  b  rho  a_0  lpha_0 endbmatrix^T\n\n\n\n\n\n","category":"type"},{"location":"library/#AerostructuralDynamics.Wagner-Tuple{}","page":"Library","title":"AerostructuralDynamics.Wagner","text":"Wagner(; C1=0.165, C2=0.335, eps1 = 0.0455, eps2 = 0.3)\n\nInitialize an object of type Wagner\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.Steady-Tuple{}","page":"Library","title":"AerostructuralDynamics.Steady","text":"Steady()\n\nInitialize an object of type QuasiSteady which represents a 2D steady aerodynamic model.\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.get_input_jacobian-Union{Tuple{TM}, Tuple{TM, Vararg{Any, N} where N}} where TM","page":"Library","title":"AerostructuralDynamics.get_input_jacobian","text":"get_input_jacobian(models)\nget_input_jacobian(models, u, y, p, t)\n\nCalculate the jacobian with respect to the inputs for the specified model or models.\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.get_inputs!-Union{Tuple{T}, Tuple{Any, T, Any, Any, Any}} where T","page":"Library","title":"AerostructuralDynamics.get_inputs!","text":"get_inputs!(y, models::NTuple{N,AbstractModel}, u, p, t) where N\n\nIn-place version of get_inputs\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.get_inputs-Union{Tuple{TM}, Tuple{TM, Any, Any, Any}} where TM","page":"Library","title":"AerostructuralDynamics.get_inputs","text":"get_inputs(models, u, p, t)\n\nCalculate the inputs to the specified combination of models.\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.get_mass_matrix!-Union{Tuple{TM}, Tuple{Any, TM, Vararg{Any, N} where N}} where TM","page":"Library","title":"AerostructuralDynamics.get_mass_matrix!","text":"get_mass_matrix!(M, models)\nget_mass_matrix!(M, models, u, y, p, t)\n\nIn-place version of get_mass_matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.get_mass_matrix-Union{Tuple{TM}, Tuple{TM, Vararg{Any, N} where N}} where TM","page":"Library","title":"AerostructuralDynamics.get_mass_matrix","text":"get_mass_matrix(models)\nget_mass_matrix(models, u, y, p, t)\n\nCalculate the mass matrix for a model or combination of models.\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.get_mass_matrix_product!-Union{Tuple{T}, Tuple{Any, T, Any, Any, Any, Any}} where T","page":"Library","title":"AerostructuralDynamics.get_mass_matrix_product!","text":"get_mass_matrix_product!(out, models, du, u, y, p, t)\n\nIn-place version of get_rates\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.get_mass_matrix_product-Union{Tuple{T}, Tuple{T, Any, Any, Any, Any, Any}} where T","page":"Library","title":"AerostructuralDynamics.get_mass_matrix_product","text":"get_mass_matrix_product(models, du, u, y, p, t)\n\nCalculate the (mass matrix multiplied) state rates for the specified model or models.\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.get_rates!-Union{Tuple{T}, Tuple{Any, T, Any, Any, Any, Any}} where T","page":"Library","title":"AerostructuralDynamics.get_rates!","text":"get_rates!(du, models, u, y, p, t)\n\nIn-place version of get_rates\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.get_rates-Union{Tuple{T}, Tuple{T, Any, Any, Any, Any}} where T","page":"Library","title":"AerostructuralDynamics.get_rates","text":"get_rates(models, u, y, p, t)\n\nCalculate the (mass matrix multiplied) state rates for the specified model or models.\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.get_state_jacobian!-Union{Tuple{T}, Tuple{Any, T, Vararg{Any, N} where N}} where T","page":"Library","title":"AerostructuralDynamics.get_state_jacobian!","text":"get_state_jacobian!(J, models, u, y, p, t)\n\nIn-place version of get_state_jacobian\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.get_state_jacobian-Union{Tuple{T}, Tuple{T, Any, Any, Any, Any}} where T","page":"Library","title":"AerostructuralDynamics.get_state_jacobian","text":"get_state_jacobian(models, u, y, p, t)\n\nCalculate the jacobian with respect to the state variables for the specified models.\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.input_indices-Union{Tuple{Tuple{Vararg{AbstractModel, N}}}, Tuple{N}} where N","page":"Library","title":"AerostructuralDynamics.input_indices","text":"input_indices(models)\n\nReturn the indices corresponding to the input variables for each model in models\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.number_of_inputs","page":"Library","title":"AerostructuralDynamics.number_of_inputs","text":"number_of_inputs(models)\n\nReturn the total number of inputs corresponding to the model or models.\n\n\n\n\n\n","category":"function"},{"location":"library/#AerostructuralDynamics.number_of_parameters","page":"Library","title":"AerostructuralDynamics.number_of_parameters","text":"number_of_parameters(models)\n\nReturn the total number of parameters corresponding to the model or models.\n\n\n\n\n\n","category":"function"},{"location":"library/#AerostructuralDynamics.number_of_states","page":"Library","title":"AerostructuralDynamics.number_of_states","text":"number_of_states(models)\n\nReturn the total number of states corresponding to the model or models.\n\n\n\n\n\n","category":"function"},{"location":"library/#AerostructuralDynamics.parameter_indices-Union{Tuple{Tuple{Vararg{AbstractModel, N}}}, Tuple{N}} where N","page":"Library","title":"AerostructuralDynamics.parameter_indices","text":"parameter_indices(models)\n\nReturn the indices corresponding to the parameters for each model in models\n\n\n\n\n\n","category":"method"},{"location":"library/#AerostructuralDynamics.state_indices-Union{Tuple{Tuple{Vararg{AbstractModel, N}}}, Tuple{N}} where N","page":"Library","title":"AerostructuralDynamics.state_indices","text":"state_indices(models)\n\nReturn the indices corresponding to the state variables for each model in models\n\n\n\n\n\n","category":"method"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/#Aerodynamic-Models","page":"Models","title":"Aerodynamic Models","text":"","category":"section"},{"location":"models/#Two-Dimensional-Models","page":"Models","title":"Two-Dimensional Models","text":"","category":"section"},{"location":"models/#[Steady](@ref)","page":"Models","title":"Steady","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"This model is a steady linear 2D aerodynamic model derived from thin airfoil theory.  The equations for the lift and quarter-chord moment per unit span are:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"L = a_0 rho_infty u^2 b alpha_texteff \nM_frac14 = 0","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where a_0 is the lift curve slope, rho is the air density, u is the local freestream velocity in the chordwise direction, b is the semichord, and alpha_texteff is the effective angle of attack.  For this model, the effective angle of attack is","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"alpha_texteff = -fracvu","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where v is the local freestream velocity in the airfoil normal direction and alpha_0 is the zero lift angle of attack.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"For coupling with structural models, it is convenient to be able to define the lift and moment at an arbitrary reference location.  Defining the reference location to be a b aft of the semichord, the lift and moment may be expressed as","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"L = a_0 rho_infty u^2 b alpha_texteff \nM = b left(frac12 + a right) L","category":"page"},{"location":"models/#[QuasiSteady](@ref)","page":"Models","title":"QuasiSteady","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"This model is a quasi-steady linear 2D aerodynamic model derived from thin airfoil theory.  The equations for the lift and quarter-chord moment per unit span are:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"L = a_0 rho_infty u^2 b alpha_texteff + pi rho b^2 left(-dotv + u dottheta - a b ddottheta right) \nM_frac14 = -pi rho_infty b^3 left -frac12dotv + udottheta + b left( frac18 - fraca2 right) ddottheta right","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where a_0 is the lift curve slope, rho_infty is the air density, u is the local freestream velocity in the chordwise direction, v is the local freestream velocity in the normal direction, theta is the pitch angle, a defines the reference location, b is the semichord, and alpha_texteff is the effective angle of attack.  The reference location is located a b aft of the semichord.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The effective angle of attack alpha for this model is given by","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"alpha_texteff = -fracvu + fracbuleft( frac12 - a right) dottheta - alpha_0","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where alpha_0 is the zero lift angle of attack.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"At the reference location, the lift and moment are","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"L = a_0 rho_infty u^2 b alpha_texteff + pi rho b^2 left(-dotv + udottheta - a b ddottheta right) \nM = -pi rho_infty b^3 left -frac12dotv + udottheta + b left( frac18 - fraca2 right) ddottheta right + b left(frac12 + a right) L","category":"page"},{"location":"models/#[Wagner](@ref)","page":"Models","title":"Wagner","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Wagner's function models the indicial response of aerodynamic loads under a sudden change in downwash w at the three-quarter's chord. The exact expression for Wagner's function is","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"phi(t) = frac2pi int_0^infty fracRe(C) sin ( omega (ub) t  )omega domega","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where C(omega) is Theodorsen's function.  In many cases, approximate versions of Wagner's function are used rather than the exact expression,  of which one of the most common is the approximation of Wagner's function provided by R. T. Jones","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"phi(t) = 1 - C_1 e^-varepsilon_1 (ub) t - C_2 e^-varepsilon_2 (ub) t","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where C_1 = 0165, C_2 = 0335, varepsilon_1 = 0455, and varepsilon_2 = 03.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Wagner's function may be used to model arbitrary airfoil motion using Duhamel's integral.  We start by modeling the increment in circulatory lift d L_c(t) at time t due to an increment in downwash d w(t) at earlier time tau as","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"fracd L_c(t)a_0 rho_infty u b =  phi(t - tau) d w(tau)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where phi(t) is the impulse response function, which in this case is R. T. Jones' approximation of Wagner's function.  Superimposing all previous impulse responses using Duhamel's integral yields the following expression for the instantaneous circulatory lift.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"fracL_ca_0 rho_infty u b = int_-infty^t d w(tau) phi(t - tau) dtau = w(0) phi(t) + int_0^t  d w(tau) phi(t - tau) d tau","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"We can transform this equation using integration by parts, yielding","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"fracL_ca_0 rho_infty u b = w(t) phi(0) - int_0^t w(tau) dphi(t - tau) dtau","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The integral in this expression may be expressed as a function of the aerodynamic states lambda_1 and lambda_2.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"lambda_1 = C_1 varepsilon_1 fracub int_0^t w(tau) e^-varepsilon_1 (ub) (t - tau) d tau","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"lambda_2 = C_2 varepsilon_2 fracub int_0^t w(tau) e^-varepsilon_2 (ub) (t - tau) d tau","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"lambda_1 + lambda_2 = - int_0^t w(tau) dphi(t-tau) dtau","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The expression for circulatory lift then reduces to","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"fracL_ca_0 rho_infty u b = w(t) phi(0) + lambda_1 + lambda_2","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where the downwash at the three quarter's chord is given by","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"w(t) = -v + b left( frac12 - a right) dottheta - ualpha_0","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"and the aerodynamic states variables lambda_1 and lambda_2 are described by the ordinary differential equations","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"dotlambda_1 = -varepsilon_1 fracub lambda_1 + C_1 varepsilon_1 fracub w(t) \ndotlambda_2 = -varepsilon_2 fracub lambda_2 + C_2 varepsilon_2 fracub w(t)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The same lift and moment expressions are used as in the quasisteady model, but with the new effective angle of attack","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"alpha_texteff = left(-fracvu + fracbu left( frac12 - a right) dottheta - alpha_0 right) phi(0) + fraclambda_1u + fraclambda_2u","category":"page"},{"location":"models/#[Peters](@ref)","page":"Models","title":"Peters","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"For Peter's finite state model, an additional term is added to the expression for the effective angle of attack from the quasi-steady model to account for induced velocity.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"alpha = - fracvu + fracbuleft( frac12 - a right) dottheta + fraclambda_0u","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The induced velocity lambda_0 is approximated from a set of N induced-flow states lambda_1 lambda_2 dots lambda_N as","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"lambda approx frac12 sum_n=1^N b_n lambda_n","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The set of N first-order ordinary differential equations which govern the N finite aerodynamic states are derived by Peters as","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"barA lambda + fracub lambda = barc left -dotv + udottheta + b left(frac12 - a right) ddottheta right","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"barA = barD + bard barb^T + barc bard^T + frac12 barc  barb^T \nbarD_nm = begincases\nfrac12n  n=m+1 \nfrac-12n  n=m-1 \n0  n neq m pm 1 \nendcases\nquad\nbarb_n = begincases\nleft( -1 right)^n-1 frac(N+n-1)(N-n-1)frac1left(nright)^2  n neq N \nleft( -1 right)^n-1  n = N\nendcases\nquad\nbarc_n = frac2n\nquad\nbard_n = begincases\nfrac12  n = 1 \n0  n neq 1\nendcases","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The same lift and moment expressions are used as in the quasisteady model, but with the new effective angle of attack.","category":"page"},{"location":"models/#Three-Dimensional-Models","page":"Models","title":"Three-Dimensional Models","text":"","category":"section"},{"location":"models/#[LiftingLine](@ref)","page":"Models","title":"LiftingLine","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Two-dimensional aerodynamic models may be applied in the context of a three-dimensional analysis by applying these models at multiple chordwise sections along the span of one or more lifting surfaces.  This type of model is applicable when spanwise flow effects are negligible, which is often the case for high aspect ratio wings.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The lifting line model implemented in this package assumes that the aerodynamics of each section is independent of the aerodynamics of the other sections, except as coupled through other models.  The state variables and inputs for this model correspond to the state variables, inputs, and parameters of each of the two-dimensional aerodynamic models, concatenated.  Rate equations are also concatenated.  ","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"When coupled with a structural model, aircraft linear and angular accelerations are obtained from the structural model and transformed into the (deformed) local beam frame using an appropriate transformation matrix.  The local freestream velocities/accelerations and pitch rates/accelerations are then defined by a subset of the transformed linear and angular accelerations and cross-flow effects are neglected.   An inverse transformation may then be performed to transform the local aerodynamic forces/moments into the reference frame used by the structural model.","category":"page"},{"location":"models/#Vortex-Lattice-Method-[VLM](@ref)","page":"Models","title":"Vortex Lattice Method VLM","text":"","category":"section"},{"location":"models/#Structural-Models","page":"Models","title":"Structural Models","text":"","category":"section"},{"location":"models/#Two-Dimensional-Models-2","page":"Models","title":"Two-Dimensional Models","text":"","category":"section"},{"location":"models/#Typical-Section-[TypicalSection](@ref)","page":"Models","title":"Typical Section TypicalSection","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The equations of motion for this model are","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"m left(ddoth+b x_theta ddottheta right) + k_h h = -L \nI_P ddottheta + m b x_theta ddoth + k_theta = M","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where a is the normalized distance from the semichord to the reference point, b is the semichord length, k_h is the linear spring constant, k_theta is the torsional spring constant, m is the mass per unit span, x_theta is the distance to the center of mass from the reference point, I_P is the moment of inertia about the reference point, L is the lift per unit span, and M_frac14 is the quarter-chord moment per unit span.","category":"page"},{"location":"models/#Three-Dimensional-Models-2","page":"Models","title":"Three-Dimensional Models","text":"","category":"section"},{"location":"models/#Rigid-Body-[RigidBody](@ref)","page":"Models","title":"Rigid Body RigidBody","text":"","category":"section"},{"location":"models/#Geometrically-Exact-Beam-Theory-[GEBT](@ref)","page":"Models","title":"Geometrically Exact Beam Theory GEBT","text":"","category":"section"},{"location":"developer/#Developer's-Guide","page":"Developer Guide","title":"Developer's Guide","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In this guide we demonstrate by example how to define aerodynamic and structural models and couple them together.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Pages = [\"developer.md\"]\nDepth = 3","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"using AerostructuralDynamics, StaticArrays, LinearAlgebra","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"using AerostructuralDynamics, StaticArrays, LinearAlgebra #hide","category":"page"},{"location":"developer/#Defining-a-Structural-Model","page":"Developer Guide","title":"Defining a Structural Model","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For demonstrating how to create a new structural model, we use a typical section model with two degrees of freedom, as shown in the following figure.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"(Image: )","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The equations of motion for this model are:","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"m left(ddoth+b x_theta ddottheta right) + k_h h = -L \nI_P ddottheta + m b x_theta ddoth + k_theta = M_frac14 + b left( frac12 + a right) L","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where a is the normalized distance from the semichord to the reference point, b is the semichord length, k_h is the linear spring constant, k_theta is the torsional spring constant, m is the mass per unit span, x_theta is the distance to the center of mass from the reference point, I_P is the moment of inertia about the reference point, L is the lift per unit span, and M_frac14 is the quarter-chord moment per unit span.","category":"page"},{"location":"developer/#Theory","page":"Developer Guide","title":"Theory","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Structural state variables in this package satisfy the ordinary differential equation (or differential algebraic equation in mass matrix form)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M_s(qrp_st)dotq = f_s(qrp_st)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where M_s is a function which defines the structural mass matrix, f_s is a function which defines the mass matrix multiplied structural state rates, q is a vector of structural states, r is a vector of aerodynamic loads, p_s is a vector of structural parameters, and t is the current time.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The equations of motion for the typical section model when expressed in the form expected by this package are","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M dotq = K q + D r","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"q = beginbmatrix h  theta  doth  dottheta endbmatrix^T quad\nr = beginbmatrix L  M_frac14 endbmatrix^T","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M =\nbeginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  m  m b x_theta \n    0  0  m b x_theta  I_P\nendbmatrix\nquad\nK =\nbeginbmatrix\n0  0  1  0 \n0  0  0  1 \n-k_h  0  0  0 \n0  -k_theta  0  0\nendbmatrix\nquad\nD =\nbeginbmatrix\n0  0 \n0  0 \n-1  0 \nb left( frac12 + a right)  1\nendbmatrix","category":"page"},{"location":"developer/#Defining-a-New-Type","page":"Developer Guide","title":"Defining a New Type","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"We start creating our model by defining a new type.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"\"\"\"\n    MyTypicalSection <: AbstractModel\n\nTypical section structural model with state variables ``q = \\\\begin{bmatrix} h &\nÎ¸ & \\\\dot{h} & \\\\dot{\\\\theta} \\\\end{bmatrix}^T``, structural parameters ``p_s =\n\\\\begin{bmatrix} a & b & k_h & k_\\\\theta & m & x_\\\\theta & I_P \\\\end{bmatrix}^T``,\nand aerodynamic loads ``r = \\\\begin{bmatrix} L & M_\\\\frac{1}{4} \\\\end{bmatrix}^T``\n\"\"\"\nstruct MyTypicalSection <: AbstractModel end\n\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Model parameters may be stored either as fields of the newly defined type or passed directly to the solver.  In this case, we choose to define all of the structural parameters as elements of the parameter vector.  In general, model constants should be stored as fields of the struct, whereas parameters that may change should be passed to the solver through the parameter vector.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Note that the state, parameter, and aerodynamic load variable identities should be documented in the docstring of the type definition since the type definition provides the primary (and sometimes only) source of documentation for a given model.","category":"page"},{"location":"developer/#Defining-Model-Properties","page":"Developer Guide","title":"Defining Model Properties","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"We now need to define a few model properties.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate the number of state variables in our model, we define a new method for the number_of_states function.  In our case, we have four structural state variables q = beginbmatrix h  theta  doth  dottheta endbmatrix^T.  This method must be defined for all models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"number_of_states(::Type{MyTypicalSection}) = 4\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate the number of aerodynamic load inputs, we define a new method for the number_of_inputs function.  In our case, we have two aerodynamic loads r = beginbmatrix L  M_frac14 endbmatrix^T.  This method must be defined for all models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"number_of_inputs(::Type{MyTypicalSection}) = 2\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate the number of parameters, we define a new method for the number_of_parameters function.  In our case, we have seven parameters p_s = beginbmatrix a  b  k_h  k_theta  m  x_theta  I_P endbmatrix^T.  This method must be defined for all models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"number_of_parameters(::Type{MyTypicalSection}) = 7\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate whether we plan to use in-place or out-of-place functions, we define a new method for the inplaceness function.  In general, for performance reasons, in-place functions are preferred.  The one exception is for models with small amounts of state variables, in which case the preferred approach is to use static arrays with out-of-place functions.  For this model, we use the latter approach.  This method must be defined for all models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"inplaceness(::Type{MyTypicalSection}) = OutOfPlace()\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate mass matrix properties, we define a new method for the mass_matrix_type function.  This method must be defined for all models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"mass_matrix_type(::Type{MyTypicalSection}) = Varying()\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate the properties of the jacobian of the state rates with respect to the state variables, we define a new method for the state_jacobian_type function.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"state_jacobian_type(::Type{MyTypicalSection}) = Varying()\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate the properties of the jacobian of the state rates with respect to the inputs, we define a new method for the input_jacobian_type function.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"input_jacobian_type(::Type{MyTypicalSection}) = Varying()\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate whether the state rates are linearly dependent on the aerodynamic loads, or in other words whether the governing structural equations can be expressed as  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M_s(qp_st)dotq = f_s(qp_st) + D_s(qp_st)r","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"we define a new method for the input_dependence_type function.  Having a linear load dependence allows for greater flexibility when coupling the structural model with an aerodynamic model.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"input_dependence_type(::Type{MyTypicalSection}) = Linear()\nnothing #hide","category":"page"},{"location":"developer/#Mass-Matrix-Equation","page":"Developer Guide","title":"Mass Matrix Equation","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For out-of-place models, the mass matrix is calculated using the get_mass_matrix function.  For in-place models the mass matrix is calculated using the get_mass_matrix! function.  For constant mass matrices, these functions are called without the q, r, p, and t arguments.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_mass_matrix(::MyTypicalSection, q, r, p, t)\n    # extract structural parameters\n    a, b, kh, kÎ¸, m, xÎ¸, Ip = p\n    # calculate mass matrix\n    return @SMatrix [1 0 0 0; 0 1 0 0; 0 0 m m*b*xÎ¸; 0 0 m*b*xÎ¸ Ip]\nend\nnothing #hide","category":"page"},{"location":"developer/#State-Rate-Equation","page":"Developer Guide","title":"State Rate Equation","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The right hand side of the governing structural differential equations is calculated using the get_rates function for out-of-place models and get_rates! function for in-place models.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_rates(::MyTypicalSection, q, r, p, t)\n    # extract structural states\n    h, Î¸, hdot, Î¸dot = q\n    # extract aerodynamic loads\n    L, M = r\n    # extract structural parameters\n    a, b, kh, kÎ¸, m, xÎ¸, Ip = p\n    # calculate state rates\n    return SVector(hdot, Î¸dot, -kh*h - L, -kÎ¸*Î¸ + M + (b/2+a*b)*L)\nend\n\nnothing #hide","category":"page"},{"location":"developer/#State-Rate-Jacobian","page":"Developer Guide","title":"State Rate Jacobian","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The jacobian of the right hand side of the governing structural equations with respect to the state variables is calculated using the get_state_jacobian function for out-of-place models and get_state_jacobian! function for in-place models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_state_jacobian(::MyTypicalSection, q, r, p, t)\n    # extract parameters\n    a, b, kh, kÎ¸, m, xÎ¸, Ip = p\n    # return jacobian\n    return @SMatrix [0 0 1 0; 0 0 0 1; -kh 0 0 0; 0 -kÎ¸ 0 0]\nend\n\nnothing #hide","category":"page"},{"location":"developer/#Input-Jacobian","page":"Developer Guide","title":"Input Jacobian","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The jacobian of the right hand side of the governing structural equations with respect to the inputs is defined using the get_input_jacobian function.  There is no out-of-place form for this function, however, it may be constructed as a either a linear map (if large) or static array (if small) in order to avoid allocations.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_input_jacobian(::MyTypicalSection, q, r, p, t)\n    # extract parameters\n    a, b, kh, kÎ¸, m, xÎ¸, Ip = p\n    # return jacobian\n    return @SMatrix [0 0; 0 0; -1 0; b/2+a*b 1]\nend\n\nnothing #hide","category":"page"},{"location":"developer/#Structural-Model-Code","page":"Developer Guide","title":"Structural Model Code","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Putting it all together, a complete representation of our typical section model for use with this package may be defined using the following block of code.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"\"\"\"\n    MyTypicalSection <: AbstractModel\n\nTypical section structural model with state variables ``q = \\\\begin{bmatrix} h &\nÎ¸ & \\\\dot{h} & \\\\dot{\\\\theta} \\\\end{bmatrix}^T``, structural parameters ``p_s =\n\\\\begin{bmatrix} a & b & k_h & k_\\\\theta & m & x_\\\\theta & I_P \\\\end{bmatrix}^T``,\nand aerodynamic loads ``r = \\\\begin{bmatrix} L & M_\\\\frac{1}{4} \\\\end{bmatrix}^T``\n\"\"\"\nstruct MyTypicalSection <: AbstractModel end\n\n# --- Traits --- #\n\nnumber_of_states(::Type{MyTypicalSection}) = 4\nnumber_of_inputs(::Type{MyTypicalSection}) = 2\nnumber_of_parameters(::Type{MyTypicalSection}) = 7\ninplaceness(::Type{MyTypicalSection}) = OutOfPlace()\nmass_matrix_type(::Type{MyTypicalSection}) = Varying()\nstate_jacobian_type(::Type{MyTypicalSection}) = Varying()\ninput_jacobian_type(::Type{MyTypicalSection}) = Varying()\ninput_dependence_type(::Type{MyTypicalSection}) = Linear()\n\n# --- Methods --- #\n\nfunction get_mass_matrix(::MyTypicalSection, q, r, p, t)\n    # extract structural parameters\n    a, b, kh, kÎ¸, m, xÎ¸, Ip = p\n    # calculate mass matrix\n    return @SMatrix [1 0 0 0; 0 1 0 0; 0 0 m m*b*xÎ¸; 0 0 m*b*xÎ¸ Ip]\nend\n\nfunction get_rates(::MyTypicalSection, q, r, p, t)\n    # extract structural states\n    h, Î¸, hdot, Î¸dot = q\n    # extract aerodynamic loads\n    L, M = r\n    # extract structural parameters\n    a, b, kh, kÎ¸, m, xÎ¸, Ip = p\n    # calculate state rates\n    return SVector(hdot, Î¸dot, -kh*h - L, -kÎ¸*Î¸ + M + (b/2+a*b)*L)\nend\n\nfunction get_state_jacobian(::MyTypicalSection, q, r, p, t)\n    # extract parameters\n    a, b, kh, kÎ¸, m, xÎ¸, Ip = p\n    # return jacobian\n    return @SMatrix [0 0 1 0; 0 0 0 1; -kh 0 0 0; 0 -kÎ¸ 0 0]\nend\n\nfunction get_input_jacobian(::MyTypicalSection, q, r, p, t)\n    # extract parameters\n    a, b, kh, kÎ¸, m, xÎ¸, Ip = p\n    # return jacobian\n    return @SMatrix [0 0; 0 0; -1 0; b/2+a*b 1]\nend\n\nnothing #hide","category":"page"},{"location":"developer/#Defining-an-Aerodynamic-Model","page":"Developer Guide","title":"Defining an Aerodynamic Model","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For demonstrating how to create a new aerodynamic model, we use Peters' finite state aerodynamic model.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The governing differential equation for the aerodynamic states is","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"barAdotlambda + fracUblambda = barcleft ddoth + Udottheta + b left(frac12 - aright) ddottheta right","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"barA = barD + bard barb^T + barc bard^T + frac12 barc  barb^T \nbarD_nm = begincases\nfrac12n  n=m+1 \nfrac-12n  n=m-1 \n0  n neq m pm 1 \nendcases\nquad\nbarb_n = begincases\nleft( -1 right)^n-1 frac(N+n-1)(N-n-1)frac1left(nright)^2  n neq N \nleft( -1 right)^n-1  n = N\nendcases\nquad\nbarc_n = frac2n\nquad\nbard_n = begincases\nfrac12  n = 1 \n0  n neq 1\nendcases","category":"page"},{"location":"developer/#Theory-2","page":"Developer Guide","title":"Theory","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Aerodynamic state variables in this package satisfy the ordinary differential equation (or differential algebraic equation in mass matrix form)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M_a(Î»dp_at)dotlambda = f_a(Î»dp_at)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where M_a is a function which defines the aerodynamic mass matrix, f_a is a function which defines the mass matrix multiplied aerodynamic state rates, lambda is a vector of structural states, d is a vector of structural deflections, p_a is a vector of aerodynamic parameters, and t is the current time.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The equations of motion for Peters' finite state model, when expressed in the form expected by this package are:","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"barAdotlambda = -fracUblambda +\nE d","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"E = barc beginbmatrix\nU \n1 \nb left(frac12 - aright)\nendbmatrix\nquad\nd = beginbmatrix\ndottheta \nddoth \nddottheta\nendbmatrix","category":"page"},{"location":"developer/#Defining-a-New-Type-2","page":"Developer Guide","title":"Defining a New Type","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"We start creating our aerodynamic model by defining a new type.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"\"\"\"\n    MyPeters{N,TF,SV,SA} <: AbstractModel\n\nPeters' finite state model with `N` state variables, inputs ``d = \\\\begin{bmatrix}\n\\\\dot{\\\\theta} & \\\\ddot{h} & \\\\ddot{\\\\theta}\\\\end{bmatrix}^T`` and parameters\n``p_a = \\\\begin{bmatrix} a & b & U & \\\\rho \\\\end{bmatrix}^T``\n\"\"\"\nstruct MyPeters{N,TF,TV<:SVector{N,TF},TA<:SMatrix{N,N,TF}} <: AbstractModel\n    A::TA\n    b::TV\n    c::TV\nend\n\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Here N is the number of aerodynamic state variables and TF is the floating point type used to represent the constant matrices/vectors barA, barb, and barc.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For convenience, we create a constructor which initializes matrix barA and vectors barb and barc given the number of aerodynamic state variables and floating point type.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"\"\"\"\n    MyPeters{N,TF=Float64}()\n\nInitialize an object of type `MyPeters` which has `N` aerodynamic\ndegrees of freedom.\n\"\"\"\nMyPeters{N}() where N = MyPeters{N,Float64}()\n\nfunction MyPeters{N,TF}() where {N,TF}\n\n    b = zeros(TF, N)\n    for n = 1:N-1\n        b[n] = (-1)^(n-1)*factorial(big(N + n - 1))/factorial(big(N - n - 1))*\n            1/factorial(big(n))^2\n    end\n    b[N] = (-1)^(N-1)\n\n    c = zeros(TF, N)\n    for n = 1:N\n        c[n] = 2/n\n    end\n\n    d = zeros(TF, N)\n    d[1] = 1/2\n\n    D = zeros(TF, N, N)\n    for m in 1:N-1\n        n = m + 1\n        D[n, m] = 1/(2*n)\n    end\n    for m in 2:N\n        n = m - 1\n        D[n, m] = -1/(2*n)\n    end\n\n    A = D + d*b' + c*d' + 1/2*c*b'\n\n    return MyPeters(SMatrix{N,N,TF}(A), SVector{N,TF}(b), SVector{N,TF}(c))\nend\n\nnothing #hide","category":"page"},{"location":"developer/#Defining-Model-Properties-2","page":"Developer Guide","title":"Defining Model Properties","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"We now need to define a few model properties.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate the number of state variables in our model, we define a new method for the number_of_states function.  In our case, we have an arbitrary number of aerodynamic states lambda, though typically 3-10 aerodynamic states are used with Peters' finite state model.  This method must be defined for all models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"number_of_states(::Type{MyPeters{N,TF,SV,SA}}) where {N,TF,SV,SA} = N\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate the number of inputs, we define a new method for the number_of_inputs function.  In our case, we have three inputs d = beginbmatrix dottheta  ddoth  ddottheta endbmatrix^T.  This method must be defined for all models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"number_of_inputs(::Type{<:MyPeters}) = 3\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate the number of parameters, we define a new method for the number_of_parameters function.  In our case, we have four parameters p_a = beginbmatrix a  b  U  rho endbmatrix^T.  This method must be defined for all models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"number_of_parameters(::Type{<:MyPeters}) = 4\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate whether we plan to use in-place or out-of-place functions, we define a new method for the inplaceness function.  This method must be defined for all models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"inplaceness(::Type{<:MyPeters}) = OutOfPlace()\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate mass matrix properties, we define a new method for the mass_matrix_type function.  This method must be defined for all models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"mass_matrix_type(::Type{<:MyPeters}) = Constant()\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate the properties of the jacobian of the state rates with respect to the state variables, we define a new method for the state_jacobian_type function.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"state_jacobian_type(::Type{<:MyPeters}) = Varying()\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate the properties of the jacobian of the state rates with respect to the inputs, we define a new method for the input_jacobian_type function.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"input_jacobian_type(::Type{<:MyPeters}) = Varying()\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate whether the state rates are linearly dependent on the inputs, or in other words whether the governing aerodynamic equations can be expressed as  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M_a(lambdap_at)dotlambda = f_a(lambdap_st) + D_a(lambdap_st)d","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"we define a new method for the input_dependence_type function.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"input_dependence_type(::Type{<:MyPeters}) = Linear()\nnothing #hide","category":"page"},{"location":"developer/#Mass-Matrix-Equation-2","page":"Developer Guide","title":"Mass Matrix Equation","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For out-of-place models, the mass matrix is calculated using the get_mass_matrix function.  For in-place models the mass matrix is calculated using the get_mass_matrix! function.  For constant mass matrices, these functions are called without the Î», d, p, and t arguments.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"get_mass_matrix(model::MyPeters) = model.A\nnothing #hide","category":"page"},{"location":"developer/#State-Rate-Equation-2","page":"Developer Guide","title":"State Rate Equation","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The right hand side of the governing aerodynamic differential equations is calculated using the get_rates function for out-of-place models and get_rates! function for in-place models.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_rates(model::MyPeters{N,TF,SV,SA}, Î», d, p, t) where {N,TF,SV,SA}\n    # extract aerodynamic states as statically sized vector\n    Î» = SVector{N}(Î»)\n    # extract structural deflections\n    Î¸dot, hddot, Î¸ddot = d\n    # extract parameters\n    a, b, U, Ï = p\n    # extract model constants\n    cbar = model.c\n    # calculate rates\n    return cbar*(hddot + U*Î¸dot + (b/2-a*b)*Î¸ddot) - U/b*Î»\nend\n\nnothing #hide","category":"page"},{"location":"developer/#State-Rate-Jacobian-2","page":"Developer Guide","title":"State Rate Jacobian","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The jacobian of the right hand side of the governing aerodynamic equations with respect to the state variables is calculated using the get_state_jacobian function for out-of-place models and get_state_jacobian! function for in-place models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_state_jacobian(model::MyPeters, Î», d, p, t)\n    # extract parameters\n    a, b, U, Ï = p\n    # extract model constants\n    cbar = model.c\n    # jacobian with respect to aerodynamic states\n    return -U/b*Diagonal(one.(cbar))\nend\n\nnothing #hide","category":"page"},{"location":"developer/#Structural-Deflection-Jacobian","page":"Developer Guide","title":"Structural Deflection Jacobian","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The jacobian of the right hand side of the governing aerodynamic equations with respect to the structural deflections is defined using the get_input_jacobian function.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_input_jacobian(model::MyPeters, Î», d, p, t)\n    # extract parameters\n    a, b, U, Ï = p\n    # extract model constants\n    cbar = model.c\n    # return jacobian\n    return hcat(U*cbar, cbar, (b/2-a*b)*cbar)\nend\n\nnothing #hide","category":"page"},{"location":"developer/#Aerodynamic-Model-Code","page":"Developer Guide","title":"Aerodynamic Model Code","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Putting it all together, a complete representation Peters' finite state aerodynamic model may be defined using the following block of code.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"\"\"\"\n    MyPeters{N,TF,SV,SA} <: AbstractModel\n\nPeter's finite state model with `N` state variables, inputs ``d = \\\\begin{bmatrix}\n\\\\dot{\\\\theta} & \\\\ddot{h} & \\\\ddot{\\\\theta}\\\\end{bmatrix}^T`` and parameters\n``p_a = \\\\begin{bmatrix} a & b & U & \\\\rho \\\\end{bmatrix}^T``\n\"\"\"\nstruct MyPeters{N,TF,TV<:SVector{N,TF},TA<:SMatrix{N,N,TF}} <: AbstractModel\n    A::TA\n    b::TV\n    c::TV\nend\n\n# --- Constructors --- #\n\n\"\"\"\n    MyPeters{N,TF=Float64}()\n\nInitialize an object of type `MyPeters` which has `N` aerodynamic\ndegrees of freedom.\n\"\"\"\nMyPeters{N}() where N = MyPeters{N,Float64}()\n\nfunction MyPeters{N,TF}() where {N,TF}\n\n    b = zeros(TF, N)\n    for n = 1:N-1\n        b[n] = (-1)^(n-1)*factorial(big(N + n - 1))/factorial(big(N - n - 1))*\n            1/factorial(big(n))^2\n    end\n    b[N] = (-1)^(N-1)\n\n    c = zeros(TF, N)\n    for n = 1:N\n        c[n] = 2/n\n    end\n\n    d = zeros(TF, N)\n    d[1] = 1/2\n\n    D = zeros(TF, N, N)\n    for m in 1:N-1\n        n = m + 1\n        D[n, m] = 1/(2*n)\n    end\n    for m in 2:N\n        n = m - 1\n        D[n, m] = -1/(2*n)\n    end\n\n    A = D + d*b' + c*d' + 1/2*c*b'\n\n    return MyPeters(SMatrix{N,N,TF}(A), SVector{N,TF}(b), SVector{N,TF}(c))\nend\n\n# --- Traits --- #\n\nnumber_of_states(::Type{MyPeters{N,TF,SV,SA}}) where {N,TF,SV,SA} = N\nnumber_of_inputs(::Type{<:MyPeters}) = 3\nnumber_of_parameters(::Type{<:MyPeters}) = 4\ninplaceness(::Type{<:MyPeters}) = OutOfPlace()\nmass_matrix_type(::Type{<:MyPeters}) = Constant()\nstate_jacobian_type(::Type{<:MyPeters}) = Varying()\ninput_jacobian_type(::Type{<:MyPeters}) = Varying()\ninput_dependence_type(::Type{<:MyPeters}) = Linear()\n\n# --- Methods --- #\n\nget_mass_matrix(model::MyPeters) = model.A\n\nfunction get_rates(model::MyPeters{N,TF,SV,SA}, Î», d, p, t) where {N,TF,SV,SA}\n    # extract aerodynamic states as statically sized vector\n    Î» = SVector{N}(Î»)\n    # extract structural deflections\n    Î¸dot, hddot, Î¸ddot = d\n    # extract parameters\n    a, b, U, Ï = p\n    # extract model constants\n    cbar = model.c\n    # calculate rates\n    return cbar*(hddot + U*Î¸dot + (b/2-a*b)*Î¸ddot) - U/b*Î»\nend\n\nfunction get_state_jacobian(model::MyPeters, Î», d, p, t)\n    # extract parameters\n    a, b, U, Ï = p\n    # extract model constants\n    cbar = model.c\n    # jacobian with respect to aerodynamic states\n    return -U/b*Diagonal(one.(cbar))\nend\n\nfunction get_input_jacobian(model::MyPeters, Î», d, p, t)\n    # extract parameters\n    a, b, U, Ï = p\n    # extract model constants\n    cbar = model.c\n    # return jacobian\n    return hcat(U*cbar, cbar, (b/2-a*b)*cbar)\nend\n\nnothing #hide","category":"page"},{"location":"developer/#Coupling-Aerodynamic-and-Structural-Models","page":"Developer Guide","title":"Coupling Aerodynamic and Structural Models","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For demonstrating how to couple aerodynamic and structural models together, we use the typical section structural model and Peters' finite state aerodynamic model.  To couple these two models together, we need to define the model inputs (aerodynamic loads and structural deflections) as functions of the states, parameters, and time.","category":"page"},{"location":"developer/#Theory-3","page":"Developer Guide","title":"Theory","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"We assume the aerodynamic loads and structural deflections may be expressed as a function of the aerodynamic and structural state variables and parameters, as well as the current time.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"d = f_d(upt) quad r = f_r(upt) ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"u = beginbmatrix lambda  q endbmatrix^T quad\np = beginbmatrix p_a  p_s endbmatrix^T quad","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"If the state rates of a given structural model are linearly dependent on the aerodynamic loads, we can expand the expression which defines the aerodynamic loads to","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"r = f_r(upt) - M_r s(upt) dotq -\nM_r a(upt) dotlambda","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where M_r s is a function which defines the (negative) jacobian of the aerodynamic loads with respect to the structural state rates and M_r a is a function which defines the (negative) jacobian of the aerodynamic loads with respect to the aerodynamic state rates.  f_r is a function which defines the portion of the aerodynamic loads which is independent of the structural and aerodynamic state rates.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"If the state rates of a given aerodynamic model are linearly dependent on the structural deflections, we can expand the expression which defines the structural deflections to","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"d = f_d(upt) - M_d s(upt) dotq -\nM_d a(upt) dotlambda","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where M_d s is a function which defines the (negative) jacobian of the structural deflections with respect to the structural state rates and M_d a is a function which defines the (negative) jacobian of the structural deflections with respect to the aerodynamic state rates.  f_d is a function which defines the portion of the structural deflections which is independent of the structural and aerodynamic state rates.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In the most general case, the coupled system of equations may be defined as","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M_u(upt) dotu = f_u(upt)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"f_u = beginbmatrix f_a f_s endbmatrix quad\nM_u = beginbmatrix M_a  0  0  M_s endbmatrix + beginbmatrix D_a  0  0  D_s endbmatrix beginbmatrix M_da  M_ds  M_ra  M_rs endbmatrix quad","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The associated jacobian is","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"fracpartial f_upartial u = beginbmatrix fracpartial f_apartial lambda endbmatrix  0  0  fracpartial f_spartial q + beginbmatrix D_a  0  0  D_s endbmatrix beginbmatrix fracpartial f_dpartial lambda  fracpartial f_dpartial q  fracpartial f_rpartial lambda  fracpartial f_rpartial q endbmatrix","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"If we introduce the combined input function","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"y = f_y(u p t) - M_y(u p t) dotu","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"y = beginbmatrix d  r endbmatrix quad f_y = beginbmatrix f_d  f_r endbmatrix quad M_y = beginbmatrix M_da  M_ds  M_ra  M_rs endbmatrix","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"the mass matrix and jacobian expressions may be shortened to","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M_u = beginbmatrix M_a  0  0  M_s endbmatrix + beginbmatrix D_a  0  0  D_s endbmatrix M_y","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"fracpartial f_upartial u =\nbeginbmatrix\nfracpartial f_apartial lambda  0 \n0  fracpartial f_spartial q\nendbmatrix +\nbeginbmatrix\nD_a  0 \n0  D_s\nendbmatrix fracpartial f_ypartial u","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"We have already implemented all of the functions in these expressions with the exception of those associated with the combined input function, so all that is required to couple the aerodynamic and structural models together is to define functions associated with the combined input function.","category":"page"},{"location":"developer/#Aerodynamic-Model-Inputs","page":"Developer Guide","title":"Aerodynamic Model Inputs","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The inputs expected by Peters' finite state model are d = beginbmatrix dottheta  ddoth  ddottheta endbmatrix^T.  These structural deflections correspond to a subset of the structural states and corresponding rates.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The structural deflections may be expressed in the form expected by this package as","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"d = J_ds q - M_ds dotq","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"J_ds = beginbmatrix 0  0  0  1  0  0  0  0  0  0  0  0 endbmatrix quad\nM_ds = beginbmatrix 0  0  0  0  0  0  -1  0  0  0  0  -1 endbmatrix","category":"page"},{"location":"developer/#Structural-Model-Inputs","page":"Developer Guide","title":"Structural Model Inputs","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The aerodynamic loads expected by the typical section model are the lift and quarter-chord moment.  The lift and quarter-chord moment, as calculated using Peters' finite state model are","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"L = pi rho_infty b^2 left( ddoth + U dottheta - b a ddottheta right) + 2 pi rho_infty U b left h + U theta + b left( frac12 - a right) dottheta - lambda_0 right","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M_frac14 = - pi rho_infty b^3 left frac12 ddoth + U dottheta + b left( frac18 - fraca2 right) ddottheta right","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where U is the freestream velocity, rho_infty is the freestream air density, and lambda_0 is the induced flow velocity.  The induced flow velocity may be approximated as a function of the aerodynamic states","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"lambda_0 approx frac12 sumlimits_n=1^Nbarb_n lambda_n","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The aerodynamic loads calculated by Peters' finite state model when coupled with the typical section model may be expressed in the form expected by this package as","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"r = J_ra lambda + J_rs q - M_rs dotq","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"r =beginbmatrix\nL \nM_frac14\nendbmatrix^T\nquad\nlambda = beginbmatrix\nlambda_1 \nlambda_2 \n \nlambda_N\nendbmatrix^T\nquad\nq = beginbmatrix\nh \ntheta \ndoth \ndottheta\nendbmatrix^T\n\nJ_rs = 2 pi rho_infty b U\nbeginbmatrix\n0  U  1   fracb2 + b left(frac12 - aright) \n0  0  0  - fracb^22\nendbmatrix\nquad\nJ_ra = - 2 pi rho_infty b U beginbmatrix barb^T  0_1 times N endbmatrix\n\nM_rs = pi rho_infty b^2\nbeginbmatrix\n0  0  -1  ba \n0  0  fracb2  b^2 left(frac18 - fraca2right)\nendbmatrix","category":"page"},{"location":"developer/#Combined-Input-Function","page":"Developer Guide","title":"Combined Input Function","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Upon combining the expressions for the aerodynamic loads and structural deflections, we obtain the following expression for the combined input function.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"y = J_y y - M_y dotu","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"J_y = beginbmatrix 0  J_ds  J_ra  J_rs  endbmatrix quad\nM_y = beginbmatrix 0  M_ds  0  M_rs endbmatrix","category":"page"},{"location":"developer/#Defining-Input-Function-Properties","page":"Developer Guide","title":"Defining Input Function Properties","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Before we define the combined input function (and its associated functions) we need to define a few of its properties.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To define whether the combined input function should use an in-place or out-of-place format, we define a new method for the inplaceness function.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"inplaceness(::Type{<:MyPeters}, ::Type{MyTypicalSection}) = OutOfPlace()\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate input function mass matrix properties, we define a new method for the mass_matrix_type function.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"mass_matrix_type(::Type{<:MyPeters}, ::Type{MyTypicalSection}) = Varying()\nnothing #hide","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To indicate the properties of the input function jacobian with respect to the state variables, we define a new method for the state_jacobian_type function.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"state_jacobian_type(::Type{<:MyPeters}, ::Type{MyTypicalSection}) = Varying()\nnothing #hide","category":"page"},{"location":"developer/#Input-Mass-Matrix-Equation","page":"Developer Guide","title":"Input Mass Matrix Equation","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For out-of-place input functions, the mass matrix is calculated using the get_input_mass_matrix function.  For in-place combined input functions, the mass matrix is calculated using the get_input_mass_matrix! function.  For constant mass matrices, these functions are called without the u, p, and t arguments.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"\nfunction get_input_mass_matrix(aero::MyPeters{N,TF,SV,SA},\n    stru::MyTypicalSection, u, p, t) where {N,TF,SV,SA}\n    # extract parameters\n    a, b, U, Ï, a, b, kh, kÎ¸, m, xÎ¸, Ip = p\n    # construct submatrices\n    Mda = zeros(SMatrix{3,N,TF})\n    Mds = @SMatrix [0 0 0 0; 0 0 -1 0; 0 0 0 -1]\n    Mra = zeros(SMatrix{2,N,TF})\n    Mrs = hcat(\n        zeros(SVector{2,TF}),\n        zeros(SVector{2,TF}),\n        -SVector(pi*Ï*b^2, -pi/2*Ï*b^3),\n        -SVector(-pi*Ï*a*b^3, -pi/8*Ï*b^4*(1 - 4*a)))\n    # assemble mass matrix\n    return [Mda Mds; Mra Mrs]\nend\n\nnothing #hide","category":"page"},{"location":"developer/#Input-Equation","page":"Developer Guide","title":"Input Equation","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The portion of the inputs which is independent of the state rates is calculated using the get_inputs function for out-of-place aerodynamic load calculations and get_inputs! function for in-place aerodynamic load calculations.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"\nfunction get_inputs(aero::MyPeters{N,TF,SV,SA}, stru::MyTypicalSection,\n    u, p, t) where {N,TF,SV,SA}\n    # indices for extracting state variables\n    iÎ» = SVector{N}(1:N)\n    iq = SVector{4}(N+1:N+4)\n    # separate aerodynamic and structural states\n    Î» = u[iÎ»]\n    q = u[iq]\n    # extract structural state variables\n    h, Î¸, hdot, Î¸dot = q\n    # extract parameters\n    a, b, U, Ï, a, b, kh, kÎ¸, m, xÎ¸, Ip = p\n    # extract model constants\n    bbar = aero.b\n    # calculate induced flow velocity\n    Î»0 = 1/2 * bbar'*Î»\n    # calculate (partial) lift\n    L = 2*pi*Ï*U*b*(hdot + U*Î¸ + (b/2-a*b)*Î¸dot - Î»0) + pi*Ï*b^2*U*Î¸dot\n    # calculate (partial) quarter-chord moment\n    M = -pi*Ï*b^3*U*Î¸dot\n    # return portion of inputs that is not dependent on the state rates\n    return SVector(Î¸dot, 0, 0, L, M)\nend\n\nnothing #hide","category":"page"},{"location":"developer/#Input-Jacobian-2","page":"Developer Guide","title":"Input Jacobian","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The jacobian of f_y with respect to the state variables is calculated using the get_input_state_jacobian function for out-of-place combined input functions and get_input_state_jacobian! function for in-place combined inputs functions.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_input_state_jacobian(aero::MyPeters{N,TF,SV,SA},\n    stru::MyTypicalSection, u, p, t) where {N,TF,SV,SA}\n    # extract parameters\n    a, b, U, Ï, a, b, kh, kÎ¸, m, xÎ¸, Ip = p\n    # extract model constants\n    bbar = aero.b\n    # compute jacobian sub-matrices\n    Jda = zeros(SMatrix{3,N,TF})\n    Jds = @SMatrix [0 0 0 1; 0 0 0 0; 0 0 0 0]\n    Jra = -pi*Ï*U*b*vcat(bbar', zero(bbar)')\n    Jrs = hcat(\n        SVector(0, 0),\n        SVector(2*pi*Ï*U^2*b, 0),\n        SVector(2*pi*Ï*U*b, 0),\n        SVector(2*pi*Ï*b^2*U*(1 - a), -pi*Ï*b^3*U)\n        )\n    # return jacobian\n    return [Jda Jds; Jra Jrs]\nend\nnothing #hide","category":"page"},{"location":"developer/#Model-Ordering","page":"Developer Guide","title":"Model Ordering","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In general, we suggest that the following ordering of model state variables, inputs, and parameters is used when constructing input functions.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Aerodynamics\nStructural\nRigid Body (when present)","category":"page"},{"location":"developer/#Avoiding-Mass-Matrices","page":"Developer Guide","title":"Avoiding Mass Matrices","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to take advantage of as many features of the DifferentialEquations package as possible (including local sensitivity analysis) we recommend that the governing differential equations for models be reformulated to avoid using mass matrices whenever possible.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Two-Dimensional-Aeroelastic-Analysis","page":"Examples","title":"Two-Dimensional Aeroelastic Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we demonstrate how to perform a two-dimensional aeroelastic analysis using a typical section model with two degrees of freedom.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The equations of motion for this model are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"m left(ddoth+b x_theta ddottheta right) + k_h h = -L \nI_P ddottheta + m b x_theta ddoth + k_theta = M","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where b is the semichord length, k_h is the linear spring constant, k_theta is the torsional spring constant, m is the mass per unit span, x_theta is the distance to the center of mass from the reference point, I_Î¸ is the moment of inertia about the reference point, L is the lift per unit span, and M is the moment per unit span about the reference point.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We use the non-dimensional parameters","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"a = -15 quad e = -110  \nr^2 = fracI_Pm b^2 quad sigma = fracomega_homega_theta \nmu = fracmrho_infty pi b^2 quad V = fracUb omega_theta","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where a is the normalized distance from the semichord to the reference point, e is the normalized distance from the semichord to the center of mass, and omega_h and omega_theta are the uncoupled natural frequencies.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"omega_h = sqrtfrack_hm quad omega_theta = sqrtfrack_thetaI_P","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We perform aeroelastic analyses using a variety of aerodynamic models in order to compare the various models.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AerostructuralDynamics, LinearAlgebra\n\n# reduced velocity range\nV = range(0, 3.1, length=5000) # (reduced velocity)\n\n# non-dimensional parameters\na = -1/5 # reference point normalized location\ne = -1/10 # center of mass normalized location\nÎ¼ = 20 # = m/(Ï*pi*b^2) (mass ratio)\nr2 = 6/25 # = IÎ¸/(m*b^2) (radius of gyration about P)\nÏ = 2/5 # = Ïh/ÏÎ¸ (natural frequency ratio)\nxÎ¸ = e - a\na0 = 2*pi # lift curve slope\nÎ±0 = 0 # zero lift angle\n\n# chosen dimensional parameters\nb = 1\nÏ = 1\nÏÎ¸ = 1\n\n# derived dimensional parameters\nm = Î¼*Ï*pi*b^2\nSÎ¸ = m*xÎ¸*b\nIÎ¸ = r2*m*b^2\nÏh = Ï*ÏÎ¸\nkh = m*Ïh^2\nkÎ¸ = IÎ¸*ÏÎ¸^2\n\n# dimensionalized velocity\nU = V*b*ÏÎ¸\n\n# aerodynamic models\naerodynamic_models = (Steady(), QuasiSteady(), Wagner(), Peters{6}())\n\n# structural model\nstructural_model = TypicalSection()\n\n# eigenvalue storage\nÎ» = Vector{Matrix{ComplexF64}}(undef, length(aerodynamic_models))\n\n# loop through each aerodynamic model\nfor (ia, aerodynamic_model) in enumerate(aerodynamic_models)\n\n    # combined models\n    models = (aerodynamic_model, structural_model)\n\n    # eigenvalue storage\n    Î»[ia] = zeros(ComplexF64, number_of_states(models), length(V))\n\n    # loop through each reduced frequency\n    for i = 1:length(V)\n        # state variables\n        u_aero = zeros(number_of_states(aerodynamic_model))\n        u_stru = zeros(number_of_states(structural_model))\n        u = vcat(u_aero, u_stru)\n\n        # parameters\n        p_aero = [a, b, Ï, a0, Î±0]\n        p_stru = [kh, kÎ¸, m, SÎ¸, IÎ¸]\n        p_input = U[i]\n        p = vcat(p_aero, p_stru, p_input)\n\n        # time\n        t = 0.0\n\n        # calculate inputs\n        y = get_inputs(models, u, p, t)\n\n        # mass matrix\n        M = get_mass_matrix(models, u, y, p, t)\n\n        # jacobian\n        J = get_state_jacobian(models, u, y, p, t)\n\n        # solve generalized eigenvalue problem\n        Î»[ia][:,i] = sort(eigvals(J, M), by=LinearAlgebra.eigsortby)\n    end\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We now plot the results predicted using each aerodynamic model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\ndefault(\n    titlefontsize = 14,\n    legendfontsize = 11,\n    guidefontsize = 14,\n    tickfontsize = 11,\n    foreground_color_legend = nothing,\n    background_color_legend = nothing,\n    minorgrid=true,\n    framestyle = :zerolines)\n\nsp1 = plot(\n    title = \"Non-Dimensional Frequency\",\n    xlim = (0,3.1),\n    xtick = 0.0:0.5:3.0,\n    xlabel = \"\\$ \\\\frac{U}{b \\\\omega_\\\\theta} \\$\",\n    ylim = (0, 1.05),\n    ytick = 0.0:0.2:1.0,\n    ylabel = \"\\$ \\\\frac{\\\\Omega}{\\\\omega_\\\\theta} \\$\",\n    legend = :topright\n    )\n\nsp2 = plot(\n    title = \"Non-Dimensional Damping\",\n    xlim = (0,3.1),\n    xtick = 0.0:0.5:3.0,\n    xlabel = \"\\$ \\\\frac{U}{b \\\\omega_\\\\theta} \\$\",\n    ylim = (-0.7, 0.605),\n    ytick = -0.6:0.2:0.6,\n    ylabel = \"\\$ \\\\frac{Î}{\\\\omega_\\\\theta} \\$\",\n    legend = :topleft\n    )\n\nlabels = [\"Steady\", \"Quasi-Steady\", \"Wagner\", \"Peters (N=6)\"]\n\nfor ia = 1:length(aerodynamic_models)\n\n    scatter!(sp1, V, imag.(Î»[ia][1,:])/ÏÎ¸,\n        label = labels[ia],\n        color = ia,\n        markersize = 1,\n        markerstrokewidth = 0,\n        )\n\n    for i = 2:size(Î»[ia], 1)\n        scatter!(sp1, V, imag.(Î»[ia][i,:])/ÏÎ¸,\n            label = \"\",\n            color = ia,\n            markersize = 1,\n            markerstrokewidth = 0,\n            )\n    end\n\n    scatter!(sp2, V, real.(Î»[ia][1,:])/ÏÎ¸,\n        label = labels[ia],\n        color = ia,\n        markersize = 1,\n        markerstrokewidth = 0,\n        )\n\n    for i = 2:size(Î»[ia], 1)\n        scatter!(sp2, V, real.(Î»[ia][i,:])/ÏÎ¸,\n            label = \"\",\n            color = ia,\n            markersize = 1,\n            markerstrokewidth = 0,\n            )\n    end\nend\n\np1 = plot(sp1, sp2, layout = (2, 1), size = (600, 800))\n\nsavefig(p1, \"two-dimensional-stability.svg\") #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The same analysis and results are presented by Hodges and Pierce in \"Introduction to Structural Dynamics and Aeroelasticity\" for the steady state and Peters' Finite State aerodynamic models.  The results shown here match with those provided by Hodges and Pierce, thus validating our implementation of these models.","category":"page"},{"location":"examples/#Three-Dimensional-Aeroelastic-Analysis","page":"Examples","title":"Three Dimensional Aeroelastic Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we demonstrate how to perform a three-dimensional aeroelastic analysis using geometrically exact beam theory in combination with various aerodynamic models.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AerostructuralDynamics, GXBeam, LinearAlgebra\n\n# velocity range\nU = range(1, 30, length=100) # m/s (velocity)\n\n# aerodynamic properties\nÏ = 0.088 # kg/m^3 (air density)\n\n# structural properties\nb = 16 # m (span)\nc = 1 # m (chord)\na = 0 # fraction of chord (Spanwise reference axis location relative to semichord)\ne = 0 # fraction of chord (Center of gravity location relative to semichord)\nGJ = 1e4 # N*m^2 (torsional rigidity)\nEIyy = 4e6 # N*m^2 (chord bending rigidity)\nEIzz = 2e4 # N*m^2 (flat bending rigidity)\nÎ¼ = 0.75 # kg/m (mass per unit span)\ni11 = 0.1 # kg*m (rotational inertia per unit span)\n\n# discretization\nN = 8 # number of elements\n\n# geometry initialization\nx = range(0, b, N+1) # point x-coordinates\ny = range(0, 0, N+1) # point y-coordinates\nz = range(0, 0, N+1) # point z-coordinates\npoints = [[x[i],y[i],z[i]] for i = 1:N]\nstart = 1:N # starting point of each beam element\nstop = 2:N+1 # ending point of each beam element\ncompliance = fill(Diagonal([0, 0, 0, 1/GJ, 1/EIyy, 1/EIzz]), N) # compliance matrix\nmass = fill(Diagonal([Î¼, Î¼, Î¼, i11, 0, 0]), N) # mass matrix\nassembly = GXBeam.Assembly(points, start, stop; compliance = compliance,\n    mass = mass)\n\n# boundary condition initialization\nprescribed_conditions = Dict(\n    1 => GXBeam.PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n        theta_z=0),\n)\n\n# distributed load initialization\ndistributed_loads = Dict()\nfor i = 1:nelem\n    distributed_loads[i] = GXBeam.DistributedLoads(assembly, i)\nend\n\n# structural system initialization\nkeep_points = [1] # points at which prescribed conditions are applied\nstatic = false # static simulation?\nsystem = GXBeam.system(assembly, keep_points, static)\n\n# construct aerodynamic model\naerodynamic_model = LiftingLine{N}(Wagner())\n\n# construct structural model\nstructural_model = GeometricallyExactBeamTheory(system, assembly, prescribed_conditions,\n    distributed_loads)\n\n# combined models\nmodels = (aerodynamic_model, structural_model)\n\n# eigenvalue storage\nÎ» = zeros(ComplexF64, number_of_states(models), length(V))\n\n# loop through each velocity\nfor i = 1:length(V)\n\n    # set initial guess for the state variables\n    u0_aero = zeros(number_of_states(aerodynamic_model))\n    u0_stru = zeros(number_of_states(structural_model))\n    u0 = vcat(u_aero, u_stru)\n\n    # set parameters\n    p_aero = [a, b, U[i], Ï]\n    p_stru = [a, b, kh, kÎ¸, m, xÎ¸, IÎ¸]\n    p = vcat(p_aero, p_stru)\n\n    # set time\n    t = 0.0\n\n    # find state variables corresponding to steady state operating conditions\n\n\n    # calculate inputs for steady state operating conditions\n    y = get_inputs(models, u, p, t)\n\n    # calculate mass matrix for steady state operating conditions\n    M = get_mass_matrix(models, u, y, p, t)\n\n    # calculate jacobian for steady state operating conditions\n    J = get_state_jacobian(models, u, y, p, t)\n\n    # solve generalized eigenvalue problem\n    Î»[ia][:,i] = sort(eigvals(J, M), by=LinearAlgebra.eigsortby)\nend\n\nnothing #hide","category":"page"},{"location":"#AerostructuralDynamics","page":"Home","title":"AerostructuralDynamics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Aerostructural Dynamics Analysis and Simulation Framework","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author: Taylor McDonnell","category":"page"},{"location":"","page":"Home","title":"Home","text":"AerostructuralDynamics is an aerostructural model coupling and analysis tool which simulates the behavior of coupled or decoupled aerodynamic, structural, and/or rigid-body dynamics models.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Provides a framework for coupling aerodynamic and structural models for analysis and/or simulation.\nInterfaces with DifferentialEquations to simulate the behavior of aerostructural models. #TODO\nDefines a variety of aerodynamic and structural models\nAerodynamic Models:\nSteady (2D)\nQuasi-Steady (2D)\nWagner's Function (2D)\nPeters' Finite State (2D)\nSteady Vortex Lattice (3D) #TODO\nQuasi-Steady Vortex Lattice (3D) #TODO\nUnsteady Vortex Lattice (3D) #TODO\nStructural Dynamics Models:\nTypical Section (2D)\nGeometrically Exact Beam Assemblies (3D) #TODO\nDynamics Models:\nRigid Body (3D) #TODO\nDefines the following coupled models\nTypical Section with:\nSteady (2D)\nQuasi-Steady (2D)\nWagner's Function (2D)\nPeters' Finite State (2D)\nGeometrically Exact Beam Assemblies with:\nQuasi-Steady (2D) #TODO\nWagner's Function (2D) #TODO\nPeters' Finite State (2D) #TODO\nSteady Vortex Lattice (3D) #TODO\nQuasi-Steady Vortex Lattice (3D) #TODO\nUnsteady Vortex Lattice (3D) #TODO\nVerifications and/or validations of implemented models (see the examples)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Enter the package manager by typing ] and then run the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://flow.byu.edu/AerostructuralDynamics.jl","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the examples","category":"page"}]
}
