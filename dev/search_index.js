var documenterSearchIndex = {"docs":
[{"location":"aerodynamics/steady/#Steady-Thin-Airfoil-Theory","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"","category":"section"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"(Image: )","category":"page"},{"location":"aerodynamics/steady/#Theory","page":"Steady Thin Airfoil Theory","title":"Theory","text":"","category":"section"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"This model is a steady linear 2D aerodynamic model derived from thin airfoil theory.  As it is a steady model, it has no state variables and/or state equations.  At the reference location, located a b aft of the semi-chord, the normal force and moment per unit span are defined as","category":"page"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"mathcalN = a_0 rho_infty u^2 b alpha_texteff \nmathcalM = b left(frac12 + a right) mathcalN","category":"page"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"where u is the local freestream velocity in the chordwise direction, a defines the reference location, b is the semi-chord, a_0 is the lift curve slope, rho_infty is the air density. and alpha_texteff is the effective angle of attack.  The effective angle of attack for this model is defined as","category":"page"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"alpha_texteff = -fracvu - alpha_0","category":"page"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"where v is the local freestream velocity in the airfoil normal direction and alpha_0 is the zero lift angle of attack.","category":"page"},{"location":"aerodynamics/steady/#Type-Definition","page":"Steady Thin Airfoil Theory","title":"Type Definition","text":"","category":"section"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"Steady","category":"page"},{"location":"aerodynamics/steady/#AerostructuralDynamics.Steady","page":"Steady Thin Airfoil Theory","title":"AerostructuralDynamics.Steady","text":"Steady <: NoStateModel\n\n2D steady aerodynamic model with parameters a b a_0 alpha_0.\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/steady/#Constructors","page":"Steady Thin Airfoil Theory","title":"Constructors","text":"","category":"section"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"Steady()","category":"page"},{"location":"aerodynamics/steady/#AerostructuralDynamics.Steady-Tuple{}","page":"Steady Thin Airfoil Theory","title":"AerostructuralDynamics.Steady","text":"Steady()\n\nInitialize an object of type Steady which represents a 2D steady aerodynamic model.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/steady/#Example-Initialization","page":"Steady Thin Airfoil Theory","title":"Example Initialization","text":"","category":"section"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"using AerostructuralDynamics #hide\nmodel = Steady()\nnothing #hide","category":"page"},{"location":"aerodynamics/quasisteady/#quasi-steady-thin-airfoil-theory","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory Model","text":"","category":"section"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"(Image: )","category":"page"},{"location":"aerodynamics/quasisteady/#Theory","page":"Quasi-Steady Thin Airfoil Theory","title":"Theory","text":"","category":"section"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"This model is a quasi-steady linear 2D aerodynamic model derived from thin airfoil theory.  As it is a quasi-steady model, it has no state variables and/or state equations.  At the reference location, located a b aft of the semi-chord, the normal force and moment per unit span are defined as","category":"page"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"mathcalN = a_0 rho_infty u^2 b alpha_texteff + pi rho b^2 left(-dotv + uomega - a b dotomega right) \nmathcalM = -pi rho_infty b^3 left -frac12dotv + uomega + b left( frac18 - fraca2 right) dotomega right + b left(frac12 + a right) mathcalN","category":"page"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"where u is the local freestream velocity in the chordwise direction, v is the local freestream velocity in the normal direction, omega is the freestream angular velocity, a defines the reference location, b is the semichord, a_0 is the lift curve slope, rho_infty is the air density, and alpha_texteff is the effective angle of attack.  The effective angle of attack for this model is defined as","category":"page"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"alpha_texteff = - fracvu + fracbuleft( frac12 - a right) omega - alpha_0","category":"page"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"where alpha_0 is the zero lift angle of attack.","category":"page"},{"location":"aerodynamics/quasisteady/#Type-Definition","page":"Quasi-Steady Thin Airfoil Theory","title":"Type Definition","text":"","category":"section"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"QuasiSteady","category":"page"},{"location":"aerodynamics/quasisteady/#AerostructuralDynamics.QuasiSteady","page":"Quasi-Steady Thin Airfoil Theory","title":"AerostructuralDynamics.QuasiSteady","text":"QuasiSteady{Order} <: NoStateModel\n\n2D quasi-steady aerodynamic model with parameters a b a_0 alpha_0.\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/quasisteady/#Constructors","page":"Quasi-Steady Thin Airfoil Theory","title":"Constructors","text":"","category":"section"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"QuasiSteady()","category":"page"},{"location":"aerodynamics/quasisteady/#AerostructuralDynamics.QuasiSteady-Tuple{}","page":"Quasi-Steady Thin Airfoil Theory","title":"AerostructuralDynamics.QuasiSteady","text":"QuasiSteady()\n\nInitialize an object of type QuasiSteady which represents a 2D quasi-steady aerodynamic model.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/quasisteady/#Example-Initialization","page":"Quasi-Steady Thin Airfoil Theory","title":"Example Initialization","text":"","category":"section"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"using AerostructuralDynamics #hide\nmodel = QuasiSteady()\nnothing #hide","category":"page"},{"location":"aerodynamics/peters/#peters-finite-state-model","page":"Peters' Finite State","title":"Peters' Finite State Model","text":"","category":"section"},{"location":"aerodynamics/peters/#Theory","page":"Peters' Finite State","title":"Theory","text":"","category":"section"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"For Peter's finite state model, an additional term is added to the expression for the effective angle of attack from the quasi-steady model to account for induced velocity.","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"alpha = - fracvu + fracbuleft( frac12 - a right) omega + fraclambda_0u - alpha_0","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"The induced velocity lambda_0 is approximated from a set of N induced-flow states lambda_1 lambda_2 dots lambda_N as","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"lambda_0 approx frac12 sum_n=1^N b_n lambda_n","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"The set of N first-order ordinary differential equations which govern the N finite aerodynamic states are derived by Peters et al. as","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"barA lambda + fracub lambda = barc left -dotv + uomega + b left(frac12 - a right) dotomega right","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"where","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"barA = barD + bard barb^T + barc bard^T + frac12 barc  barb^T \nbarD_nm = begincases\nfrac12n  n=m+1 \nfrac-12n  n=m-1 \n0  n neq m pm 1 \nendcases\nquad\nbarb_n = begincases\nleft( -1 right)^n-1 frac(N+n-1)(N-n-1)frac1left(nright)^2  n neq N \nleft( -1 right)^n-1  n = N\nendcases\nquad\nbarc_n = frac2n\nquad\nbard_n = begincases\nfrac12  n = 1 \n0  n neq 1\nendcases","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"The same force and moment expressions are used as in the quasi-steady model, but with the new effective angle of attack provided above.","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"Note that while Peter's finite state model can accommodate any number of aerodynamic state variables, generally 3-10 state variables are used.","category":"page"},{"location":"aerodynamics/peters/#Type-Definition","page":"Peters' Finite State","title":"Type Definition","text":"","category":"section"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"Peters","category":"page"},{"location":"aerodynamics/peters/#AerostructuralDynamics.Peters","page":"Peters' Finite State","title":"AerostructuralDynamics.Peters","text":"Peters{N,TF,SV,SA} <: AbstractModel\n\nPeter's finite state model with N state variables, inputs u omega dotv dotomega and parameters a b a_0 alpha_0\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/peters/#Constructors","page":"Peters' Finite State","title":"Constructors","text":"","category":"section"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"Peters()","category":"page"},{"location":"aerodynamics/peters/#AerostructuralDynamics.Peters-Tuple{}","page":"Peters' Finite State","title":"AerostructuralDynamics.Peters","text":"Peters{N,TF=Float64}()\n\nInitialize an object of type Peters which has N aerodynamic degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/peters/#Example-Initialization","page":"Peters' Finite State","title":"Example Initialization","text":"","category":"section"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"using AerostructuralDynamics #hide\nmodel = Peters{6}()\nnothing #hide","category":"page"},{"location":"aerodynamics/wagner/#Wagner's-Function","page":"Wagner's Function","title":"Wagner's Function","text":"","category":"section"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"(Image: )","category":"page"},{"location":"aerodynamics/wagner/#Theory","page":"Wagner's Function","title":"Theory","text":"","category":"section"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"Wagner's function models the indicial response of aerodynamic loads under a sudden change in downwash w at the three-quarter's chord. The exact expression for Wagner's function is","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"phi(t) = frac2pi int_0^infty fracRe(C) sin ( omega (ub) t  )omega domega","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"where u is the freestream velocity in the chordwise direction, omega is the freestream angular velocity, b is the semi-chord, and C(omega) is Theodorsen's function.  In many cases, approximate versions of Wagner's function are used rather than the exact expression, of which one of the most common is the approximation of Wagner's function provided by R. T. Jones","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"phi(t) = 1 - C_1 e^-varepsilon_1 (ub) t - C_2 e^-varepsilon_2 (ub) t","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"where C_1 = 0165, C_2 = 0335, varepsilon_1 = 0455, and varepsilon_2 = 03.","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"Wagner's function may be used to model arbitrary airfoil motion using Duhamel's integral.  We start by modeling the increment in the circulatory normal force d mathcalN_c(t) at time t due to an increment in downwash d w(t) at earlier time tau as","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"fracd mathcalN_c(t)a_0 rho_infty u b =  phi(t - tau) d w(tau)","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"where phi(t) is the impulse response function, which in this case is R. T. Jones' approximation of Wagner's function.  Superimposing all previous impulse responses using Duhamel's integral yields the following expression for the instantaneous circulatory normal force.","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"fracmathcalN_ca_0 rho_infty u b = int_-infty^t d w(tau) phi(t - tau) dtau = w(0) phi(t) + int_0^t  d w(tau) phi(t - tau) d tau","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"We can transform this equation using integration by parts, yielding","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"fracmathcalN_ca_0 rho_infty u b = w(t) phi(0) - int_0^t w(tau) dphi(t - tau) dtau","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"The integral in this expression may be expressed as a function of the aerodynamic states lambda_1 and lambda_2.","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"lambda_1 = C_1 varepsilon_1 fracub int_0^t w(tau) e^-varepsilon_1 (ub) (t - tau) d tau","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"lambda_2 = C_2 varepsilon_2 fracub int_0^t w(tau) e^-varepsilon_2 (ub) (t - tau) d tau","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"lambda_1 + lambda_2 = - int_0^t w(tau) dphi(t-tau) dtau","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"The expression for the circulatory normal force then reduces to","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"fracmathcalN_ca_0 rho_infty u b = w(t) phi(0) + lambda_1 + lambda_2","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"where the downwash at the three quarter's chord is given by","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"w(t) = -v + b left( frac12 - a right) omega - ualpha_0","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"and the aerodynamic states variables lambda_1 and lambda_2 are described by the ordinary differential equations","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"dotlambda_1 = -varepsilon_1 fracub lambda_1 + C_1 varepsilon_1 fracub w(t) \ndotlambda_2 = -varepsilon_2 fracub lambda_2 + C_2 varepsilon_2 fracub w(t)","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"The same lift and moment expressions are used as in the quasi-steady model, but with the following effective angle of attack","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"alpha_texteff = left(-fracvu + fracbu left( frac12 - a right) omega - alpha_0 right) phi(0) + fraclambda_1u + fraclambda_2u","category":"page"},{"location":"aerodynamics/wagner/#Type-Definition","page":"Wagner's Function","title":"Type Definition","text":"","category":"section"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"Wagner","category":"page"},{"location":"aerodynamics/wagner/#AerostructuralDynamics.Wagner","page":"Wagner's Function","title":"AerostructuralDynamics.Wagner","text":"Wagner{TF} <: AbstractModel\n\nAerodynamic model based on Wagner's function with state variables lambda_1 lambda_2, inputs u v omega, and parameters a b a_0 alpha_0\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/wagner/#Constructors","page":"Wagner's Function","title":"Constructors","text":"","category":"section"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"Wagner()","category":"page"},{"location":"aerodynamics/wagner/#AerostructuralDynamics.Wagner-Tuple{}","page":"Wagner's Function","title":"AerostructuralDynamics.Wagner","text":"Wagner(; C1=0.165, C2=0.335, eps1 = 0.0455, eps2 = 0.3)\n\nInitialize an object of type Wagner\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/wagner/#Example-Initialization","page":"Wagner's Function","title":"Example Initialization","text":"","category":"section"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"using AerostructuralDynamics #hide\nmodel = Wagner()\nnothing #hide","category":"page"},{"location":"developer/#Developer's-Guide","page":"Developer Guide","title":"Developer's Guide","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In this guide, we describe how to create new independent and/or coupled models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"developer/#Creating-a-New-Model","page":"Developer Guide","title":"Creating a New Model","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In this section, we describe in detail how to construct a new independent model.  To demonstrate this process, we also show how one might implement the TypicalSection model.","category":"page"},{"location":"developer/#Manipulating-a-Model's-Governing-Equations","page":"Developer Guide","title":"Manipulating a Model's Governing Equations","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Before a model can be used with this package, its governing equations must be manipulated so that it satisfies the ordinary differential equation (or differential algebraic equation in mass matrix form)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M(xypt)dotx = f(xypt)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where M(x y p t) is a function which defines the mass matrix corresponding to the differential equation, f(x y p t) is a function which defines the mass matrix multiplied state rates, x is a vector of state variables, y is a vector of inputs, p is a vector of parameters, and t is the current time.  State variables are variables which have rate equations associated with them.  Inputs are variables which may be defined in time, possibly using other models.  Parameters are variables which are user-specified and constant in time.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For example, the governing differential equation for the TypicalSection model is often expressed as the second order ordinary differential equation","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"beginbmatrix m  S_theta  S_theta  I_theta endbmatrix\nbeginbmatrix ddoth  ddottheta endbmatrix +\nbeginbmatrix k_h  0  0  k_h endbmatrix\nbeginbmatrix h  theta endbmatrix =\nbeginbmatrix -mathcalL  mathcalM endbmatrix","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where k_h is the linear spring constant, k_theta is the torsional spring constant, m is the mass per unit span, S_theta is the structural imbalance, I_theta is the mass moment of inertia, mathcalL is the lift per unit span, and mathcalM is the moment per unit span.  Expressed in the form expected by this package, the governing differential equation for this model is","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M dotx = K x + D y","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"x = beginbmatrix h  theta  doth  dottheta endbmatrix^T quad\ny = beginbmatrix mathcalL  mathcalM endbmatrix^T","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M =\nbeginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  m  S_theta \n    0  0  S_theta  I_P\nendbmatrix\nquad\nK =\nbeginbmatrix\n0  0  1  0 \n0  0  0  1 \n-k_h  0  0  0 \n0  -k_theta  0  0\nendbmatrix\nquad\nD =\nbeginbmatrix\n0  0 \n0  0 \n-1  0 \n0  1\nendbmatrix","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"A special type of model which trivially satisfies the form of the governing differential equations expected by this package is a model with no state variables and/or inputs.  These models are designated as being subtypes of abstract type NoStateModel and are used solely to define the inputs of other models.  For example, the Steady and QuasiSteady models may be used to calculate the inputs corresponding to the TypicalSection model, but have no state variables of their own.","category":"page"},{"location":"developer/#Defining-a-Model's-Type","page":"Developer Guide","title":"Defining a Model's Type","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Once the governing differential equations for a model has been manipulated into the expected format, and the state variables, inputs, and parameters for the model have been identified, the first step in defining a new model is to define a new type.  A docstring should also be provided along with the new type definition which defines the identities of the elements of the state, input, and parameter vectors for the model.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For example, the type definition for the TypicalSection is defined as","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"\"\"\"\n    TypicalSection <: AbstractModel\n\nTypical section structural model with state variables ``h, \\\\theta, \\\\dot{h},\n\\\\dot{\\\\theta}``, inputs ``\\\\mathcal{L}, \\\\mathcal{M}``, and parameters ``k_h,\nk_\\\\theta, m, S_\\\\theta, I_\\\\theta``\n\"\"\"\nstruct TypicalSection <: AbstractModel end","category":"page"},{"location":"developer/#Defining-Model-Traits","page":"Developer Guide","title":"Defining Model Traits","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The next step in defining a new model is to define the model's properties.  At a minimum, this requires defining new methods for the number_of_states, number_of_inputs, number_of_parameters, and inplaceness functions, though additional method definitions may be necessary.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The length of the model's state, input and parameter vectors is specified by defining new methods for the number_of_states, number_of_inputs, and number_of_parameters functions.  For out-of-place models, these methods must operate the model type so that the vector sizes are completely inferrable.  For in-place models, this restriction is loosened and these methods may operate on model instances instead.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Whether a model uses in-place or out-of-place function definitions is specified by defining a new method for the inplaceness function, which operates on the model type. For performance reasons, in-place functions are generally preferred.  The one exception is for models with small numbers of state variables, in which case the preferred approach is to use static arrays with out-of-place functions.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The properties of the model's mass matrix, state jacobian, and/or input jacobian are defined by defining new methods for the mass_matrix_type, state_jacobian_type, and/or input_jacobian_type functions, respectively.  By default, these properties assume their loosest possible definitions.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"As an example, the TypicalSection model's properties are defined using the following block of code.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"number_of_states(::Type{TypicalSection}) = 4\nnumber_of_inputs(::Type{TypicalSection}) = 2\nnumber_of_parameters(::Type{TypicalSection}) = 5\ninplaceness(::Type{TypicalSection}) = OutOfPlace()\nmass_matrix_type(::Type{TypicalSection}) = Linear()\nstate_jacobian_type(::Type{TypicalSection}) = Linear()\ninput_jacobian_type(::Type{TypicalSection}) = Constant()","category":"page"},{"location":"developer/#Defining-Methods-for-Governing-Equations","page":"Developer Guide","title":"Defining Methods for Governing Equations","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Once the properties of a model have been defined, methods must be provided for the model which define its governing equations.  The right hand side of the governing structural differential equations is calculated using the get_rates function for out-of-place models or the get_rates! function for in-place models.  For models with mass matrices, a new method must also be defined for the get_mass_matrix function (or get_mass_matrix! function if the model's functions are in-place functions).  For constant mass matrices (mass_matrix_type(typeof(model)) == Constant()), this function should be defined without the x, y, p, and t arguments.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For example, the governing equations for the TypicalSection model may be defined using the following block of code","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_rates(::TypicalSection, x, y, p, t)\n    # extract state variables\n    h, θ, hdot, θdot = x\n    # extract inputs\n    L, M = y\n    # extract parameters\n    kh, kθ, m, Sθ, Iθ = p\n    # calculate state rates\n    return SVector(hdot, θdot, -kh*h - L, -kθ*θ + M)\nend\n\nfunction get_mass_matrix(::MyTypicalSection, x, y, p, t)\n    # extract structural parameters\n    kh, kθ, m, Sθ, Iθ = p\n    # calculate mass matrix\n    return @SMatrix [1 0 0 0; 0 1 0 0; 0 0 m Sθ; 0 0 Sθ Iθ]\nend","category":"page"},{"location":"developer/#Defining-Methods-for-Jacobians","page":"Developer Guide","title":"Defining Methods for Jacobians","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Unless otherwise specified, the jacobian of the governing differential equations for a given model with respect to the state variables and/or inputs is calculated when necessary using forward automatic differentiation (enabled by the ForwardDiff package).  While this approach for computing the jacobians is convenient and exact, alternative methods for computing jacobians may be more computationally efficient.  To manually define the jacobian of the right hand side of the governing equations with respect to the state variables, a new method for get_state_jacobian (or get_state_jacobian! for in-place models) may be defined.  To manually define the jacobian of the right hand side of the governing equations with respect to the inputs, a new method for get_input_jacobian may be defined.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For the TypicalSection model, these jacobians may be defined analytically using the following block of code","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_state_jacobian(::MyTypicalSection, q, r, p, t)\n    # extract parameters\n    a, b, kh, kθ, m, xθ, Ip = p\n    # return jacobian\n    return @SMatrix [0 0 1 0; 0 0 0 1; -kh 0 0 0; 0 -kθ 0 0]\nend\n\nget_input_jacobian(::MyTypicalSection) = @SMatrix [0 0; 0 0; -1 0; 0 1]","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Note that while there is no in-place version of the get_input_jacobian function it may be constructed as either a linear map (for large matrices) or static array (for small matrices) in order to avoid allocations.","category":"page"},{"location":"developer/#Defining-Methods-for-Unit-Testing","page":"Developer Guide","title":"Defining Methods for Unit Testing","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to test whether provided mass matrices are correct for a given model, a new method for get_lhs() (which defines the left hand side of the governing differential equations) must be provided.  Since this function is only used for testing, there is no in-place version of this function.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For the TypicalSection model, the new method could be defined as follows","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_lhs(::TypicalSection, dq, q, r, p, t)\n    # extract structural parameters\n    kh, kθ, m, Sθ, Iθ = p\n    # extract state rates\n    dh, dθ, dhdot, dθdot = dq\n    # calculate mass matrix product\n    return SVector(dh, dθ, m*dhdot + Sθ*dθdot, Sθ*dhdot + Iθ*dθdot)\nend","category":"page"},{"location":"developer/#Creating-a-New-Model-Coupling","page":"Developer Guide","title":"Creating a New Model Coupling","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In this section, we describe in detail how to construct a new model by coupling multiple existing models together.  To demonstrate this process, we also how one might implement the Wagner and TypicalSection model coupling.","category":"page"},{"location":"developer/#Coupled-Model-Theory","page":"Developer Guide","title":"Coupled Model Theory","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To construct a coupled model, we first concatenate the governing differential equations, state variables, inputs, and parameters of multiple independent models into a single system of equations.  This system of equations may be expressed as","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M(xypt)dotx = f(xypt)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"x = beginbmatrix x_1^T  x_2^T  dots  x_N^T endbmatrix^T quad\ny = beginbmatrix y_1^T  y_2^T  dots  y_N^T endbmatrix^T quad\np = beginbmatrix p_1^T  p_2^T  dots  p_N^T endbmatrix^T \nM(x y p t) = beginbmatrix\n    M_1(x_1 y_1 p_1 t)  0   0 \n    0  M_2(x_2 y_2 p_2 t)   0 \n      ddots  \n    0  0   M_N(x_N y_N p_N t)\nendbmatrix \nf(x y p t) = beginbmatrix\n    f_1(x_1 y_1 p_1 t) \n    f_2(x_2 y_2 p_2 t) \n    vdots \n    f_N(x_N y_N p_N t) \nendbmatrix","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"We then couple the models in this system of equations by allowing the inputs corresponding to each model to be defined as a function of the variables associated with the other models.  Specifically, we assume that the inputs corresponding to each model may be defined as","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"y = g(x p t) - M_y(x p t) dotx","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where g(x p t) is a function which returns a vector and M_y(x p t) is a function which returns a matrix.  If we also assume that the state rates of the coupled model returned by f(x y p t) are linearly dependent on the coupled model's inputs, at least for the non-zero rows of M_y(x p t), then the governing equations for the coupled system of equations may be expressed as","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"barM(x p t) dotx = barf(x p t)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"barM(x p t) = M(x y p t) + fracpartial fpartial y M_y(x p t)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"and","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"barf(x p t) = f(x g(x p t) p t)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For the Wagner model coupled with the TypicalSection model, the coupled model's state variables, inputs, and parameters are","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"x = beginbmatrix lambda_1  lambda_2  h  theta  doth  dottheta endbmatrix^T quad\ny = beginbmatrix u  v  omega  L  M endbmatrix^T \np = beginbmatrix a  b  a_0  alpha_0  k_h  k_theta  m  S_theta  I_theta endbmatrix^T ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The Wagner model inputs may be defined as a function of the state variables of the typical section model.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"u = U_infty \nv = doth \nomega = dottheta","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The TypicalSection model inputs may be defined using the lift and moment expressions corresponding to the Wagner model.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"mathcalL = a_0 rho_infty u^2 b alpha_texteff + pi rho b^2 left(-dotv + uomega - a b dotomega right) \nmathcalM = -pi rho_infty b^3 left -frac12dotv + uomega + b left( frac18 - fraca2 right) dotomega right + b left(frac12 + a right) mathcalL","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"alpha_texteff = left(theta - fracvu + fracbu left( frac12 - a right) omega - alpha_0 right) phi(0) + fraclambda_1u + fraclambda_2u","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to use these relationships, two additional parameters must be introduced: the freestream velocity U_infty and the freestream density rho_infty.  These parameters are simply appended to the end of the parameter vector.","category":"page"},{"location":"developer/#Defining-the-Coupled-Model","page":"Developer Guide","title":"Defining the Coupled Model","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"New coupled model's are defined by defining a new method for the couple_models function.  This function returns a tuple of models in the order in which their states, inputs, and parameters are concatenated.  A docstring should also be provided along with the method definition which defines the identities of any additional parameters, if used.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For the Wagner model coupled with the TypicalSection model, a new coupled model may be defined using the following code block.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"\"\"\"\n    couple_models(aero::Wagner, stru::TypicalSection)\n\nCreate an aerostructural model using an unsteady aerodynamic model based on\nWagner's function and a two-degree of freedom typical section model.  This model\nintroduces the freestream velocity ``U_\\\\infty`` and air density ``\\\\rho_\\\\infty``\nas additional parameters.\n\"\"\"\ncouple_models(aero::Wagner, stru::TypicalSection) = (aero, stru)","category":"page"},{"location":"developer/#Defining-the-Coupled-Model's-Traits","page":"Developer Guide","title":"Defining the Coupled Model's Traits","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The next step in defining a coupled model is to define a model's properties.  At a minimum, this requires defining new methods for the number_of_parameters and inplaceness functions, though additional method definitions may be necessary.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The number of additional parameters introduced by the coupled model is specified by defining a new method for the number_of_parameters function.  For out-of-place models, these methods must operate on the model types so that the length of the parameter vector is completely inferrable. For in-place models, this restriction is loosened and this methods may operate on model instances instead.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Whether the coupled model uses an in-place or out-of-place coupling function is defined by the inplaceness function, which operates on the model type. For performance reasons, in-place functions are generally preferred. The one exception is for coupled models with small numbers of state variables, in which case the preferred approach is to use static arrays with out-of-place functions.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The properties of the coupling function's mass matrix and/or state jacobian are defined by defining new methods for the mass_matrix_type and/or state_jacobian_type functions, respectively. By default, these properties assume their loosest possible definitions.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The properties of the Wagner model coupled with the TypicalSection model may be defined using the following block of code.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"number_of_parameters(::Type{<:Wagner}, ::Type{TypicalSection}) = 2\ninplaceness(::Type{<:Wagner}, ::Type{TypicalSection}) = OutOfPlace()\nmass_matrix_type(::Type{<:Wagner}, ::Type{TypicalSection}) = Linear()\nstate_jacobian_type(::Type{<:Wagner}, ::Type{TypicalSection}) = Nonlinear()","category":"page"},{"location":"developer/#Defining-Methods-for-Defining-the-Inputs","page":"Developer Guide","title":"Defining Methods for Defining the Inputs","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Once the properties of a coupled model have been defined, methods must be provided for the model which define the values of its inputs. The portion of the inputs which is independent of the state rates is calculated using the get_inputs function for out-of-place coupling functions or the get_inputs! function for in-place coupling functions. For models with inputs that are also linearly dependent on the state rates, a new method must also be defined for the get_input_mass_matrix function (or get_input_mass_matrix! function if the inputs are defined in-place). For constant mass matrices (massmatrixtype(typeof.(models)...) == Constant()), this function should be defined without the x, p, and t arguments.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"As an example, the expressions defining the inputs for the Wagner model coupled with the TypicalSection model may be defined using the following block of code.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_inputs(aero::Wagner, stru::TypicalSection, s, p, t)\n    # extract state variables\n    λ1, λ2, h, θ, hdot, θdot = s\n    # extract parameters\n    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p\n    # extract model constants\n    C1 = aero.C1\n    C2 = aero.C2\n    # local freestream velocity components\n    u = U\n    v = U*θ + hdot\n    ω = θdot\n    # circulatory load factor\n    tmp1 = a0*ρ*u*b\n    # non-circulatory load factor\n    tmp2 = pi*ρ*b^3\n    # constant based on geometry\n    d = b/2 - a*b\n    # Wagner's function at t = 0.0\n    ϕ0 = 1 - C1 - C2\n    # lift at reference point\n    L = tmp1*((v + d*ω - u*α0)*ϕ0 + λ1 + λ2) + tmp2*u/b*ω\n    # moment at reference point\n    M = -tmp2*u*ω + (b/2 + a*b)*L\n    # return portion of inputs that is not dependent on the state rates\n    return SVector(u, v, ω, L, M)\nend\n\nfunction get_input_mass_matrix(aero::Wagner, stru::TypicalSection, s, p, t)\n    # extract parameters\n    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p\n    # non-circulatory load factor\n    tmp = pi*ρ*b^3\n    # lift at reference point\n    L_hddot = tmp/b\n    L_θddot = -a*tmp\n    # moment at reference point\n    M_hddot = -tmp/2 + (b/2 + a*b)*L_hddot\n    M_θddot = -tmp*(b/8 - a*b/2) + (b/2 + a*b)*L_θddot\n    # construct submatrices\n    Mda = @SMatrix [0 0; 0 0; 0 0]\n    Mds = @SMatrix [0 0 0 0; 0 0 0 0; 0 0 0 0]\n    Mra = @SMatrix [0 0; 0 0]\n    Mrs = @SMatrix [0 0 -L_hddot -L_θddot; 0 0 -M_hddot -M_θddot]\n    # assemble mass matrix\n    return [Mda Mds; Mra Mrs]\nend","category":"page"},{"location":"developer/#Defining-Methods-for-the-Coupling-Function's-Jacobians","page":"Developer Guide","title":"Defining Methods for the Coupling Function's Jacobians","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Unless otherwise specified, the jacobian of the expression for the inputs of a given coupled model with respect to the state variables is calculated when necessary using forward automatic differentiation (enabled by the ForwardDiff package). While this approach for computing the jacobians is convenient and exact, alternative methods for computing jacobians may be more computationally efficient. To manually define the jacobian of the coupling function with respect to the state variables, a new method for the get_input_state_jacobian (or get_input_state_jacobian! for inputs which are defined in-place) may be defined.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For the Wagner model coupled with the TypicalSection model, this jacobian may be defined analytically using the following block of code.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_input_state_jacobian(aero::Wagner, stru::TypicalSection, u, p, t) where {N,TF,SV,SA}\n    # extract parameters\n    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p\n    # extract model constants\n    C1 = aero.C1\n    C2 = aero.C2\n    # local freestream velocity components\n    v_θ = U\n    v_hdot = 1\n    ω_θdot = 1\n    # calculate loads\n    r_λ = wagner_loads_λ(a, b, ρ, a0, U)\n    L_h, M_h = wagner_loads_h()\n    L_θ, M_θ = wagner_loads_θ(a, b, ρ, a0, C1, C2, U)\n    L_hdot, M_hdot = wagner_loads_v(a, b, ρ, a0, C1, C2, U)\n    L_θdot, M_θdot = wagner_loads_ω(a, b, ρ, a0, C1, C2, U)\n    # compute jacobian sub-matrices\n    Jda = @SMatrix [0 0; 0 0; 0 0]\n    Jds = @SMatrix [0 0 0 0; 0 v_θ v_hdot 0; 0 0 0 ω_θdot]\n    Jra = r_λ\n    Jrs = @SMatrix [L_h L_θ L_hdot L_θdot; M_h M_θ M_hdot M_θdot]\n    # return jacobian\n    return [Jda Jds; Jra Jrs]\nend\n\nfunction wagner_loads_λ(a, b, ρ, a0, u)\n    tmp1 = a0*ρ*u*b\n    tmp2 = (b/2 + a*b)*tmp1\n    return @SMatrix [tmp1 tmp1; tmp2 tmp2]\nend\n\nwagner_loads_h() = SVector(0, 0)\n\nfunction wagner_loads_θ(a, b, ρ, a0, C1, C2, u)\n    ϕ0 = 1 - C1 - C2\n    L_θ = a0*ρ*b*u^2*ϕ0\n    M_θ = (b/2 + a*b)*L_θ\n    return SVector(L_θ, M_θ)\nend\n\nfunction wagner_loads_v(a, b, ρ, a0, C1, C2, u)\n    # Wagner's function at t = 0.0\n    ϕ0 = 1 - C1 - C2\n    # lift at reference point\n    L_v = a0*ρ*u*b*ϕ0\n    # moment at reference point\n    M_v = (b/2 + a*b)*L_v\n\n    return SVector(L_v, M_v)\nend\n\nfunction wagner_loads_ω(a, b, ρ, a0, C1, C2, u)\n    # circulatory load factor\n    tmp1 = a0*ρ*u*b\n    # non-circulatory load factor\n    tmp2 = pi*ρ*b^3\n    # constant based on geometry\n    d = b/2 - a*b\n    # Wagner's function at t = 0.0\n    ϕ0 = 1 - C1 - C2\n    # lift at reference point\n    L_ω = tmp1*d*ϕ0 + tmp2*u/b\n    # moment at reference point\n    M_ω = -tmp2*u + (b/2 + a*b)*L_ω\n\n    return SVector(L_ω, M_ω)\nend","category":"page"},{"location":"developer/#Defining-Methods-for-Unit-Testing-2","page":"Developer Guide","title":"Defining Methods for Unit Testing","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to test whether the provided mass matrices are correct for a given coupled model, a new method for get_inputs_from_state_rates (which defines the portion of the inputs that are dependent on the state rates) must be provided.  Since this function is used for testing, there is no in-place version of this function.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For the Wagner model coupled with the TypicalSection model, this function could be defined as follows","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_inputs_from_state_rates(aero::Wagner, stru::TypicalSection,\n    ds, s, p, t)\n    # extract state rates\n    dλ1, dλ2, dh, dθ, dhdot, dθdot = ds\n    # extract parameters\n    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p\n    # local freestream velocity components\n    udot = 0\n    vdot = dhdot\n    ωdot = dθdot\n    # non-circulatory load factor\n    tmp = pi*ρ*b^3\n    # lift at reference point\n    L = tmp*(vdot/b - a*ωdot)\n    # moment at reference point\n    M = -tmp*(vdot/2 + b*(1/8 - a/2)*ωdot) + (b/2 + a*b)*L\n    # return inputs\n    return SVector(0, 0, 0, L, M)\nend","category":"page"},{"location":"developer/#Model-Ordering","page":"Developer Guide","title":"Model Ordering","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In general, we suggest that the following model order is used when constructing coupled models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Aerodynamics\nStructural\nRigid Body (when present)","category":"page"},{"location":"developer/#Avoiding-Mass-Matrices","page":"Developer Guide","title":"Avoiding Mass Matrices","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to take advantage of as many features of the DifferentialEquations package as possible (including local sensitivity analysis), at this point in time we recommend that the governing differential equations for models be reformulated to avoid using mass matrices whenever possible.","category":"page"},{"location":"structures/rigidbody/#Rigid-Body-Model","page":"Rigid Body","title":"Rigid Body Model","text":"","category":"section"},{"location":"structures/rigidbody/#Theory","page":"Rigid Body","title":"Theory","text":"","category":"section"},{"location":"structures/rigidbody/","page":"Rigid Body","title":"Rigid Body","text":"A basic six degree of freedom rigid body model based on the SixDOF package.","category":"page"},{"location":"structures/rigidbody/#Type-Definition","page":"Rigid Body","title":"Type Definition","text":"","category":"section"},{"location":"structures/rigidbody/","page":"Rigid Body","title":"Rigid Body","text":"RigidBody","category":"page"},{"location":"structures/rigidbody/#AerostructuralDynamics.RigidBody","page":"Rigid Body","title":"AerostructuralDynamics.RigidBody","text":"RigidBody <: AbstractModel\n\nSix-degree of freedom rigid body dynamic model with state variables x y z phi theta psi u v w p q r, inputs m I_xx I_yy I_zz I_xz I_xy I_yz F_x F_y F_z M_x M_y M_z and zero parameters.\n\n\n\n\n\n","category":"type"},{"location":"structures/rigidbody/#Constructors","page":"Rigid Body","title":"Constructors","text":"","category":"section"},{"location":"structures/rigidbody/","page":"Rigid Body","title":"Rigid Body","text":"RigidBody()","category":"page"},{"location":"structures/rigidbody/#AerostructuralDynamics.RigidBody-Tuple{}","page":"Rigid Body","title":"AerostructuralDynamics.RigidBody","text":"RigidBody()\n\nInitialize an object of type RigidBody\n\n\n\n\n\n","category":"method"},{"location":"structures/rigidbody/#Example-Initialization","page":"Rigid Body","title":"Example Initialization","text":"","category":"section"},{"location":"structures/rigidbody/","page":"Rigid Body","title":"Rigid Body","text":"using AerostructuralDynamics #hide\nmodel = RigidBody()\nnothing #hide","category":"page"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [AerostructuralDynamics]\nPublic = false\nPrivate = true","category":"page"},{"location":"library/internals/#AerostructuralDynamics.AbstractModel","page":"Internals","title":"AerostructuralDynamics.AbstractModel","text":"AbstractModel\n\nSupertype for all models.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#AerostructuralDynamics.LiftingLineSection","page":"Internals","title":"AerostructuralDynamics.LiftingLineSection","text":"LiftingLineSection <: AbstractModel\n\nLifting line section model with state variables v_x v_y v_z omega_x omega_y omega_z, inputs F_x F_y F_z M_x M_y M_z, and zero parameters.  Two-dimensional aerodynamic models may be extended to three-dimensional models by coupling with this model.  Note that this model has no rate equations of its own since its state variables are defined as functions of the 3D structural model's state variables.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#AerostructuralDynamics.NoStateModel","page":"Internals","title":"AerostructuralDynamics.NoStateModel","text":"NoStateModel <: AbstractModel\n\nSupertype for all models which contain no state variables.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#AerostructuralDynamics.get_input_jacobian-Union{Tuple{TM}, Tuple{TM, Vararg{Any, N} where N}} where TM","page":"Internals","title":"AerostructuralDynamics.get_input_jacobian","text":"get_input_jacobian(models)\nget_input_jacobian(models, u, y, p, t)\n\nCalculate the jacobian with respect to the inputs for the specified model or models.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.get_input_mass_matrix","page":"Internals","title":"AerostructuralDynamics.get_input_mass_matrix","text":"get_input_mass_matrix(models)\nget_input_mass_matrix(models, u, p, t)\n\nCalculate the input function mass matrix for the specified combination of models.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.get_input_mass_matrix!","page":"Internals","title":"AerostructuralDynamics.get_input_mass_matrix!","text":"get_input_mass_matrix!(My, models)\nget_input_mass_matrix!(My, models, u, p, t)\n\nIn-place version of get_input_mass_matrix.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.get_input_state_jacobian","page":"Internals","title":"AerostructuralDynamics.get_input_state_jacobian","text":"get_input_state_jacobian(models::NTuple{N,AbstractModel}, u, p, t) where N\n\nCalculate the jacobian of the input function with respect to the state variables for the specified combination of models.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.get_input_state_jacobian!","page":"Internals","title":"AerostructuralDynamics.get_input_state_jacobian!","text":"get_input_state_jacobian!(J, models, u, p, t)\n\nIn-place version of get_input_state_jacobian\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.get_inputs_from_state_rates-NTuple{4, Any}","page":"Internals","title":"AerostructuralDynamics.get_inputs_from_state_rates","text":"get_inputs_from_state_rates(models, u, p, t)\n\nCalculate the portion of the inputs which are dependent on the state rates.  This function is used to test the mass matrices associated with each input mass matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.get_lhs-NTuple{5, Any}","page":"Internals","title":"AerostructuralDynamics.get_lhs","text":"get_lhs(model, u, y, p, t)\n\nReturn the left hand side of the governing differential equations for the model. This method is used for testing the mass matrix associated with each model.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.inplaceness-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Internals","title":"AerostructuralDynamics.inplaceness","text":"inplaceness(::Type{T})\n\nReturn InPlace() if functions associated with model T are in-place or OutOfPlace() if functions associated with model T are out-of-place.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.inplaceness-Union{Tuple{Vararg{Type, N}}, Tuple{N}} where N","page":"Internals","title":"AerostructuralDynamics.inplaceness","text":"inplaceness(::Type{T1}, ::Type{T2}, ..., ::Type{TN})\n\nReturn InPlace() if the functions associated with the input function for coupled models T1, T2, ... TN are in-place or OutOfPlace() if the functions associated with the input function for coupled models T1, T2, ... TN are out-of-place.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.input_jacobian_type-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Internals","title":"AerostructuralDynamics.input_jacobian_type","text":"input_jacobian_type(::Type{T})\n\nReturn\n\nEmpty(), if the jacobian of the mass matrix multiplied state rates  with respect to the inputs is empty for model T\nZeros(), if the jacobian of the mass matrix multiplied state rates  with respect to the inputs is filled with zeros for model T\nIdentity(), if the jacobian of the mass matrix multiplied state rates  with respect to the inputs is the identity matrix for model T\nConstant(), if the jacobian of the mass matrix multiplied state rates  with respect to the inputs is constant with respect to time for model T\nLinear(), if the jacobian of the mass matrix multiplied state rates  with respect to the inputs may vary with respect to time for model T, and  is linear with respect to the inputs\nNonlinear(), if the jacobian of the mass matrix multiplied state rates  with respect to the inputs may vary with respect to time for model T, and  is nonlinear with respect to the inputs\n\nIf no method is defined for the specified type, return Nonlinear().\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.mass_matrix_type-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Internals","title":"AerostructuralDynamics.mass_matrix_type","text":"mass_matrix_type(::Type{T})\n\nReturn\n\nEmpty(), if the mass matrix associated with model T is empty\nZeros(), if the mass matrix associated with model T is filled  with zeros\nIdentity(), if the mass matrix associated with model T is the  identity matrix\nConstant(), if the mass matrix associated with model T is  constant with respect to time\nLinear(), if the mass matrix associated with model T may vary  with respect to time\n\nIf no method is defined for the specified type, return Linear().\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.state_jacobian_type-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Internals","title":"AerostructuralDynamics.state_jacobian_type","text":"state_jacobian_type(::Type{T})\n\nReturn\n\nEmpty(), if the jacobian of the mass matrix multiplied state rates  with respect to the state variables associated with model T is empty\nZeros(), if the jacobian of the mass matrix multiplied state rates  with respect to the state variables associated with model T is filled  with zeros\nIdentity(), if the jacobian of the mass matrix multiplied state rates  with respect to the state variables associated with model T is the  identity matrix\nConstant(), if the jacobian of the mass matrix multiplied state rates  with respect to the state variables associated with model T is  constant with respect to time\nLinear(), if the jacobian of the mass matrix multiplied state rates  with respect to the state variables associated with model T may vary  with respect to time, but is linear with respect to the states\nNonlinear(), if the jacobian of the mass matrix multiplied state rates  with respect to the state variables associated with model T may vary  with respect to time, and is nonlinear with respect to the states\n\nIf no method is defined for the specified type, return Nonlinear().\n\n\n\n\n\n","category":"method"},{"location":"couplings/liftingline-rigidbody/#[LiftingLine](@ref)-[RigidBody](@ref)","page":"Lifting Line + Rigid Body","title":"LiftingLine + RigidBody","text":"","category":"section"},{"location":"couplings/liftingline-rigidbody/#Theory","page":"Lifting Line + Rigid Body","title":"Theory","text":"","category":"section"},{"location":"couplings/liftingline-rigidbody/","page":"Lifting Line + Rigid Body","title":"Lifting Line + Rigid Body","text":"This model is defined by coupling the lifting line aerodynamics model with the rigid body model.","category":"page"},{"location":"couplings/liftingline-rigidbody/#Constructors","page":"Lifting Line + Rigid Body","title":"Constructors","text":"","category":"section"},{"location":"couplings/liftingline-rigidbody/","page":"Lifting Line + Rigid Body","title":"Lifting Line + Rigid Body","text":"couple_models(aero::LiftingLine, stru::RigidBody)","category":"page"},{"location":"couplings/liftingline-rigidbody/#AerostructuralDynamics.couple_models-Tuple{LiftingLine, RigidBody}","page":"Lifting Line + Rigid Body","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::LiftingLine, stru::RigidBody)\n\nCreate an aerostructural model using a lifting line aerodynamic model coupled with a rigid body model.  This model introduces additional parameters corresponding to the freestream velocity components V_x V_y V_z, air density rho, gravitational constant g, inertial properties m Ixx Iyy Izz Ixz Ixy Iyz, and constant applied forces/moments (in the body frame) Fx Fy Fz Mx My Mz, followed by the length, position, and orientation of each lifting line element L p_e e_1 e_2 e_3.\n\nNOTE: When using this model, the local frame for each lifting line element should be oriented with the x-axis in the chordwise direction, the y-axis in the spanwise direction (out the right wing), and the z-axis in the airfoil normal direction\n\n\n\n\n\n","category":"method"},{"location":"couplings/liftingline-rigidbody/#Example-Initialization","page":"Lifting Line + Rigid Body","title":"Example Initialization","text":"","category":"section"},{"location":"couplings/liftingline-rigidbody/","page":"Lifting Line + Rigid Body","title":"Lifting Line + Rigid Body","text":"using AerostructuralDynamics #hide\nmodel = couple_models(LiftingLine{6}(Wagner()), RigidBody())\nnothing #hide","category":"page"},{"location":"couplings/liftingline-gxbeam/#[LiftingLine](@ref)-[GEBT](@ref)","page":"Lifting Line + Geometrically Exact Beam Theory","title":"LiftingLine + GEBT","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam/#Theory","page":"Lifting Line + Geometrically Exact Beam Theory","title":"Theory","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam/","page":"Lifting Line + Geometrically Exact Beam Theory","title":"Lifting Line + Geometrically Exact Beam Theory","text":"This model is defined by coupling the lifting line aerodynamics model with the geometrically exact beam theory model.","category":"page"},{"location":"couplings/liftingline-gxbeam/#Constructors","page":"Lifting Line + Geometrically Exact Beam Theory","title":"Constructors","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam/","page":"Lifting Line + Geometrically Exact Beam Theory","title":"Lifting Line + Geometrically Exact Beam Theory","text":"couple_models(aero::LiftingLine, stru::GEBT)","category":"page"},{"location":"couplings/liftingline-gxbeam/#AerostructuralDynamics.couple_models-Tuple{LiftingLine, GEBT}","page":"Lifting Line + Geometrically Exact Beam Theory","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::LiftingLine, stru::GEBT)\n\nCreate an aerostructural model using a lifting line aerodynamic model coupled with a geometrically exact beam theory model.  This model introduces additional parameters corresponding to the freestream velocity components V_x V_y V_z, followed by the air density rho, followed by the external loads F_xi F_yi F_zi M_xi M_yi M_zi or displacements u_xi u_yi u_zi theta_xi theta_yi theta_zi for each node, followed by the constant distributed loads f_xi f_yi f_zi m_xi m_yi m_zi for each beam element (excluding aerodynamic loads), followed by the body frame linear and angular velocity u v w p q r.\n\nNOTE: When using this model, the local frame for each beam element should be oriented with the x-axis along the beam's axis, the y-axis forward, and the z-axis normal to the surface\n\n\n\n\n\n","category":"method"},{"location":"couplings/liftingline-gxbeam/#Example-Initialization","page":"Lifting Line + Geometrically Exact Beam Theory","title":"Example Initialization","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam/","page":"Lifting Line + Geometrically Exact Beam Theory","title":"Lifting Line + Geometrically Exact Beam Theory","text":"using AerostructuralDynamics, GXBeam, LinearAlgebra\n\n# discretization\nN = 8 # number of elements\n\n# geometric properties\nspan = 6.096 # m (wing half span)\nchord = 1.8288 # m (chord)\n\n# structural section properties\nxea = 0.33*chord # m (elastic axis, from leading edge)\nEIcc = 9.77e6 # N*m^2 (flat bending rigidity)\nGJ = 0.99e6 # N*m^2 (torsional rigidity)\nμ = 35.71 # kg/m (mass per unit length)\nxcm = 0.43*chord # m (center of mass, from leading edge)\ni11 = 8.64 # kg*m (moment of inertia about elastic axis)\ni22 = 0.1*i11 # moment of inertia about beam y-axis\ni33 = 0.9*i11 # moment of inertia about beam z-axis\n\n# define geometry\nxpt = range(0, 0, length=N+1) # point x-coordinates (in body frame)\nypt = range(0, span, length=N+1) # point y-coordinates (in body frame)\nzpt = range(0, 0, length=N+1) # point z-coordinates (in body frame)\npoints = [[xpt[i],ypt[i],zpt[i]] for i = 1:N+1]\nstart = 1:N # starting point of each beam element\nstop = 2:N+1 # ending point of each beam element\nframes = fill([0 1 0; 1 0 0; 0 0 -1], N) # local to body frame transformation\ncompliance = fill(Diagonal([0, 0, 0, 1/GJ, 1/EIcc, 0]), N) # compliance matrix\nxm2 = xea - xcm\nmass = fill([\n    μ 0 0 0 0 -μ*xm2;\n    0 μ 0 0 0 0;\n    0 0 μ μ*xm2 0 0;\n    0 0 μ*xm2 i11 0 0;\n    0 0 0 0 i22 0;\n    -μ*xm2 0 0 0 0 i33], N) # mass matrix\nassembly = GXBeam.Assembly(points, start, stop; frames, compliance, mass)\n\n# boundary condition initialization\nprescribed = Dict(\n    # fixed left edge\n    1 => GXBeam.PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n        theta_z=0),\n)\n\naero = LiftingLine{N}(Wagner())\n\nstru = GEBT(assembly, prescribed)\n\nmodel = couple_models(aero, stru)\n\nnothing #hide","category":"page"},{"location":"couplings/quasisteady-section/#[QuasiSteady](@ref)-[TypicalSection](@ref)","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"QuasiSteady + TypicalSection","text":"","category":"section"},{"location":"couplings/quasisteady-section/#Theory","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Theory","text":"","category":"section"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"This model is defined by coupling quasi-steady thin airfoil theory aerodynamics","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"with the typical section model.  ","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"To facilitate this coupling, the freestream velocity components u and v are assumed to be aligned with the undeflected chordwise and normal directions, respectively, so that","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"u approx U_infty \nv approx doth \nomega approx dottheta","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"where U_infty is the freestream velocity magnitude, theta is pitch, and h is plunge. To capture the effect of twist on the circulatory lift (since it is no longer implicitly modeled by the fracvu quantity) twist is added to the effective angle of attack from the quasi-steady model so that the effective angle of attack is now given by","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"alpha_texteff = theta - fracvu + fracbuleft( frac12 - a right) omega - alpha_0","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"The original expression for the effective angle of attack may be used by defining the new variable barv = u theta + v such that","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"alpha_texteff = -fracbarvu + fracbuleft( frac12 - a right) omega - alpha_0","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"A small angle assumption is also used to define the lift about the reference location as","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"mathcalL approx mathcalN","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"where mathcalN is the normal force per unit span at the reference location.","category":"page"},{"location":"couplings/quasisteady-section/#Constructors","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Constructors","text":"","category":"section"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"couple_models(aero::QuasiSteady, stru::TypicalSection)","category":"page"},{"location":"couplings/quasisteady-section/#AerostructuralDynamics.couple_models-Tuple{QuasiSteady, TypicalSection}","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::QuasiSteady, stru::TypicalSection)\n\nCreate an aerostructural model using a quasi-steady aerodynamics model and a two-degree of freedom typical section model.  This model introduces the freestream velocity U and air density rho as additional parameters.\n\n\n\n\n\n","category":"method"},{"location":"couplings/quasisteady-section/#Example-Initialization","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Example Initialization","text":"","category":"section"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"using AerostructuralDynamics #hide\nmodel = couple_models(QuasiSteady(), TypicalSection())\nnothing #hide","category":"page"},{"location":"guide/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# this is placed here to pre-install matplotlib so the documentation doesn't get cluttered with the installation print statements.\nusing Plots\npyplot()\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"In this guide we introduce you to the basic functionality of this package in a step by step manner.  This is a good starting point for learning about how to use this package.  For more details about how to use a particular model, the model documentation is likely a better resource.  For more examples of how to use this package see the examples.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"If you haven't yet, now would be a good time to install AerostructuralDynamics.  AerostructuralDynamics can be installed from the Julia REPL by typing ] (to enter the package manager) and then running the following command.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"pkg> add https://flow.byu.edu/AerostructuralDynamics.jl","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Now, that the package is installed we need to load it so that we can use it.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using AerostructuralDynamics\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For the purposes of this guide, we will be working with a two-degree-of-freedom typical section model, as shown in the following figure.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Our goal is to create an 2D aeroelastic model which we can use to simulate the behavior of this system.","category":"page"},{"location":"guide/#Initializing-the-Aeroelastic-Model","page":"Getting Started","title":"Initializing the Aeroelastic Model","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For the aerodynamic model, we will be using Peter's finite state model with four aerodynamic state variables.  For the structural model, we will be using the typical section model.  To couple these models together, we use the couple_models function.  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"aerodynamic_model = Peters{4}() # we use four aerodynamic state variables\nstructural_model = TypicalSection()\ncoupled_model = couple_models(aerodynamic_model, structural_model)\nnothing #hide","category":"page"},{"location":"guide/#Defining-State-Variables,-Inputs,-and-Parameters","page":"Getting Started","title":"Defining State Variables, Inputs, and Parameters","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The governing equations for all models in this package may be expressed as the first order ordinary differential equation","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"M(xypt)dotx = f(xypt)","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"where M(xypt) is a function which defines the mass matrix corresponding to the differential equation, f(x y p t) is a function which defines the mass matrix multiplied state rates, x is a vector of states, y is a vector of inputs/coupling variables, p is a vector of parameters, and t is the current time.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"As described in the documentation for Peters, the state, input, and parameter vectors for the aerodynamic model are","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"x_textaero = beginbmatrix lambda_1  lambda_2  vdots  lambda_N endbmatrix quad\ny_textaero = beginbmatrix u  v  omega endbmatrix quad\np = beginbmatrix a  b  a_0  alpha_0 endbmatrix","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"where lambda_1 lambda_2 dots lambda_N are the aerodynamic states, u is the chordwise freestream velocity, v is the normal freestream velocity, omega is the angular freestream velocity, a is the normalized reference location relative to the semi-chord, b is the semi-chord, a_0 is the section lift slope, and alpha_0 is the section zero lift angle of attack.  Positive freestream velocity components are defined as shown in the following figure.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"As described in the documentation for TypicalSection, the state, input, and parameter vectors for the typical section model are defined as","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"x_textstru = beginbmatrix h  theta  doth  dottheta endbmatrix quad y_textstru = beginbmatrix mathcalL  mathcalM endbmatrix quad p_textstru = beginbmatrix k_h  k_theta  m  S_theta  I_theta endbmatrix","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"where h is plunge, theta is pitch, mathcalL is the lift per unit span, mathcalM is the moment per unit span about the reference point, k_h is the linear spring constant, and k_theta is the torsional spring constant, m is the mass per unit span, S_theta is the structural imbalance, and I_θ is the mass moment of inertia about the reference point.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The state variables and inputs of a coupled model correspond to the state variables and inputs of its component models concatenated.  The parameters of a coupled model correspond to the parameters of its component models concatenated, followed by additional parameters which are specific to the coupled model.  As noted in the coupled model's documentation, the additional parameters introduced by the coupled model is the freestream velocity U_infty and air density rho.  The state, input, and parameter vectors for the coupled model are therefore","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"x_textcoupled = beginbmatrix lambda_1  lambda_2  vdots  lambda_N  h  theta  doth  dottheta endbmatrix quad y_textcoupled = beginbmatrix u  v  omega  mathcalL  mathcalM endbmatrix quad p_textcoupled = beginbmatrix a  b  a_0  alpha_0  k_h  k_theta  m  S_theta  I_theta  U_infty  rho endbmatrix","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# state variables\nx_coupled = zeros(number_of_states(coupled_model))\n\n# non-dimensional parameters\na = -1/5 # reference point normalized location\ne = -1/10 # center of mass normalized location\nμ = 20 # = m/(ρ*pi*b^2) (mass ratio)\nr2 = 6/25 # = Iθ/(m*b^2) (radius of gyration about P)\nσ = 2/5 # = ωh/ωθ (natural frequency ratio)\nxθ = e - a\na0 = 2*pi # lift curve slope\nα0 = 0 # zero lift angle\nV = 1.0 # = U/(b*ωθ) (reduced velocity)\n\n# chosen dimensional parameters\nb = 1\nρ = 1\nωθ = 1\n\n# derived dimensional parameters\nm = μ*ρ*pi*b^2\nSθ = m*xθ*b\nIθ = r2*m*b^2\nωh = σ*ωθ\nkh = m*ωh^2\nkθ = Iθ*ωθ^2\nU = V*b*ωθ\n\n# parameter vector\np_aero = [a, b, a0, α0]\np_stru = [kh, kθ, m, Sθ, Iθ]\np_additional = [U, ρ]\np_coupled = vcat(p_aero, p_stru, p_additional)\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For coupled models, inputs are calculated as a function of the model states, model parameters, and current time using the get_inputs function.  For uncoupled models, inputs are provided by the user.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"t = 0 # time\n\ny_coupled = get_inputs(coupled_model, x_coupled, p_coupled, t) # inputs\nnothing #hide","category":"page"},{"location":"guide/#Performing-a-Stability-Analysis","page":"Getting Started","title":"Performing a Stability Analysis","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The stability of a model for a given set of state variables, inputs, and parameters may be determined by calling the get_eigen function, which returns eigenvalues, left eigenvectors, and right eigenvectors.  For nonlinear systems, the provided state variables must correspond to an equilibrium point for the stability analysis to be theoretically valid.  In our case, our aeroelastic system is linear, so all sets of state variables yield the same result.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"λ, U, V = get_eigen(coupled_model, x_coupled, y_coupled, p_coupled, t)\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"A positive real part corresponding to any eigenvalue returned from the get_eigen function indicates that the system is unstable for the provided set of state variables, inputs, and parameters.","category":"page"},{"location":"guide/#Performing-a-Simulation","page":"Getting Started","title":"Performing a Simulation","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To simulate the behavior of our model we first need to create an object of type DifferentialEquations.ODEFunction using get_ode.  Then the DifferentialEquations package may be used to solve the ordinary differential equation corresponding to the model.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using DifferentialEquations\n\n# non-zero plunge degree of freedom\nu0 = [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0]\n\n# simulate for 10 seconds\ntspan = (0.0, 10.0)\n\n# construct ODE function\nf = get_ode(coupled_model)\n\n# construct ODE problem\nprob = DifferentialEquations.ODEProblem(f, u0, tspan, p_coupled)\n\n# solve ODE\nsol = DifferentialEquations.solve(prob)\n","category":"page"},{"location":"aerodynamics/liftingline/#Lifting-Line-Model","page":"Lifting Line","title":"Lifting Line Model","text":"","category":"section"},{"location":"aerodynamics/liftingline/#Theory","page":"Lifting Line","title":"Theory","text":"","category":"section"},{"location":"aerodynamics/liftingline/","page":"Lifting Line","title":"Lifting Line","text":"Two-dimensional aerodynamic models may be applied in the context of a three-dimensional analysis by applying these models at multiple chordwise sections along the span of one or more lifting surfaces.  This type of model is applicable when spanwise flow effects are negligible, which is often the case for high aspect ratio wings.","category":"page"},{"location":"aerodynamics/liftingline/","page":"Lifting Line","title":"Lifting Line","text":"The lifting line model implemented in this package assumes that the aerodynamics of each section is independent of the aerodynamics of the other sections, except as coupled through other models.  The state variables and inputs for this model correspond to the state variables, inputs, and parameters of each of the two-dimensional aerodynamic models, concatenated.  Rate equations are also concatenated.  ","category":"page"},{"location":"aerodynamics/liftingline/","page":"Lifting Line","title":"Lifting Line","text":"When coupled with a structural model, aircraft linear and angular accelerations are obtained from the structural model and transformed into the (deformed) local beam frame using an appropriate transformation matrix.  The local freestream velocities/accelerations and pitch rates/accelerations are then defined by a subset of the transformed linear and angular accelerations and cross-flow effects are neglected.   An inverse transformation may then be performed to transform the local aerodynamic forces/moments into the reference frame used by the structural model.","category":"page"},{"location":"aerodynamics/liftingline/#Type-Definition","page":"Lifting Line","title":"Type Definition","text":"","category":"section"},{"location":"aerodynamics/liftingline/","page":"Lifting Line","title":"Lifting Line","text":"LiftingLine","category":"page"},{"location":"aerodynamics/liftingline/#AerostructuralDynamics.LiftingLine","page":"Lifting Line","title":"AerostructuralDynamics.LiftingLine","text":"LiftingLine{N,T} <: AbstractModel\n\nLifting line model with N cross sections, using the aerodynamic models in T. State variables, inputs, and parameters correspond to the state variables, inputs, and parameters of each of the cross sections concatenated\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/liftingline/#Constructors","page":"Lifting Line","title":"Constructors","text":"","category":"section"},{"location":"aerodynamics/liftingline/","page":"Lifting Line","title":"Lifting Line","text":"LiftingLine(models)","category":"page"},{"location":"aerodynamics/liftingline/#AerostructuralDynamics.LiftingLine-Tuple{Any}","page":"Lifting Line","title":"AerostructuralDynamics.LiftingLine","text":"LiftingLine(models)\n\nConstruct a lifting line aerodynamic model given a tuple of 2D aerodynamic models.\n\n\n\n\n\nLiftingLine{N}(model)\n\nConstruct a lifting line aerodynamic model using N instances of model.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/liftingline/#Example-Initialization","page":"Lifting Line","title":"Example Initialization","text":"","category":"section"},{"location":"aerodynamics/liftingline/","page":"Lifting Line","title":"Lifting Line","text":"using AerostructuralDynamics #hide\nmodel = LiftingLine{4}(Wagner())\nnothing #hide","category":"page"},{"location":"couplings/peters-section/#[Peters](@ref)-[TypicalSection](@ref)","page":"Peters' Finite State + Typical Section","title":"Peters + TypicalSection","text":"","category":"section"},{"location":"couplings/peters-section/#Theory","page":"Peters' Finite State + Typical Section","title":"Theory","text":"","category":"section"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"This model is defined by coupling Peter's finite state model","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"with the typical section model.  ","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"To facilitate this coupling, the freestream velocity components u and v are assumed to be aligned with the undeflected chordwise and normal directions, respectively, so that","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"u approx U_infty \nv approx doth \nomega approx dottheta","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"where U_infty is the freestream velocity magnitude, theta is pitch, and h is plunge. To capture the effect of twist on the circulatory lift (since it is no longer implicitly modeled by the fracvu quantity) twist is added to the effective angle of attack from Peter's finite state model so that the effective angle of attack is now given by","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"alpha_texteff = theta - fracvu + fracbuleft( frac12 - a right) omega  + fraclambda_0u - alpha_0","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"The original expression for the effective angle of attack may be used by defining the new variable barv = u theta + v such that","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"alpha_texteff = -fracbarvu + fracbuleft( frac12 - a right) omega + fraclambda_0u - alpha_0","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"A small angle assumption is also used to define the lift about the reference location as","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"mathcalL approx mathcalN","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"where mathcalN is the normal force per unit span at the reference location.","category":"page"},{"location":"couplings/peters-section/#Constructors","page":"Peters' Finite State + Typical Section","title":"Constructors","text":"","category":"section"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"couple_models(aero::Peters, stru::TypicalSection)","category":"page"},{"location":"couplings/peters-section/#AerostructuralDynamics.couple_models-Tuple{Peters, TypicalSection}","page":"Peters' Finite State + Typical Section","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::Peters, stru::TypicalSection)\n\nCreate an aerostructural model using the unsteady aerodynamic model defined by Peters et al. and a two-degree of freedom typical section model.  This model introduces the freestream velocity U_infty and air density rho_infty as additional parameters.\n\n\n\n\n\n","category":"method"},{"location":"couplings/peters-section/#Example-Initialization","page":"Peters' Finite State + Typical Section","title":"Example Initialization","text":"","category":"section"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"using AerostructuralDynamics #hide\nmodel = couple_models(Peters{6}(), TypicalSection())\nnothing #hide","category":"page"},{"location":"structures/gxbeam/#Geometrically-Exact-Beam-Theory-Model","page":"Geometrically Exact Beam Theory","title":"Geometrically Exact Beam Theory Model","text":"","category":"section"},{"location":"structures/gxbeam/#Theory","page":"Geometrically Exact Beam Theory","title":"Theory","text":"","category":"section"},{"location":"structures/gxbeam/","page":"Geometrically Exact Beam Theory","title":"Geometrically Exact Beam Theory","text":"A geometrically exact beam model implemented using the GXBeam package.","category":"page"},{"location":"structures/gxbeam/#Type-Definition","page":"Geometrically Exact Beam Theory","title":"Type Definition","text":"","category":"section"},{"location":"structures/gxbeam/","page":"Geometrically Exact Beam Theory","title":"Geometrically Exact Beam Theory","text":"GEBT","category":"page"},{"location":"structures/gxbeam/#AerostructuralDynamics.GEBT","page":"Geometrically Exact Beam Theory","title":"AerostructuralDynamics.GEBT","text":"GEBT <: AbstractModel\n\nGeometrically exact beam theory model, as implemented by the GXBeam package. State variables are as defined by GXBeam.  Inputs correspond to the body frame linear and angular velocity V_x V_y V_z Omega_x Omega_y Omega_z, followed by the external forces F_xi F_yi F_zi M_xi M_yi M_zi or displacements u_xi u_yi u_zi theta_xi theta_yi theta_zi applied to each node, followed by the distributed loads f_xi f_yi f_zi m_xi m_yi m_zi applied to each beam element, followed by the linear and angular velocity of the system. Parameters correspond to the location p_x p_y p_z of each node followed by each beam element's properties. Each beam element's properties are defined by a triad which defines the orientation of the beam element e_1x e_1y e_1z e_2x e_2y e_2z e_3x e_3y e_3z, followed by the 21 independent entries of the compliance matrix C_11 C_12 C_13 C_14 C_15 C_16 C_22 C_23 C_24 C_25 C_26 C_33 C_34 C_35 C_36 C_44 C_45 C_46 C_55 C_56 C_66, followed by the beam element's inertial properties mu x_m2 x_m3 i_22 i_33 i_23.\n\nWhen coupled with an aerodynamic model, the local beam y and z-axes should be aligned with the negative chordwise and positive normal directions, respectively.\n\n\n\n\n\n","category":"type"},{"location":"structures/gxbeam/#Constructors","page":"Geometrically Exact Beam Theory","title":"Constructors","text":"","category":"section"},{"location":"structures/gxbeam/","page":"Geometrically Exact Beam Theory","title":"Geometrically Exact Beam Theory","text":"GEBT(assembly, prescribed)","category":"page"},{"location":"structures/gxbeam/#AerostructuralDynamics.GEBT-Tuple{Any, Any}","page":"Geometrically Exact Beam Theory","title":"AerostructuralDynamics.GEBT","text":"GEBT(GXBeam.assembly, prescribed = Dict(Int, <:GXBeam.PrescribedConditions))\n\nConstruct a geometrically exact beam theory structural model with connectivity as specified in assembly and prescribed displacements (rather than forces) as specified in prescribed.\n\n\n\n\n\n","category":"method"},{"location":"structures/gxbeam/#Example-Initialization","page":"Geometrically Exact Beam Theory","title":"Example Initialization","text":"","category":"section"},{"location":"structures/gxbeam/","page":"Geometrically Exact Beam Theory","title":"Geometrically Exact Beam Theory","text":"using AerostructuralDynamics, GXBeam, LinearAlgebra\n\n# discretization\nN = 8 # number of elements\n\n# geometric properties\nspan = 6.096 # m (wing half span)\nchord = 1.8288 # m (chord)\n\n# structural section properties\nxea = 0.33*chord # m (elastic axis, from leading edge)\nEIcc = 9.77e6 # N*m^2 (flat bending rigidity)\nGJ = 0.99e6 # N*m^2 (torsional rigidity)\nμ = 35.71 # kg/m (mass per unit length)\nxcm = 0.43*chord # m (center of mass, from leading edge)\ni11 = 8.64 # kg*m (moment of inertia about elastic axis)\ni22 = 0.1*i11 # moment of inertia about beam y-axis\ni33 = 0.9*i11 # moment of inertia about beam z-axis\n\n# define geometry\nxpt = range(0, 0, length=N+1) # point x-coordinates (in body frame)\nypt = range(0, span, length=N+1) # point y-coordinates (in body frame)\nzpt = range(0, 0, length=N+1) # point z-coordinates (in body frame)\npoints = [[xpt[i],ypt[i],zpt[i]] for i = 1:N+1]\nstart = 1:N # starting point of each beam element\nstop = 2:N+1 # ending point of each beam element\nframes = fill([0 1 0; 1 0 0; 0 0 -1], N) # local to body frame transformation\ncompliance = fill(Diagonal([0, 0, 0, 1/GJ, 1/EIcc, 0]), N) # compliance matrix\nxm2 = xea - xcm\nmass = fill([\n    μ 0 0 0 0 -μ*xm2;\n    0 μ 0 0 0 0;\n    0 0 μ μ*xm2 0 0;\n    0 0 μ*xm2 i11 0 0;\n    0 0 0 0 i22 0;\n    -μ*xm2 0 0 0 0 i33], N) # mass matrix\nassembly = GXBeam.Assembly(points, start, stop; frames, compliance, mass)\n\n# boundary condition initialization\nprescribed = Dict(\n    # fixed left edge\n    1 => GXBeam.PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n        theta_z=0),\n)\n\nmodel = GEBT(assembly, prescribed)\n\nnothing #hide","category":"page"},{"location":"couplings/liftingline-gxbeam-rigidbody/#[LiftingLine](@ref)-[GEBT](@ref)-[RigidBody](@ref)","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"LiftingLine + GEBT + RigidBody","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam-rigidbody/#Theory","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"Theory","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam-rigidbody/","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","text":"This model is defined by coupling the lifting line aerodynamics model with the geometrically exact beam theory model and the rigid body dynamics model.","category":"page"},{"location":"couplings/liftingline-gxbeam-rigidbody/#Constructors","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"Constructors","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam-rigidbody/","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","text":"couple_models(aero::LiftingLine, stru::GEBT, dyn::RigidBody)","category":"page"},{"location":"couplings/liftingline-gxbeam-rigidbody/#AerostructuralDynamics.couple_models-Tuple{LiftingLine, GEBT, RigidBody}","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::LiftingLine, stru::GEBT, dyn::RigidBody)\n\nCreate an aerostructural model using a lifting line aerodynamic model coupled with a geometrically exact beam theory and rigid body model.  This model introduces additional parameters corresponding to the freestream velocity components V_x V_y V_z, air density rho, gravitational constant g, and external forces F_xi F_yi F_zi M_xi M_yi M_zi or displacements u_xi u_yi u_zi theta_xi theta_yi theta_zi applied to each node.\n\nNOTE: When using this model, the local frame for each beam element should be oriented with the x-axis along the beam's axis, the y-axis forward, and the z-axis normal to the surface\n\n\n\n\n\n","category":"method"},{"location":"couplings/liftingline-gxbeam-rigidbody/#Example-Initialization","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"Example Initialization","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam-rigidbody/","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","text":"using AerostructuralDynamics, GXBeam, LinearAlgebra\n\n# discretization\nN = 8 # number of elements\n\n# geometric properties\nspan = 6.096 # m (wing half span)\nchord = 1.8288 # m (chord)\n\n# structural section properties\nxea = 0.33*chord # m (elastic axis, from leading edge)\nEIcc = 9.77e6 # N*m^2 (flat bending rigidity)\nGJ = 0.99e6 # N*m^2 (torsional rigidity)\nμ = 35.71 # kg/m (mass per unit length)\nxcm = 0.43*chord # m (center of mass, from leading edge)\ni11 = 8.64 # kg*m (moment of inertia about elastic axis)\ni22 = 0.1*i11 # moment of inertia about beam y-axis\ni33 = 0.9*i11 # moment of inertia about beam z-axis\n\n# define geometry\nxpt = range(0, 0, length=N+1) # point x-coordinates (in body frame)\nypt = range(0, span, length=N+1) # point y-coordinates (in body frame)\nzpt = range(0, 0, length=N+1) # point z-coordinates (in body frame)\npoints = [[xpt[i],ypt[i],zpt[i]] for i = 1:N+1]\nstart = 1:N # starting point of each beam element\nstop = 2:N+1 # ending point of each beam element\nframes = fill([0 1 0; 1 0 0; 0 0 -1], N) # local to body frame transformation\ncompliance = fill(Diagonal([0, 0, 0, 1/GJ, 1/EIcc, 0]), N) # compliance matrix\nxm2 = xea - xcm\nmass = fill([\n    μ 0 0 0 0 -μ*xm2;\n    0 μ 0 0 0 0;\n    0 0 μ μ*xm2 0 0;\n    0 0 μ*xm2 i11 0 0;\n    0 0 0 0 i22 0;\n    -μ*xm2 0 0 0 0 i33], N) # mass matrix\nassembly = GXBeam.Assembly(points, start, stop; frames, compliance, mass)\n\n# boundary condition initialization\nprescribed = Dict(\n    # fixed left edge\n    1 => GXBeam.PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n        theta_z=0),\n)\n\naero = LiftingLine{N}(Wagner())\n\nstru = GEBT(assembly, prescribed)\n\ndyn = RigidBody()\n\nmodel = couple_models(aero, stru, dyn)\n\nnothing #hide","category":"page"},{"location":"structures/section/#typical-section-model","page":"Typical Section","title":"Typical Section Model","text":"","category":"section"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"(Image: )","category":"page"},{"location":"structures/section/#Theory","page":"Typical Section","title":"Theory","text":"","category":"section"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"The equations of motion for this model are:","category":"page"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"beginbmatrix m  S_theta  S_theta  I_theta endbmatrix\nbeginbmatrix ddoth  ddottheta endbmatrix +\nbeginbmatrix k_h  0  0  k_h endbmatrix\nbeginbmatrix h  theta endbmatrix =\nbeginbmatrix -mathcalL  mathcalM endbmatrix","category":"page"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"where k_h is the linear spring constant, k_theta is the torsional spring constant, m is the mass per unit span, S_theta is the structural imbalance, I_theta is the mass moment of inertia, mathcalL is the lift per unit span, and mathcalM is the moment per unit span.","category":"page"},{"location":"structures/section/#Type-Definition","page":"Typical Section","title":"Type Definition","text":"","category":"section"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"TypicalSection","category":"page"},{"location":"structures/section/#AerostructuralDynamics.TypicalSection","page":"Typical Section","title":"AerostructuralDynamics.TypicalSection","text":"TypicalSection <: AbstractModel\n\nTypical section structural model with state variables h theta doth dottheta, inputs mathcalL mathcalM, and parameters k_h k_theta m S_theta I_theta\n\n\n\n\n\n","category":"type"},{"location":"structures/section/#Constructors","page":"Typical Section","title":"Constructors","text":"","category":"section"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"TypicalSection()","category":"page"},{"location":"structures/section/#AerostructuralDynamics.TypicalSection-Tuple{}","page":"Typical Section","title":"AerostructuralDynamics.TypicalSection","text":"TypicalSection()\n\nInitialize an object of type TypicalSection\n\n\n\n\n\n","category":"method"},{"location":"structures/section/#Example-Initialization","page":"Typical Section","title":"Example Initialization","text":"","category":"section"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"using AerostructuralDynamics #hide\nmodel = TypicalSection()\nnothing #hide","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Aeroelastic-Analysis-of-a-Typical-Section","page":"Examples","title":"Aeroelastic Analysis of a Typical Section","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we demonstrate how to perform a two-dimensional aeroelastic analysis using a typical section model with two degrees of freedom.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The equations of motion for this model are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"m left(ddoth+b x_theta ddottheta right) + k_h h = -L \nI_P ddottheta + m b x_theta ddoth + k_theta = M","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where b is the semichord length, k_h is the linear spring constant, k_theta is the torsional spring constant, m is the mass per unit span, x_theta is the distance to the center of mass from the reference point, I_θ is the moment of inertia about the reference point, L is the lift per unit span, and M is the moment per unit span about the reference point.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We use the non-dimensional parameters","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"a = -15 quad e = -110  \nr^2 = fracI_Pm b^2 quad sigma = fracomega_homega_theta \nmu = fracmrho_infty pi b^2 quad V = fracUb omega_theta","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where a is the normalized distance from the semichord to the reference point, e is the normalized distance from the semichord to the center of mass, and omega_h and omega_theta are the uncoupled natural frequencies.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"omega_h = sqrtfrack_hm quad omega_theta = sqrtfrack_thetaI_P","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We perform aeroelastic analyses using a variety of aerodynamic models in order to compare the various models.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AerostructuralDynamics, LinearAlgebra\n\n# reduced velocity range\nV = range(0, 3.1, length=5000) # = U/(b*ωθ) (reduced velocity)\n\n# non-dimensional parameters\na = -1/5 # reference point normalized location\ne = -1/10 # center of mass normalized location\nμ = 20 # = m/(ρ*pi*b^2) (mass ratio)\nr2 = 6/25 # = Iθ/(m*b^2) (radius of gyration about P)\nσ = 2/5 # = ωh/ωθ (natural frequency ratio)\nxθ = e - a\na0 = 2*pi # lift curve slope\nα0 = 0 # zero lift angle\n\n# chosen dimensional parameters\nb = 1\nρ = 1\nωθ = 1\n\n# derived dimensional parameters\nm = μ*ρ*pi*b^2\nSθ = m*xθ*b\nIθ = r2*m*b^2\nωh = σ*ωθ\nkh = m*ωh^2\nkθ = Iθ*ωθ^2\n\n# dimensionalized velocity\nU = V*b*ωθ\n\n# aerodynamic models\naerodynamic_models = (Steady(), QuasiSteady(), Wagner(), Peters{6}())\n\n# structural model\nstructural_model = TypicalSection()\n\n# eigenvalue storage\nλ = Vector{Matrix{ComplexF64}}(undef, length(aerodynamic_models))\n\n# loop through each aerodynamic model\nfor (ia, aerodynamic_model) in enumerate(aerodynamic_models)\n\n    # coupled model\n    model = couple_models(aerodynamic_model, structural_model)\n\n    # eigenvalue storage\n    λ[ia] = zeros(ComplexF64, number_of_states(model), length(V))\n\n    # loop through each reduced frequency\n    for i = 1:length(V)\n        # state variables\n        u_aero = zeros(number_of_states(aerodynamic_model))\n        u_stru = zeros(number_of_states(structural_model))\n        u = vcat(u_aero, u_stru)\n\n        # parameters\n        p_aero = [a, b, a0, α0]\n        p_stru = [kh, kθ, m, Sθ, Iθ]\n        p_input = [U[i], ρ]\n        p = vcat(p_aero, p_stru, p_input)\n\n        # time\n        t = 0.0\n\n        # calculate inputs\n        y = get_inputs(model, u, p, t)\n\n        # perform linear stability analysis\n        λ[ia][:,i], Uλ, Vλ = get_eigen(model, u, y, p, t)\n    end\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We now plot the results predicted using each aerodynamic model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\ndefault(\n    titlefontsize = 14,\n    legendfontsize = 11,\n    guidefontsize = 14,\n    tickfontsize = 11,\n    foreground_color_legend = nothing,\n    background_color_legend = nothing,\n    minorgrid=true,\n    framestyle = :zerolines)\n\nsp1 = plot(\n    title = \"Non-Dimensional Frequency\",\n    xlim = (0,3.1),\n    xtick = 0.0:0.5:3.0,\n    xlabel = \"\\$ \\\\frac{U}{b \\\\omega_\\\\theta} \\$\",\n    ylim = (0, 1.05),\n    ytick = 0.0:0.2:1.0,\n    ylabel = \"\\$ \\\\frac{\\\\Omega}{\\\\omega_\\\\theta} \\$\",\n    legend = :topright\n    )\n\nsp2 = plot(\n    title = \"Non-Dimensional Damping\",\n    xlim = (0,3.1),\n    xtick = 0.0:0.5:3.0,\n    xlabel = \"\\$ \\\\frac{U}{b \\\\omega_\\\\theta} \\$\",\n    ylim = (-0.7, 0.605),\n    ytick = -0.6:0.2:0.6,\n    ylabel = \"\\$ \\\\frac{Γ}{\\\\omega_\\\\theta} \\$\",\n    legend = :topleft\n    )\n\nlabels = [\"Steady\", \"Quasi-Steady\", \"Wagner\", \"Peters (N=6)\"]\n\nfor ia = 1:length(aerodynamic_models)\n\n    scatter!(sp1, V, imag.(λ[ia][1,:])/ωθ,\n        label = labels[ia],\n        color = ia,\n        markersize = 1,\n        markerstrokewidth = 0,\n        )\n\n    for i = 2:size(λ[ia], 1)\n        scatter!(sp1, V, imag.(λ[ia][i,:])/ωθ,\n            label = \"\",\n            color = ia,\n            markersize = 1,\n            markerstrokewidth = 0,\n            )\n    end\n\n    scatter!(sp2, V, real.(λ[ia][1,:])/ωθ,\n        label = labels[ia],\n        color = ia,\n        markersize = 1,\n        markerstrokewidth = 0,\n        )\n\n    for i = 2:size(λ[ia], 1)\n        scatter!(sp2, V, real.(λ[ia][i,:])/ωθ,\n            label = \"\",\n            color = ia,\n            markersize = 1,\n            markerstrokewidth = 0,\n            )\n    end\nend\n\np1 = plot(sp1, sp2, layout = (2, 1), size = (600, 800))\n\nsavefig(p1, \"typical-section-stability.svg\") #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The same analysis and results are presented by Hodges and Pierce in \"Introduction to Structural Dynamics and Aeroelasticity\" for the steady state and Peters' Finite State aerodynamic models.  The results shown here match with those provided by Hodges and Pierce, thus validating our implementation of these models.","category":"page"},{"location":"examples/#Aeroelastic-Analysis-of-a-Cantilever-Wing","page":"Examples","title":"Aeroelastic Analysis of a Cantilever Wing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we demonstrate how to perform a three-dimensional aeroelastic analysis using geometrically exact beam theory in combination with various aerodynamic models.  We perform this analysis using the Goland wing, a low-aspect ratio prismatic metallic wing, which has been extensively used for validation.  ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AerostructuralDynamics, GXBeam, NLsolve, LinearAlgebra\n\n# discretization\nN = 8 # number of elements\n\n# geometric properties\nspan = 6.096 # m (wing half span)\nchord = 1.8288 # m (chord)\n\n# structural section properties\nxea = 0.33*chord # m (elastic axis, from leading edge)\nEIcc = 9.77e6 # N*m^2 (flat bending rigidity)\nGJ = 0.99e6 # N*m^2 (torsional rigidity)\nμ = 35.71 # kg/m (mass per unit length)\nxcm = 0.43*chord # m (center of mass, from leading edge)\ni11 = 8.64 # kg*m (moment of inertia about elastic axis)\ni22 = 0.1*i11 # moment of inertia about beam y-axis\ni33 = 0.9*i11 # moment of inertia about beam z-axis\n\n# freestream properties\nVinf = 0:5:200 # m/s (velocity)\nα = 0 # angle of attack\n\n# aerodynamic section properties\nxref = xea/chord # normalized reference location (relative to leading edge)\na = xref - 0.5 # normalized reference location (relative to semi-chord)\nb = chord / 2 # m (semi-chord)\nρ = 1.02 # kg/m^3 (air density)\na0 = 0.85*(2*pi) # lift slope (for each section)\nα0 = 0 # zero lift angle of attack (for each section)\n\n# define geometry\nxpt = range(0, 0, length=N+1) # point x-coordinates (in body frame)\nypt = range(0, span, length=N+1) # point y-coordinates (in body frame)\nzpt = range(0, 0, length=N+1) # point z-coordinates (in body frame)\npoints = [[xpt[i],ypt[i],zpt[i]] for i = 1:N+1]\nstart = 1:N # starting point of each beam element\nstop = 2:N+1 # ending point of each beam element\nframes = fill([0 1 0; 1 0 0; 0 0 -1], N) # local to body frame transformation\ncompliance = fill(Diagonal([0, 0, 0, 1/GJ, 1/EIcc, 0]), N) # compliance matrix\nxm2 = xea - xcm\nmass = fill([\n    μ 0 0 0 0 -μ*xm2;\n    0 μ 0 0 0 0;\n    0 0 μ μ*xm2 0 0;\n    0 0 μ*xm2 i11 0 0;\n    0 0 0 0 i22 0;\n    -μ*xm2 0 0 0 0 i33], N) # mass matrix\nassembly = GXBeam.Assembly(points, start, stop; frames, compliance, mass)\n\n# boundary condition initialization\nprescribed = Dict(\n    # fixed left edge\n    1 => GXBeam.PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n        theta_z=0),\n)\n\n# construct aerodynamic model\naerodynamic_model = LiftingLine{N}(Peters{6}())\n\n# construct structural model\nstructural_model = GEBT(assembly, prescribed)\n\n# define coupled model\nmodel = couple_models(aerodynamic_model, structural_model)\n\n# eigenvalue storage\nλ = zeros(ComplexF64, number_of_states(model), length(Vinf))\n\nu0 = zeros(number_of_states(model))\n\n# loop through each velocity\nfor i = 1:length(Vinf)\n\n    println(\"Vinf: \", Vinf[i])\n\n    # set state variables, parameters, and current time\n    p_aero = vcat(fill([a, b, a0, α0], N)...)\n    p_stru = set_parameters(structural_model, assembly)\n    p_additional = vcat(-Vinf[i]*cos(α), 0, -Vinf[i]*sin(α), ρ,\n        set_inputs(structural_model, assembly; prescribed=prescribed))\n    p = vcat(p_aero, p_stru, p_additional)\n    t = 0\n\n    # find state variables corresponding to steady state operating conditions\n    fresid = u -> get_rates(model, u, get_inputs(model, u, p, t), p, t)\n    sol = nlsolve(fresid, u0)\n    u = sol.zero\n\n    # calculate the inputs corresponding to steady state operating conditions\n    y = get_inputs(model, u, p, t)\n\n    # calculate the mass matrix corresponding to steady state operating conditions\n    M = get_mass_matrix(model, u, y, p, t)\n\n    # calculate the jacobian corresponding to steady state operating conditions\n    J = get_state_jacobian(model, u, y, p, t)\n\n    # solve the generalized eigenvalue problem\n    λ[:,i] = sort(eigvals(J, M), by=LinearAlgebra.eigsortby)\n\n    # update initial guess for the state variables\n    u0 .= u\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We now plot the results predicted using each aerodynamic model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\ndefault(\n    titlefontsize = 14,\n    legendfontsize = 11,\n    guidefontsize = 14,\n    tickfontsize = 11,\n    foreground_color_legend = nothing,\n    background_color_legend = nothing,\n    minorgrid=true,\n    framestyle = :zerolines)\n\nsp1 = plot(\n    xlim = (0, 200),\n    xtick = 0:40:200,\n    xlabel = \"Velocity (m/s)\",\n    ylim = (0, 1000),\n    ytick = 0:100:1000,\n    ylabel = \"Frequency (rad/s)\",\n    legend = :topright\n    )\n\nsp2 = plot(\n    xlim = (0, 200),\n    xtick = 0:40:200,\n    xlabel = \"Velocity (m/s)\",\n    ylim = (-80, 20),\n    ytick = -80:20:20,\n    ylabel = \"Damping (1/s)\",\n    legend = :topleft\n    )\n\nfor i = 1:size(λ, 1)\n\n    Vi = Vinf[:]\n    λi = λ[i,:]\n\n    scatter!(sp1, Vi, imag.(λi),\n        label = \"\",\n        color = 1,\n        markersize = 3,\n        markerstrokewidth = 0,\n        )\nend\n\nfor i = 1:size(λ, 1)\n\n    Vi = Vinf[:]\n    λi = λ[i,:]\n\n    scatter!(sp2, Vi,\n        real.(λi),\n        label = \"\",\n        color = 1,\n        markersize = 3,\n        markerstrokewidth = 0,\n        )\nend\n\np1 = plot(sp1, sp2, layout = (2, 1), size = (600, 800), show=true)\n","category":"page"},{"location":"examples/#TODO:-Aeroelastic-Analysis-of-a-Blended-Wing-Body-Aircraft","page":"Examples","title":"TODO: Aeroelastic Analysis of a Blended-Wing-Body Aircraft","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we demonstrate how to perform a three-dimensional aeroelastic analysis using geometrically exact beam theory in combination with a rigid body dynamics model and various aerodynamic models.  ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AerostructuralDynamics, GXBeam, NLsolve, LinearAlgebra\n\n# discretization\nNB = 6 # number of elements on body\nNW = 12 # number of elements on wing\nN = NB + NW # number of elements on blended wing body aircraft\n\n# wing geometry\nchord = [1.39, 0.55, 0.55] # m (chord lengths in -x-direction)\nybreak = [0.0, 0.89, 3.25] # m (span break locations in y-direction)\nsweep = 30 * pi/180 # leading edge sweep\n\n# stiffness properties\nEA = [1.69e8, 1.55e8] # N (extension stiffness)\nGJ = [2.25e6, 1.10e4] # N*m^2 (torsion stiffness)\nEIcc = [7.5e5, 1.14e4] # N*m^2 (out-of-plane bending stiffness)\nEInn = [3.5e7, 1.3e5] # N*m^2 (in-plane bending stiffness)\n\n# inertial properties\nμ = [50.0, 6.2] # kg/m (mass per unit length)\ni11 = [4.5, 5.08e-3] # kg*m (rotational inertia per unit length)\ni22 = [0.7, 5.0e-4] # kg*m (flat bending inertia per unit length)\ni33 = [22, 4.63e-3] # kg*m (edge bending inertia per unit length)\n\n# axis locations\nxref = [0.6438, 0.4560, 0.4560] .* chord # reference axis location (from leading edge)\nxcm = [0.6438, 0.4560, 0.4560] .* chord # center of gravity (from leading edge)\n\n# body definition\nxpt1 = range(0 + xref[1], ybreak[1]*tan(sweep) + xref[2]; length=NB+1)\nypt1 = range(0, ybreak[1]; length=NB+1)\nzpt1 = range(0, 0; length=NB+1)\npoints1 = [[xpt1[i],ypt1[i],zpt1[i]] for i = 1:NB+1]\nframes1 = fill( , NB)\ncompliance1 = fill(Diagonal([1/EA, 0, 0, 1/GJ, 1/EIcc, 1/EInn]), NB)\nmass1 = fill(Diagonal([μ[1], μ[1], μ[1], i11[1], i22[1], i33[1]]), NB)\na1 = linterp(xref[1]/chord[1] - 0.5, xref[2]/chord[2] - 0.5, length=NB)\nb1 = linterp(chord[1]/2, chord[2]/2, length=NB) # m (semi-chord)\na01 = fill(2*pi, NB) # lift slope (for each section)\nα01 = fill(0.0, NB) # zero lift angle of attack (for each section)\n\n# wing definition\nxpt2 = range(ybreak[1]*tan(sweep) + xref[2], ybreak[2]*tan(sweep) + xref[3];\n    length=NW+1)\nypt2 = range(ybreak[1], ybreak[2]; length=NW+1)\nzpt2 = range(0, 0; length=NW+1)\npoints2 = [[xpt2[i],ypt2[i],zpt2[i]] for i = 1:NW+1]\nframes2 = fill( , NW)\ncompliance2 = fill(Diagonal([1/EA[2], 0, 0, 1/GJ[2], 1/EIcc[2], 1/EInn[2]]), NW)\nmass2 = fill(Diagonal([μ[2], μ[2], μ[2], i11[2], i22[2], i33[2]]), NW)\na2 = linterp(xref[2]/chord[2] - 0.5, xref[3]/chord[3] - 0.5; length = NW)\nb2 = linterp(chord[2]/2, chord[3]/2; length = NW) # m (semi-chord)\na02 = fill(2*pi, NW) # lift slope (for each section)\nα02 = fill(0.0, NW) # zero lift angle of attack (for each section)\n\n# define beam assembly\npoints = vcat(points1, points2[2:end])\nframes = vcat(frames1, frames2)\nstart = 1:N # starting point of each beam element\nstop = 2:N+1 # ending point of each beam element\nassembly = GXBeam.Assembly(points, start, stop; frames, compliance, mass)\n\n# define aerodynamic section properties\na = vcat(a1, a2)\nb = vcat(b1, b2)\na0 = vcat(a01, a02)\nα0 = vcat(α01, α02)\nρ = 1.02 # kg/m^3 (air density)\n\n# boundary condition initialization\nprescribed = Dict(\n    # fixed left edge\n    1 => GXBeam.PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n        theta_z=0),\n)\n\n# construct aerodynamic model\naerodynamic_model = LiftingLine{N}(Peters{6}())\n\n# construct structural model\nstructural_model = GEBT(assembly, prescribed)\n\n# rigid body dynamics model\ndynamics_model = RigidBody()\n\n# define simulation models\nmodel = couple_models(aerodynamic_model, structural_model, dynamics_model)\n\n# eigenvalue storage\nλ = zeros(ComplexF64, number_of_states(model), length(Vinf))\n\nu0 = zeros(number_of_states(model))\n\n# loop through each velocity\nfor i = 1:length(Vinf)\n\n    println(\"Vinf: \", Vinf[i])\n\n    # set state variables, parameters, and current time\n    p_aero = vcat([(a[i], b[i], a0[i], α0[i]) for i = 1:N]...)\n    p_stru = set_parameters(structural_model, assembly)\n    p_additional = vcat(-Vinf[i]*cos(α), 0, -Vinf[i]*sin(α), ρ,\n        set_inputs(structural_model, assembly; prescribed=prescribed))\n    p = vcat(p_aero, p_stru, p_additional)\n    t = 0\n\n    # find state variables corresponding to steady state operating conditions\n    fresid = u -> get_rates(model, u, get_inputs(model, u, p, t), p, t)\n    sol = nlsolve(fresid, u0)\n    u = sol.zero\n\n    # calculate the inputs corresponding to steady state operating conditions\n    y = get_inputs(model, u, p, t)\n\n    # calculate the mass matrix corresponding to steady state operating conditions\n    M = get_mass_matrix(model, u, y, p, t)\n\n    # calculate the jacobian corresponding to steady state operating conditions\n    J = get_state_jacobian(model, u, y, p, t)\n\n    # solve the generalized eigenvalue problem\n    λ[:,i] = sort(eigvals(J, M), by=LinearAlgebra.eigsortby)\n\n    # update initial guess for the state variables\n    u0 .= u\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We now plot the results predicted using each aerodynamic model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\ndefault(\n    titlefontsize = 14,\n    legendfontsize = 11,\n    guidefontsize = 14,\n    tickfontsize = 11,\n    foreground_color_legend = nothing,\n    background_color_legend = nothing,\n    minorgrid=true,\n    framestyle = :zerolines)\n\nsp1 = plot(\n    xlim = (0, 200),\n    xtick = 0:40:200,\n    xlabel = \"Velocity (m/s)\",\n    ylim = (0, 1000),\n    ytick = 0:100:1000,\n    ylabel = \"Frequency (rad/s)\",\n    legend = :topright\n    )\n\nsp2 = plot(\n    xlim = (0, 200),\n    xtick = 0:40:200,\n    xlabel = \"Velocity (m/s)\",\n    ylim = (-80, 20),\n    ytick = -80:20:20,\n    ylabel = \"Damping (1/s)\",\n    legend = :topleft\n    )\n\nfor i = 1:size(λ, 1)\n\n    Vi = Vinf[:]\n    λi = λ[i,:]\n\n    scatter!(sp1, Vi, imag.(λi),\n        label = \"\",\n        color = 1,\n        markersize = 3,\n        markerstrokewidth = 0,\n        )\nend\n\nfor i = 1:size(λ, 1)\n\n    Vi = Vinf[:]\n    λi = λ[i,:]\n\n    scatter!(sp2, Vi,\n        real.(λi),\n        label = \"\",\n        color = 1,\n        markersize = 3,\n        markerstrokewidth = 0,\n        )\nend\n\np1 = plot(sp1, sp2, layout = (2, 1), size = (600, 800), show=true)\n","category":"page"},{"location":"couplings/steady-section/#[Steady](@ref)-[TypicalSection](@ref)","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady + TypicalSection","text":"","category":"section"},{"location":"couplings/steady-section/#Theory","page":"Steady Thin Airfoil Theory + Typical Section","title":"Theory","text":"","category":"section"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"This model is defined by coupling steady thin airfoil theory aerodynamics","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"with the typical section model.  ","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"By making use of a small angle assumption, the freestream velocity components are defined as","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"u approx U_infty \nv approx U_infty theta \nomega approx 0","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"where U_infty is the freestream velocity magnitude, theta is the pitch angle, u is the chordwise freestream velocity, v is the normal freestream velocity, and omega is the freestream angular velocity. A small angle assumption is also used to define the lift about the reference location as","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"mathcalL approx mathcalN","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"where mathcalN is the normal force per unit span at the reference location.","category":"page"},{"location":"couplings/steady-section/#Constructors","page":"Steady Thin Airfoil Theory + Typical Section","title":"Constructors","text":"","category":"section"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"couple_models(aero::Steady, stru::TypicalSection)","category":"page"},{"location":"couplings/steady-section/#AerostructuralDynamics.couple_models-Tuple{Steady, TypicalSection}","page":"Steady Thin Airfoil Theory + Typical Section","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::Steady, stru::TypicalSection)\n\nCreate an aerostructural model using a steady aerodynamics model and a two-degree of freedom typical section model.  This model introduces the freestream velocity U and air density rho as additional parameters.\n\n\n\n\n\n","category":"method"},{"location":"couplings/steady-section/#Example-Initialization","page":"Steady Thin Airfoil Theory + Typical Section","title":"Example Initialization","text":"","category":"section"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"using AerostructuralDynamics #hide\nmodel = couple_models(Steady(), TypicalSection())\nnothing #hide","category":"page"},{"location":"couplings/wagner-section/#[Wagner](@ref)-[TypicalSection](@ref)","page":"Wagner's Function + Typical Section","title":"Wagner + TypicalSection","text":"","category":"section"},{"location":"couplings/wagner-section/#Theory","page":"Wagner's Function + Typical Section","title":"Theory","text":"","category":"section"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"This model is defined by coupling Wagner's function unsteady aerodynamics","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"with the typical section model.  ","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"To facilitate this coupling, the freestream velocity components u and v are assumed to be aligned with the undeflected chordwise and normal directions, respectively, so that","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"u approx U_infty \nv approx doth \nomega approx dottheta","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"where U_infty is the freestream velocity magnitude, theta is pitch, and h is plunge. To capture the effect of twist on the circulatory lift (since it is no longer implicitly modeled by the fracvu quantity) twist is added to the effective angle of attack from the Wagner's function model so that the effective angle of attack is now given by","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"alpha_texteff = left(theta - fracvu + fracbu left( frac12 - a right) omega - alpha_0 right) phi(0) + fraclambda_1u + fraclambda_2u","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"The original expression for the effective angle of attack may be used by defining the new variable barv = u theta + v such that","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"alpha_texteff = left(-fracbarvu + fracbu left( frac12 - a right) omega - alpha_0 right) phi(0) + fraclambda_1u + fraclambda_2u","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"A small angle assumption is also used to define the lift about the reference location as","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"mathcalL approx mathcalN","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"where mathcalN is the normal force per unit span at the reference location.","category":"page"},{"location":"couplings/wagner-section/#Constructors","page":"Wagner's Function + Typical Section","title":"Constructors","text":"","category":"section"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"couple_models(aero::Wagner, stru::TypicalSection)","category":"page"},{"location":"couplings/wagner-section/#AerostructuralDynamics.couple_models-Tuple{Wagner, TypicalSection}","page":"Wagner's Function + Typical Section","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::Wagner, stru::TypicalSection)\n\nCreate an aerostructural model using an unsteady aerodynamic model based on Wagner's function and a two-degree of freedom typical section model.  This model introduces the freestream velocity U_infty and air density rho_infty as additional parameters.\n\n\n\n\n\n","category":"method"},{"location":"couplings/wagner-section/#Example-Initialization","page":"Wagner's Function + Typical Section","title":"Example Initialization","text":"","category":"section"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"using AerostructuralDynamics #hide\nmodel = couple_models(Wagner(), TypicalSection())\nnothing #hide","category":"page"},{"location":"#AerostructuralDynamics","page":"Home","title":"AerostructuralDynamics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Aerostructural Dynamics Analysis and Simulation Framework","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author: Taylor McDonnell","category":"page"},{"location":"","page":"Home","title":"Home","text":"AerostructuralDynamics is a multi-fidelity modeling and analysis framework which is designed to simulate the behavior of coupled and/or decoupled aerodynamic, structural, and/or rigid-body dynamics models.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Provides a framework for coupling multiple models together for analysis and/or simulation.\nDefines a variety of aerodynamic, structural, and dynamics models\nAerodynamic Models:\nSteady and/or Quasi-Steady Thin Airfoil Theory (2D)\nWagner's Function (2D)\nPeters' Finite State (2D)\nLifting Line (3D)\nStructural Dynamics Models:\nTwo Degree of Freedom Typical Section (2D)\nGeometrically Exact Beam Theory (As implemented by GXBeam) (3D)\nDynamics Models:\nRigid Body (3D)\nVerified and/or validated against theoretical, computational, and/or experimental results (see the examples)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Enter the package manager by typing ] and then run the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://flow.byu.edu/AerostructuralDynamics.jl","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the examples","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for AerostructuralDynamics.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"See the Models section of the manual for documentation covering the individual models.","category":"page"},{"location":"library/public/#Contents","page":"Public","title":"Contents","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"library/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"library/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"library/public/#Getting-Model-Properties","page":"Public","title":"Getting Model Properties","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following methods may be used to determine the properties of a model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"number_of_states\nnumber_of_inputs\nnumber_of_parameters","category":"page"},{"location":"library/public/#AerostructuralDynamics.number_of_states","page":"Public","title":"AerostructuralDynamics.number_of_states","text":"number_of_states(models)\n\nReturn the total number of states corresponding to the model or models.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.number_of_inputs","page":"Public","title":"AerostructuralDynamics.number_of_inputs","text":"number_of_inputs(models)\n\nReturn the total number of inputs corresponding to the model or models.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.number_of_parameters","page":"Public","title":"AerostructuralDynamics.number_of_parameters","text":"number_of_parameters(models)\n\nReturn the total number of parameters corresponding to the model or models.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Getting-Model-Indices","page":"Public","title":"Getting Model Indices","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following methods may be used to find the state, input, and parameter indices associated with each model in a coupled model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"state_indices\ninput_indices\nparameter_indices","category":"page"},{"location":"library/public/#AerostructuralDynamics.state_indices","page":"Public","title":"AerostructuralDynamics.state_indices","text":"state_indices(models)\n\nReturn the indices corresponding to the state variables for each model in models\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.input_indices","page":"Public","title":"AerostructuralDynamics.input_indices","text":"input_indices(models)\n\nReturn the indices corresponding to the input variables for each model in models\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.parameter_indices","page":"Public","title":"AerostructuralDynamics.parameter_indices","text":"parameter_indices(models)\n\nReturn the indices corresponding to the parameters for each model in models\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Getting-Model-Inputs","page":"Public","title":"Getting Model Inputs","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following methods may be used to calculate the value of the inputs for a coupled model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"get_inputs\nget_inputs!","category":"page"},{"location":"library/public/#AerostructuralDynamics.get_inputs","page":"Public","title":"AerostructuralDynamics.get_inputs","text":"get_inputs(models, u, p, t)\n\nCalculate the inputs to the specified combination of models.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.get_inputs!","page":"Public","title":"AerostructuralDynamics.get_inputs!","text":"get_inputs!(y, models::NTuple{N,AbstractModel}, u, p, t) where N\n\nIn-place version of get_inputs\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Getting-State-Rates","page":"Public","title":"Getting State Rates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following methods may be used to calculate the value of the state rates for a model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"get_rates\nget_rates!","category":"page"},{"location":"library/public/#AerostructuralDynamics.get_rates","page":"Public","title":"AerostructuralDynamics.get_rates","text":"get_rates(models, u, y, p, t)\n\nCalculate the (mass matrix multiplied) state rates for the specified model or models.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.get_rates!","page":"Public","title":"AerostructuralDynamics.get_rates!","text":"get_rates!(du, models, u, y, p, t)\n\nIn-place version of get_rates\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Getting-Mass-Matrices","page":"Public","title":"Getting Mass Matrices","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following methods may be used to calculate the mass matrix for a model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"get_mass_matrix\nget_mass_matrix!","category":"page"},{"location":"library/public/#AerostructuralDynamics.get_mass_matrix","page":"Public","title":"AerostructuralDynamics.get_mass_matrix","text":"get_mass_matrix(models)\nget_mass_matrix(models, u, y, p, t)\n\nCalculate the mass matrix for a model or combination of models.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.get_mass_matrix!","page":"Public","title":"AerostructuralDynamics.get_mass_matrix!","text":"get_mass_matrix!(M, models)\nget_mass_matrix!(M, models, u, y, p, t)\n\nIn-place version of get_mass_matrix.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Getting-Jacobians","page":"Public","title":"Getting Jacobians","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following methods may be used to calculate the jacobian of the state rates for a model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"get_state_jacobian\nget_state_jacobian!","category":"page"},{"location":"library/public/#AerostructuralDynamics.get_state_jacobian","page":"Public","title":"AerostructuralDynamics.get_state_jacobian","text":"get_state_jacobian(models, u, y, p, t)\n\nCalculate the jacobian with respect to the state variables for the specified models.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.get_state_jacobian!","page":"Public","title":"AerostructuralDynamics.get_state_jacobian!","text":"get_state_jacobian!(J, models, u, y, p, t)\n\nIn-place version of get_state_jacobian\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Performing-a-Stability-Analysis","page":"Public","title":"Performing a Stability Analysis","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following method may be used to perform a stability analysis for a model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"get_eigen","category":"page"},{"location":"library/public/#AerostructuralDynamics.get_eigen","page":"Public","title":"AerostructuralDynamics.get_eigen","text":"get_eigen(model::TM, x, y, p, t; kwargs...)\n\nReturn the eigenvalues, left eigenvector matrix, and right eigenvector matrix corresponding to the model for state variables x, inputs y, parameters p, and time t.\n\nFor in-place models, the number of eigenvalues to compute may be specified using the nev keyword argument.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Interfacing-with-DifferentialEquations","page":"Public","title":"Interfacing with DifferentialEquations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following method may be used to construct a function for use with DifferentialEquations.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"get_ode","category":"page"},{"location":"library/public/#AerostructuralDynamics.get_ode","page":"Public","title":"AerostructuralDynamics.get_ode","text":"get_ode(model)\n\nConstruct an ODEFunction corresponding to the specified model or models which may be solved using DifferentialEquations.\n\n\n\n\n\n","category":"function"}]
}
