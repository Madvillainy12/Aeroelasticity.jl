var documenterSearchIndex = {"docs":
[{"location":"aerodynamics/steady/#Steady-Thin-Airfoil-Theory","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"","category":"section"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"(Image: )","category":"page"},{"location":"aerodynamics/steady/#Theory","page":"Steady Thin Airfoil Theory","title":"Theory","text":"","category":"section"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"This model is a steady linear 2D aerodynamic model derived from thin airfoil theory.  As it is a steady model, it has no state variables and/or state equations.  At the reference location, located a b aft of the semi-chord, the normal force and moment per unit span are defined as","category":"page"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"mathcalN = a_0 rho_infty u^2 b alpha_texteff \nmathcalM = b left(frac12 + a right) mathcalN","category":"page"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"where u is the local freestream velocity in the chordwise direction, a defines the reference location, b is the semi-chord, a_0 is the lift curve slope, rho_infty is the air density. and alpha_texteff is the effective angle of attack.  The effective angle of attack for this model is defined as","category":"page"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"alpha_texteff = -fracvu - alpha_0","category":"page"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"where v is the local freestream velocity in the airfoil normal direction and alpha_0 is the zero lift angle of attack.","category":"page"},{"location":"aerodynamics/steady/#Type-Definition","page":"Steady Thin Airfoil Theory","title":"Type Definition","text":"","category":"section"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"Steady","category":"page"},{"location":"aerodynamics/steady/#AerostructuralDynamics.Steady","page":"Steady Thin Airfoil Theory","title":"AerostructuralDynamics.Steady","text":"Steady <: NoStateModel\n\n2D steady aerodynamic model with parameters a b a_0 alpha_0 c_d0 c_m0.\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/steady/#Constructors","page":"Steady Thin Airfoil Theory","title":"Constructors","text":"","category":"section"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"Steady()","category":"page"},{"location":"aerodynamics/steady/#AerostructuralDynamics.Steady-Tuple{}","page":"Steady Thin Airfoil Theory","title":"AerostructuralDynamics.Steady","text":"Steady()\n\nInitialize an object of type Steady which represents a 2D steady aerodynamic model.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/steady/#Example-Usage","page":"Steady Thin Airfoil Theory","title":"Example Usage","text":"","category":"section"},{"location":"aerodynamics/steady/","page":"Steady Thin Airfoil Theory","title":"Steady Thin Airfoil Theory","text":"Aeroelastic Analysis of a Typical Section","category":"page"},{"location":"aerodynamics/quasisteady/#quasi-steady-thin-airfoil-theory","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory Model","text":"","category":"section"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"(Image: )","category":"page"},{"location":"aerodynamics/quasisteady/#Theory","page":"Quasi-Steady Thin Airfoil Theory","title":"Theory","text":"","category":"section"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"This model is a quasi-steady linear 2D aerodynamic model derived from thin airfoil theory.  As it is a quasi-steady model, it has no state variables and/or state equations.  At the reference location, located a b aft of the semi-chord, the normal force and moment per unit span are defined as","category":"page"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"mathcalN = a_0 rho_infty u^2 b alpha_texteff + pi rho b^2 left(dotv + uomega - a b dotomega right) \nmathcalM = -pi rho_infty b^3 leftfrac12dotv + uomega + b left( frac18 - fraca2 right) dotomega right + b left(frac12 + a right) mathcalN","category":"page"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"where u is the local freestream velocity in the chordwise direction, v is the local freestream velocity in the normal direction, omega is the freestream angular velocity, a defines the reference location, b is the semichord, a_0 is the lift curve slope, rho_infty is the air density, and alpha_texteff is the effective angle of attack.  The effective angle of attack for this model is defined as","category":"page"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"alpha_texteff = fracvu + fracbuleft( frac12 - a right) omega - alpha_0","category":"page"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"where alpha_0 is the zero lift angle of attack.","category":"page"},{"location":"aerodynamics/quasisteady/#Type-Definition","page":"Quasi-Steady Thin Airfoil Theory","title":"Type Definition","text":"","category":"section"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"QuasiSteady","category":"page"},{"location":"aerodynamics/quasisteady/#AerostructuralDynamics.QuasiSteady","page":"Quasi-Steady Thin Airfoil Theory","title":"AerostructuralDynamics.QuasiSteady","text":"QuasiSteady{Order} <: NoStateModel\n\n2D quasi-steady aerodynamic model with parameters a b a_0 alpha_0 c_d0 c_m0.\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/quasisteady/#Constructors","page":"Quasi-Steady Thin Airfoil Theory","title":"Constructors","text":"","category":"section"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"QuasiSteady()","category":"page"},{"location":"aerodynamics/quasisteady/#AerostructuralDynamics.QuasiSteady-Tuple{}","page":"Quasi-Steady Thin Airfoil Theory","title":"AerostructuralDynamics.QuasiSteady","text":"QuasiSteady()\n\nInitialize an object of type QuasiSteady which represents a 2D quasi-steady aerodynamic model.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/quasisteady/#Example-Usage","page":"Quasi-Steady Thin Airfoil Theory","title":"Example Usage","text":"","category":"section"},{"location":"aerodynamics/quasisteady/","page":"Quasi-Steady Thin Airfoil Theory","title":"Quasi-Steady Thin Airfoil Theory","text":"Aeroelastic Analysis of a Typical Section","category":"page"},{"location":"aerodynamics/peters/#peters-finite-state-model","page":"Peters' Finite State","title":"Peters' Finite State Model","text":"","category":"section"},{"location":"aerodynamics/peters/#Theory","page":"Peters' Finite State","title":"Theory","text":"","category":"section"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"For Peter's finite state model, an additional term is added to the expression for the effective angle of attack from the quasi-steady model to account for induced velocity.","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"alpha = fracvu + fracbuleft( frac12 - a right) omega + fraclambda_0u - alpha_0","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"The induced velocity lambda_0 is approximated from a set of N induced-flow states lambda_1 lambda_2 dots lambda_N as","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"lambda_0 approx frac12 sum_n=1^N b_n lambda_n","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"The set of N first-order ordinary differential equations which govern the N finite aerodynamic states are derived by Peters et al. as","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"barA lambda + fracub lambda = barc left -dotv + uomega + b left(frac12 - a right) dotomega right","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"where","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"barA = barD + bard barb^T + barc bard^T + frac12 barc  barb^T \nbarD_nm = begincases\nfrac12n  n=m+1 \nfrac-12n  n=m-1 \n0  n neq m pm 1 \nendcases\nquad\nbarb_n = begincases\nleft( -1 right)^n-1 frac(N+n-1)(N-n-1)frac1left(nright)^2  n neq N \nleft( -1 right)^n-1  n = N\nendcases\nquad\nbarc_n = frac2n\nquad\nbard_n = begincases\nfrac12  n = 1 \n0  n neq 1\nendcases","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"The same force and moment expressions are used as in the quasi-steady model, but with the new effective angle of attack provided above.","category":"page"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"Note that while Peter's finite state model can accommodate any number of aerodynamic state variables, generally 3-10 state variables are used.","category":"page"},{"location":"aerodynamics/peters/#Type-Definition","page":"Peters' Finite State","title":"Type Definition","text":"","category":"section"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"Peters","category":"page"},{"location":"aerodynamics/peters/#AerostructuralDynamics.Peters","page":"Peters' Finite State","title":"AerostructuralDynamics.Peters","text":"Peters{N,TF,SV,SA} <: AbstractModel\n\nPeter's finite state model with N state variables, inputs u omega dotv dotomega and parameters a b a_0 alpha_0\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/peters/#Constructors","page":"Peters' Finite State","title":"Constructors","text":"","category":"section"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"Peters()","category":"page"},{"location":"aerodynamics/peters/#AerostructuralDynamics.Peters-Tuple{}","page":"Peters' Finite State","title":"AerostructuralDynamics.Peters","text":"Peters{N,TF=Float64}()\n\nInitialize an object of type Peters which has N aerodynamic degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/peters/#Example-Usage","page":"Peters' Finite State","title":"Example Usage","text":"","category":"section"},{"location":"aerodynamics/peters/","page":"Peters' Finite State","title":"Peters' Finite State","text":"Aeroelastic Analysis of a Typical Section","category":"page"},{"location":"aerodynamics/wagner/#Wagner's-Function","page":"Wagner's Function","title":"Wagner's Function","text":"","category":"section"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"(Image: )","category":"page"},{"location":"aerodynamics/wagner/#Theory","page":"Wagner's Function","title":"Theory","text":"","category":"section"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"Wagner's function models the indicial response of aerodynamic loads under a sudden change in downwash w at the three-quarter's chord. The exact expression for Wagner's function is","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"phi(t) = frac2pi int_0^infty fracRe(C) sin ( omega (ub) t  )omega domega","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"where u is the freestream velocity in the chordwise direction, omega is the freestream angular velocity, b is the semi-chord, and C(omega) is Theodorsen's function.  In many cases, approximate versions of Wagner's function are used rather than the exact expression, of which one of the most common is the approximation of Wagner's function provided by R. T. Jones","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"phi(t) = 1 - C_1 e^-varepsilon_1 (ub) t - C_2 e^-varepsilon_2 (ub) t","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"where C_1 = 0165, C_2 = 0335, varepsilon_1 = 0455, and varepsilon_2 = 03.","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"Wagner's function may be used to model arbitrary airfoil motion using Duhamel's integral.  We start by modeling the increment in the circulatory normal force d mathcalN_c(t) at time t due to an increment in downwash d w(t) at earlier time tau as","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"fracd mathcalN_c(t)a_0 rho_infty u b =  phi(t - tau) d w(tau)","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"where phi(t) is the impulse response function, which in this case is R. T. Jones' approximation of Wagner's function.  Superimposing all previous impulse responses using Duhamel's integral yields the following expression for the instantaneous circulatory normal force.","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"fracmathcalN_ca_0 rho_infty u b = int_-infty^t d w(tau) phi(t - tau) dtau = w(0) phi(t) + int_0^t  d w(tau) phi(t - tau) d tau","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"We can transform this equation using integration by parts, yielding","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"fracmathcalN_ca_0 rho_infty u b = w(t) phi(0) - int_0^t w(tau) dphi(t - tau) dtau","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"The integral in this expression may be expressed as a function of the aerodynamic states lambda_1 and lambda_2.","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"lambda_1 = C_1 varepsilon_1 fracub int_0^t w(tau) e^-varepsilon_1 (ub) (t - tau) d tau","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"lambda_2 = C_2 varepsilon_2 fracub int_0^t w(tau) e^-varepsilon_2 (ub) (t - tau) d tau","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"lambda_1 + lambda_2 = - int_0^t w(tau) dphi(t-tau) dtau","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"The expression for the circulatory normal force then reduces to","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"fracmathcalN_ca_0 rho_infty u b = w(t) phi(0) + lambda_1 + lambda_2","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"where the downwash at the three quarter's chord is given by","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"w(t) = v + b left( frac12 - a right) omega - ualpha_0","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"and the aerodynamic states variables lambda_1 and lambda_2 are described by the ordinary differential equations","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"dotlambda_1 = -varepsilon_1 fracub lambda_1 + C_1 varepsilon_1 fracub w(t) \ndotlambda_2 = -varepsilon_2 fracub lambda_2 + C_2 varepsilon_2 fracub w(t)","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"The same lift and moment expressions are used as in the quasi-steady model, but with the following effective angle of attack","category":"page"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"alpha_texteff = left(fracvu + fracbu left( frac12 - a right) omega - alpha_0 right) phi(0) + fraclambda_1u + fraclambda_2u","category":"page"},{"location":"aerodynamics/wagner/#Type-Definition","page":"Wagner's Function","title":"Type Definition","text":"","category":"section"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"Wagner","category":"page"},{"location":"aerodynamics/wagner/#AerostructuralDynamics.Wagner","page":"Wagner's Function","title":"AerostructuralDynamics.Wagner","text":"Wagner{TF} <: AbstractModel\n\nAerodynamic model based on Wagner's function with state variables lambda_1 lambda_2, inputs u v omega, and parameters a b a_0 alpha_0  c_d0 c_m0\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/wagner/#Constructors","page":"Wagner's Function","title":"Constructors","text":"","category":"section"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"Wagner()","category":"page"},{"location":"aerodynamics/wagner/#AerostructuralDynamics.Wagner-Tuple{}","page":"Wagner's Function","title":"AerostructuralDynamics.Wagner","text":"Wagner(; C1=0.165, C2=0.335, eps1 = 0.0455, eps2 = 0.3)\n\nInitialize an object of type Wagner\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/wagner/#Example-Usage","page":"Wagner's Function","title":"Example Usage","text":"","category":"section"},{"location":"aerodynamics/wagner/","page":"Wagner's Function","title":"Wagner's Function","text":"Aeroelastic Analysis of a Typical Section","category":"page"},{"location":"developer/#Developer's-Guide","page":"Developer Guide","title":"Developer's Guide","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In this guide, we describe how to create new independent and/or coupled models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"developer/#Theory","page":"Developer Guide","title":"Theory","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"This package assumes that the governing equations for the state variables corresponding to all models satisfy the implicit ordinary differential equation","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"0 = f(dotxxypt)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where f(dotx x y p t) is a residual function, x is a vector of state variables, y is a vector of inputs, p is a vector of parameters, and t is the current time.  In the context of this package, we define inputs as variables which may vary over time and parameters as variables which do not vary over time.  Typically, inputs are defined as any model parameter which could correspond to the output or outputs from other models.  We call t","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The primary type of model encountered in this package is a model with state variables which are governed by  the following implicit ordinary differential equation.  ","category":"page"},{"location":"developer/#Creating-a-New-Model","page":"Developer Guide","title":"Creating a New Model","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In this section, we describe in detail how to construct a new independent model.  To demonstrate this process, we also show how one might implement the TypicalSection model.","category":"page"},{"location":"developer/#Manipulating-a-Model's-Governing-Equations","page":"Developer Guide","title":"Manipulating a Model's Governing Equations","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Before a model can be used with this package, its governing equations must be manipulated so that it satisfies the implicit ordinary differential equation","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"0 = f(dotxxypt)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where f(dotx x y p t) is a residual function, x is a vector of state variables, y is a vector of inputs, p is a vector of parameters, and t is the current time.  State variables are variables which have rate equations associated with them.  Inputs are variables which may vary over time, possibly as defined by other models.  Parameters are variables which are user-specified and constant in time.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For example, the governing differential equation for the TypicalSection model is often expressed as the second order ordinary differential equation","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"beginbmatrix m  S_theta  S_theta  I_theta endbmatrix\nbeginbmatrix ddoth  ddottheta endbmatrix +\nbeginbmatrix k_h  0  0  k_h endbmatrix\nbeginbmatrix h  theta endbmatrix =\nbeginbmatrix -mathcalL  mathcalM endbmatrix","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where k_h is the linear spring constant, k_theta is the torsional spring constant, m is the mass per unit span, S_theta is the structural imbalance, I_theta is the mass moment of inertia, mathcalL is the lift per unit span, and mathcalM is the moment per unit span.  Expressed in the form expected by this package, the governing differential equation for this model is","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"0 = M dotx + K x + D y","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"x = beginbmatrix h  theta  doth  dottheta endbmatrix^T quad\ny = beginbmatrix mathcalL  mathcalM endbmatrix^T","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M =\nbeginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  m  S_theta \n    0  0  S_theta  I_P\nendbmatrix\nquad\nK =\nbeginbmatrix\n0  0  -1  0 \n0  0  0  -1 \nk_h  0  0  0 \n0  k_theta  0  0\nendbmatrix\nquad\nD =\nbeginbmatrix\n0  0 \n0  0 \n1  0 \n0  -1\nendbmatrix","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"A special type of model which trivially satisfies the form of the governing differential equations expected by this package is a model with no state variables and/or inputs.  These models are designated as being subtypes of abstract type NoStateModel and are used solely to define the inputs of other models.  For example, the Steady and QuasiSteady models may be used to calculate the inputs corresponding to the TypicalSection model, but have no state variables of their own.","category":"page"},{"location":"developer/#Defining-a-Model's-Type","page":"Developer Guide","title":"Defining a Model's Type","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Once the governing differential equations for a model has been manipulated into the expected format, and the state variables, inputs, and parameters for the model have been identified, the first step in defining a new model is to define a new type.  A docstring should also be provided along with the new type definition which defines the identities of the elements of the state, input, and parameter vectors for the model.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For example, the type definition for the TypicalSection is defined as","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"\"\"\"\n    TypicalSection <: AbstractModel\n\nTypical section structural model with state variables ``h, \\\\theta, \\\\dot{h},\n\\\\dot{\\\\theta}``, inputs ``\\\\mathcal{L}, \\\\mathcal{M}``, and parameters ``k_h,\nk_\\\\theta, m, S_\\\\theta, I_\\\\theta``\n\"\"\"\nstruct TypicalSection <: AbstractModel end","category":"page"},{"location":"developer/#Defining-Model-Traits","page":"Developer Guide","title":"Defining Model Traits","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The next step in defining a new model is to define the model's properties.  At a minimum, this requires defining new methods for the number_of_states, number_of_inputs, number_of_parameters, and inplaceness functions, though additional method definitions may be necessary.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The length of the model's state, input and parameter vectors is specified by defining new methods for the number_of_states, number_of_inputs, and number_of_parameters functions.  For out-of-place models, these methods must operate the model type so that the vector sizes are completely inferrable.  For in-place models, this restriction is loosened and these methods may operate on model instances instead.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Whether a model uses in-place or out-of-place function definitions is specified by defining a new method for the inplaceness function, which operates on the model type. For performance reasons, in-place functions are generally preferred.  The one exception is for models with small numbers of state variables, in which case the preferred approach is to use static arrays with out-of-place functions.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The properties of the model's mass matrix, state jacobian, and/or input jacobian are defined by defining new methods for the mass_matrix_type, state_jacobian_type, and/or input_jacobian_type functions, respectively.  By default, these properties assume their loosest possible definitions.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"As an example, the TypicalSection model's properties are defined using the following block of code.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"number_of_states(::Type{TypicalSection}) = 4\nnumber_of_inputs(::Type{TypicalSection}) = 2\nnumber_of_parameters(::Type{TypicalSection}) = 5\ninplaceness(::Type{TypicalSection}) = OutOfPlace()\nmass_matrix_type(::Type{TypicalSection}) = Linear()\nstate_jacobian_type(::Type{TypicalSection}) = Linear()\ninput_jacobian_type(::Type{TypicalSection}) = Constant()","category":"page"},{"location":"developer/#Defining-Methods-for-Governing-Equations","page":"Developer Guide","title":"Defining Methods for Governing Equations","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Once the properties of a model have been defined, methods must be provided for the model which define its governing equations.  The right hand side of the governing structural differential equations is calculated using the get_rates function for out-of-place models or the get_rates! function for in-place models.  For models with mass matrices, a new method must also be defined for the get_mass_matrix function (or get_mass_matrix! function if the model's functions are in-place).  For constant mass matrices (mass_matrix_type(typeof(model)) == Constant()), this function should be defined without the x, y, p, and t arguments.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For example, the governing equations for the TypicalSection model may be defined using the following block of code","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_rates(::TypicalSection, x, y, p, t)\n    # extract state variables\n    h, θ, hdot, θdot = x\n    # extract inputs\n    L, M = y\n    # extract parameters\n    kh, kθ, m, Sθ, Iθ = p\n    # calculate state rates\n    return SVector(hdot, θdot, -kh*h - L, -kθ*θ + M)\nend\n\nfunction get_mass_matrix(::MyTypicalSection, x, y, p, t)\n    # extract structural parameters\n    kh, kθ, m, Sθ, Iθ = p\n    # calculate mass matrix\n    return @SMatrix [1 0 0 0; 0 1 0 0; 0 0 m Sθ; 0 0 Sθ Iθ]\nend","category":"page"},{"location":"developer/#Defining-Methods-for-Jacobians","page":"Developer Guide","title":"Defining Methods for Jacobians","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Unless otherwise specified, the jacobian of the governing differential equations for a given model with respect to the state variables and/or inputs is calculated when necessary using forward automatic differentiation (enabled by the ForwardDiff package).  While this approach for computing the jacobians is convenient and exact, alternative methods for computing jacobians may be more computationally efficient.  To manually define the jacobian of the right hand side of the governing equations with respect to the state variables, a new method for get_state_jacobian (or get_state_jacobian! for in-place models) may be defined.  To manually define the jacobian of the right hand side of the governing equations with respect to the inputs, a new method for get_input_jacobian may be defined.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For the TypicalSection model, these jacobians may be defined analytically using the following block of code","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_state_jacobian(::MyTypicalSection, q, r, p, t)\n    # extract parameters\n    a, b, kh, kθ, m, xθ, Ip = p\n    # return jacobian\n    return @SMatrix [0 0 1 0; 0 0 0 1; -kh 0 0 0; 0 -kθ 0 0]\nend\n\nget_input_jacobian(::MyTypicalSection) = @SMatrix [0 0; 0 0; -1 0; 0 1]","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Note that while there is no in-place version of the get_input_jacobian function it may be constructed as either a linear map (for large matrices) or static array (for small matrices) in order to avoid allocations.","category":"page"},{"location":"developer/#Defining-Methods-for-Unit-Testing","page":"Developer Guide","title":"Defining Methods for Unit Testing","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to test whether provided mass matrices are correct for a given model, a new method for get_lhs() (which defines the left hand side of the governing differential equations) must be provided.  Since this function is only used for testing, there is no in-place version of this function.  ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For the TypicalSection model, the new method could be defined as follows","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_lhs(::TypicalSection, dq, q, r, p, t)\n    # extract structural parameters\n    kh, kθ, m, Sθ, Iθ = p\n    # extract state rates\n    dh, dθ, dhdot, dθdot = dq\n    # calculate mass matrix product\n    return SVector(dh, dθ, m*dhdot + Sθ*dθdot, Sθ*dhdot + Iθ*dθdot)\nend","category":"page"},{"location":"developer/#Defining-Convenience-Methods","page":"Developer Guide","title":"Defining Convenience Methods","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To aid users in defining state, input, and parameter vectors, new methods for the set_states!, set_inputs!, and set_parameters! functions should be provided.  For the TypicalSection model, these new methods may be defined using the following block of code.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function set_states!(x, model::TypicalSection; h, theta, hdot, thetadot)\n\n    x[1] = h\n    x[2] = theta\n    x[3] = hdot\n    x[4] = thetadot\n\n    return x\nend\n\nfunction set_inputs!(y, model::TypicalSection; L, M)\n\n    y[1] = L\n    y[2] = M\n\n    return y\nend\n\nfunction set_parameters!(p, model::TypicalSection; kh, ktheta, m, Stheta, Itheta)\n\n    p[1] = kh\n    p[2] = ktheta\n    p[3] = m\n    p[4] = Stheta\n    p[5] = Itheta\n\n    return p\nend","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To aid users in interpreting state, input, and parameter vector values, new methods for the separate_states, separate_inputs, and separate_parameters functions should be provided.  For the TypicalSection model, these new methods may be defined using the following block of code.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function separate_states(model::TypicalSection, x)\n\n    return (h = x[1], theta = x[2], hdot = x[3], thetadot = x[4])\nend\n\nfunction separate_inputs(model::TypicalSection, y)\n\n    return (L = y[1], M = y[2])\nend\n\nfunction separate_parameters(model::TypicalSection, p)\n\n    return (kh = p[1], ktheta = p[1], m = p[1], Stheta = p[1], Itheta = p[1])\nend","category":"page"},{"location":"developer/#Creating-a-New-Model-Coupling","page":"Developer Guide","title":"Creating a New Model Coupling","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In this section, we describe in detail how to construct a new model by coupling multiple existing models together.  To demonstrate this process, we also show how one might implement the Wagner and TypicalSection model coupling.","category":"page"},{"location":"developer/#Coupled-Model-Theory","page":"Developer Guide","title":"Coupled Model Theory","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To construct a coupled model, we first concatenate the governing differential equations, state variables, inputs, and parameters of multiple independent models into a single system of equations.  This system of equations may be expressed as","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"M(xypt)dotx = f(xypt)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"x = beginbmatrix x_1^T  x_2^T  dots  x_N^T endbmatrix^T quad\ny = beginbmatrix y_1^T  y_2^T  dots  y_N^T endbmatrix^T quad\np = beginbmatrix p_1^T  p_2^T  dots  p_N^T endbmatrix^T \nM(x y p t) = beginbmatrix\n    M_1(x_1 y_1 p_1 t)  0   0 \n    0  M_2(x_2 y_2 p_2 t)   0 \n      ddots  \n    0  0   M_N(x_N y_N p_N t)\nendbmatrix \nf(x y p t) = beginbmatrix\n    f_1(x_1 y_1 p_1 t) \n    f_2(x_2 y_2 p_2 t) \n    vdots \n    f_N(x_N y_N p_N t) \nendbmatrix","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"We then couple the models in this system of equations by allowing the inputs corresponding to each model to be defined as a function of the variables associated with the other models.  Specifically, we assume that the inputs corresponding to each model may be defined as","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"y = g(x p t) - M_y(x p t) dotx","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where g(x p t) is a function which returns a vector and M_y(x p t) is a function which returns a matrix.  If we also assume that the state rates of the coupled model returned by f(x y p t) are linearly dependent on the coupled model's inputs, at least for the non-zero rows of M_y(x p t), then the governing equations for the coupled system of equations may be expressed as","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"barM(x p t) dotx = barf(x p t)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"barM(x p t) = M(x y p t) + fracpartial fpartial y M_y(x p t)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"and","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"barf(x p t) = f(x g(x p t) p t)","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For the Wagner model coupled with the TypicalSection model, the coupled model's state variables, inputs, and parameters are","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"x = beginbmatrix lambda_1  lambda_2  h  theta  doth  dottheta endbmatrix^T quad\ny = beginbmatrix u  v  omega  L  M endbmatrix^T \np = beginbmatrix a  b  a_0  alpha_0  k_h  k_theta  m  S_theta  I_theta endbmatrix^T ","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The Wagner model inputs may be defined as a function of the state variables of the typical section model.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"u = U_infty \nv = doth \nomega = dottheta","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The TypicalSection model inputs may be defined using the lift and moment expressions corresponding to the Wagner model.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"mathcalL = a_0 rho_infty u^2 b alpha_texteff + pi rho b^2 left(-dotv + uomega - a b dotomega right) \nmathcalM = -pi rho_infty b^3 left -frac12dotv + uomega + b left( frac18 - fraca2 right) dotomega right + b left(frac12 + a right) mathcalL","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"where","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"alpha_texteff = left(theta - fracvu + fracbu left( frac12 - a right) omega - alpha_0 right) phi(0) + fraclambda_1u + fraclambda_2u","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to use these relationships, two additional parameters must be introduced: the freestream velocity U_infty and the freestream density rho_infty.  These parameters are simply appended to the end of the parameter vector.","category":"page"},{"location":"developer/#Defining-the-Coupled-Model","page":"Developer Guide","title":"Defining the Coupled Model","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"New coupled model's are defined by defining a new method for the couple_models function.  This function returns a tuple of models in the order in which their states, inputs, and parameters are concatenated.  A docstring should also be provided along with the method definition which defines the identities of any additional parameters, if used.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For the Wagner model coupled with the TypicalSection model, a new coupled model may be defined using the following code block.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"\"\"\"\n    couple_models(aero::Wagner, stru::TypicalSection)\n\nCreate an aerostructural model using an unsteady aerodynamic model based on\nWagner's function and a two-degree of freedom typical section model.  This model\nintroduces the freestream velocity ``U_\\\\infty`` and air density ``\\\\rho_\\\\infty``\nas additional parameters.\n\"\"\"\ncouple_models(aero::Wagner, stru::TypicalSection) = (aero, stru)","category":"page"},{"location":"developer/#Defining-the-Coupled-Model's-Traits","page":"Developer Guide","title":"Defining the Coupled Model's Traits","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The next step in defining a coupled model is to define the model's properties.  At a minimum, this requires defining new methods for the number_of_additional_parameters and coupling_inplaceness functions, though additional method definitions may be necessary.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The number of additional parameters introduced by the coupled model is specified by defining a new method for the number_of_additional_parameters function.  For out-of-place models, these methods must operate on the model types so that the length of the parameter vector is completely inferrable. For in-place models, this restriction is loosened and this methods may operate on model instances instead.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Whether the coupled model uses an in-place or out-of-place coupling function is defined by the coupling_inplaceness function, which operates on the model type. For performance reasons, in-place functions are generally preferred. The one exception is for coupled models with small numbers of state variables, in which case the preferred approach is to use static arrays with out-of-place functions.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The properties of the coupling function's mass matrix and/or state jacobian are defined by defining new methods for the coupling_mass_matrix_type and/or coupling_state_jacobian_type functions, respectively. By default, these properties assume their loosest possible definitions.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"The properties of the Wagner model coupled with the TypicalSection model may be defined using the following block of code.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"number_of_additional_parameters(::Type{<:Wagner}, ::Type{TypicalSection}) = 2\ncoupling_inplaceness(::Type{<:Wagner}, ::Type{TypicalSection}) = OutOfPlace()\ncoupling_mass_matrix_type(::Type{<:Wagner}, ::Type{TypicalSection}) = Linear()\ncoupling_state_jacobian_type(::Type{<:Wagner}, ::Type{TypicalSection}) = Nonlinear()","category":"page"},{"location":"developer/#Defining-Coupling-Function-Methods","page":"Developer Guide","title":"Defining Coupling Function Methods","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Once the properties of a coupled model have been defined, methods must be provided which define the values of the model's inputs. The portion of the inputs which is independent of the state rates is calculated using the get_coupling_inputs function for out-of-place coupling functions or the get_coupling_inputs! function for in-place coupling functions. For models with inputs that are also linearly dependent on the state rates, a new method must also be defined for the get_coupling_mass_matrix function (or get_coupling_mass_matrix! function if the inputs are defined in-place). For constant mass matrices (couplingmassmatrix_type(typeof.(models)...) == Constant()), this function should be defined without the x, p, and t arguments.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"As an example, the expressions defining the inputs for the Wagner model coupled with the TypicalSection model may be defined using the following block of code.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_coupling_inputs(aero::Wagner, stru::TypicalSection, s, p, t)\n    # extract state variables\n    λ1, λ2, h, θ, hdot, θdot = s\n    # extract parameters\n    a, b, a0, α0, cd0, cm0, kh, kθ, m, Sθ, Iθ, U, ρ = p\n    # extract model constants\n    C1 = aero.C1\n    C2 = aero.C2\n    # local freestream velocity components\n    u = U\n    v = U*θ + hdot\n    ω = θdot\n    # circulatory load factor\n    tmp1 = a0*ρ*u*b\n    # non-circulatory load factor\n    tmp2 = pi*ρ*b^3\n    # constant based on geometry\n    d = b/2 - a*b\n    # Wagner's function at t = 0.0\n    ϕ0 = 1 - C1 - C2\n    # lift at reference point\n    L = tmp1*((v + d*ω - u*α0)*ϕ0 + λ1 + λ2) + tmp2*u/b*ω\n    # moment at reference point\n    M = -tmp2*u*ω + (b/2 + a*b)*L\n    # return portion of inputs that is not dependent on the state rates\n    return SVector(u, v, ω, L, M)\nend\n\nfunction get_coupling_mass_matrix(aero::Wagner, stru::TypicalSection, s, p, t)\n    # extract parameters\n    a, b, a0, α0, cd0, cm0, kh, kθ, m, Sθ, Iθ, U, ρ = p\n    # non-circulatory load factor\n    tmp = pi*ρ*b^3\n    # lift at reference point\n    L_hddot = tmp/b\n    L_θddot = -a*tmp\n    # moment at reference point\n    M_hddot = -tmp/2 + (b/2 + a*b)*L_hddot\n    M_θddot = -tmp*(b/8 - a*b/2) + (b/2 + a*b)*L_θddot\n    # construct submatrices\n    Mda = @SMatrix [0 0; 0 0; 0 0]\n    Mds = @SMatrix [0 0 0 0; 0 0 0 0; 0 0 0 0]\n    Mra = @SMatrix [0 0; 0 0]\n    Mrs = @SMatrix [0 0 -L_hddot -L_θddot; 0 0 -M_hddot -M_θddot]\n    # assemble mass matrix\n    return [Mda Mds; Mra Mrs]\nend","category":"page"},{"location":"developer/#Defining-Methods-for-the-Coupling-Function's-Jacobians","page":"Developer Guide","title":"Defining Methods for the Coupling Function's Jacobians","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Unless otherwise specified, the jacobian of the coupling function of a given coupled model with respect to the state variables is calculated when necessary using forward automatic differentiation (enabled by the ForwardDiff package). While this approach for computing the jacobians is convenient and exact, alternative methods for computing jacobians may be more computationally efficient. To manually define the jacobian of the coupling function with respect to the state variables, a new method for the get_coupling_state_jacobian (or get_coupling_state_jacobian! for inputs which are defined in-place) may be defined.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For the Wagner model coupled with the TypicalSection model, this jacobian may be defined analytically using the following block of code.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_coupling_state_jacobian(aero::Wagner, stru::TypicalSection, u, p, t) where {N,TF,SV,SA}\n    # extract parameters\n    a, b, a0, α0, cd0, cm0, kh, kθ, m, Sθ, Iθ, U, ρ = p\n    # extract model constants\n    C1 = aero.C1\n    C2 = aero.C2\n    # local freestream velocity components\n    v_θ = U\n    v_hdot = 1\n    ω_θdot = 1\n    # calculate loads\n    r_λ = wagner_loads_λ(a, b, ρ, a0, U)\n    L_h, M_h = wagner_loads_h()\n    L_θ, M_θ = wagner_loads_θ(a, b, ρ, a0, C1, C2, U)\n    L_hdot, M_hdot = wagner_loads_v(a, b, ρ, a0, C1, C2, U)\n    L_θdot, M_θdot = wagner_loads_ω(a, b, ρ, a0, C1, C2, U)\n    # compute jacobian sub-matrices\n    Jda = @SMatrix [0 0; 0 0; 0 0]\n    Jds = @SMatrix [0 0 0 0; 0 v_θ v_hdot 0; 0 0 0 ω_θdot]\n    Jra = r_λ\n    Jrs = @SMatrix [L_h L_θ L_hdot L_θdot; M_h M_θ M_hdot M_θdot]\n    # return jacobian\n    return [Jda Jds; Jra Jrs]\nend\n\nfunction wagner_loads_λ(a, b, ρ, a0, u)\n    tmp1 = a0*ρ*u*b\n    tmp2 = (b/2 + a*b)*tmp1\n    return @SMatrix [tmp1 tmp1; tmp2 tmp2]\nend\n\nwagner_loads_h() = SVector(0, 0)\n\nfunction wagner_loads_θ(a, b, ρ, a0, C1, C2, u)\n    ϕ0 = 1 - C1 - C2\n    L_θ = a0*ρ*b*u^2*ϕ0\n    M_θ = (b/2 + a*b)*L_θ\n    return SVector(L_θ, M_θ)\nend\n\nfunction wagner_loads_v(a, b, ρ, a0, C1, C2, u)\n    # Wagner's function at t = 0.0\n    ϕ0 = 1 - C1 - C2\n    # lift at reference point\n    L_v = a0*ρ*u*b*ϕ0\n    # moment at reference point\n    M_v = (b/2 + a*b)*L_v\n\n    return SVector(L_v, M_v)\nend\n\nfunction wagner_loads_ω(a, b, ρ, a0, C1, C2, u)\n    # circulatory load factor\n    tmp1 = a0*ρ*u*b\n    # non-circulatory load factor\n    tmp2 = pi*ρ*b^3\n    # constant based on geometry\n    d = b/2 - a*b\n    # Wagner's function at t = 0.0\n    ϕ0 = 1 - C1 - C2\n    # lift at reference point\n    L_ω = tmp1*d*ϕ0 + tmp2*u/b\n    # moment at reference point\n    M_ω = -tmp2*u + (b/2 + a*b)*L_ω\n\n    return SVector(L_ω, M_ω)\nend","category":"page"},{"location":"developer/#Defining-Methods-for-Unit-Testing-2","page":"Developer Guide","title":"Defining Methods for Unit Testing","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to test whether the provided mass matrices are correct for a given coupled model, a new method for get_coupling_inputs_using_state_rates (which defines the portion of the inputs that are dependent on the state rates) must be provided.  Since this function is used for testing, there is no in-place version of this function.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"For the Wagner model coupled with the TypicalSection model, this function could be defined as follows","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function get_inputs_using_state_rates(aero::Wagner, stru::TypicalSection,\n    ds, s, p, t)\n    # extract state rates\n    dλ1, dλ2, dh, dθ, dhdot, dθdot = ds\n    # extract parameters\n    a, b, a0, α0, cd0, cm0, kh, kθ, m, Sθ, Iθ, U, ρ = p\n    # local freestream velocity components\n    udot = 0\n    vdot = dhdot\n    ωdot = dθdot\n    # non-circulatory load factor\n    tmp = pi*ρ*b^3\n    # lift at reference point\n    L = tmp*(vdot/b - a*ωdot)\n    # moment at reference point\n    M = -tmp*(vdot/2 + b*(1/8 - a/2)*ωdot) + (b/2 + a*b)*L\n    # return inputs\n    return SVector(0, 0, 0, L, M)\nend","category":"page"},{"location":"developer/#Defining-Convenience-Methods-2","page":"Developer Guide","title":"Defining Convenience Methods","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To aid users in defining state, input, and parameter vectors, new methods for the set_states!, set_inputs!, and set_parameters! functions should be provided.  For the Wagner model coupled with the TypicalSection model, these new methods may be defined as follows","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function set_states!(x, aero::Wagner, stru::TypicalSection; lambda = [0.0, 0.0],\n    h = 0.0, theta = 0.0, hdot = 0.0, thetadot = 0.0)\n\n    models = (aero, stru)\n    xs = view.(x, state_indices.(models))\n\n    set_states!(xs[1], aero; lambda)\n    set_states!(xs[2], stru; h, theta, hdot, thetadot)\n\n    return x\nend\n\nfunction set_inputs!(y, aero::Wagner, stru::TypicalSection; u=1.0, v=0.0,\n    omega=0.0, L=0.0, M=0.0)\n\n    models = (aero, stru)\n    ys = view.(y, input_indices.(models))\n\n    set_inputs!(ys[1], aero; u, v, omega)\n    set_inputs!(ys[2], stru; L, M)\n\n    return y\nend\n\nfunction set_parameters!(p, aero::Wagner, stru::TypicalSection; a=0.0, b=0.5,\n    a0=2*pi, alpha0=0.0, kh, ktheta, m, Stheta, Itheta)\n\n    models = (aero, stru)\n    ps = view.(p, input_indices.(models))\n\n    set_inputs!(ps[1], aero; a, b, a0, alpha0)\n    set_inputs!(ps[2], stru; kh, ktheta, m, Stheta, Itheta)\n\n    return y\nend","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To aid users in interpreting state, input, and parameter vector values, new methods for the separate_states, separate_inputs, and separate_parameters functions should be provided.  For the Wagner model coupled with the TypicalSection model, these new methods may be defined using the following block of code.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"function separate_states(model::TypicalSection, x)\n\n    return (h = x[1], theta = x[2], hdot = x[3], thetadot = x[4])\nend\n\nfunction separate_inputs(model::TypicalSection, y)\n\n    return (L = y[1], M = y[2])\nend\n\nfunction separate_parameters(model::TypicalSection, p)\n\n    return (kh = p[1], ktheta = p[1], m = p[1], Stheta = p[1], Itheta = p[1])\nend","category":"page"},{"location":"developer/#Defining-Visualization-Methods","page":"Developer Guide","title":"Defining Visualization Methods","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"To aid users in visualizing solution geometry new plot recipes","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"defining state, input, and parameter vectors, new methods for the set_states!, set_inputs!, and set_parameters! functions should be provided.  For the Wagner model coupled with the TypicalSection model, these new methods are defined as follows","category":"page"},{"location":"developer/#Model-Ordering","page":"Developer Guide","title":"Model Ordering","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In general, we suggest that the following model order is used when constructing coupled models.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Aerodynamics Model(s)\nStructural Model(s)\nRigid Body Model(s)\nControl Surface Model(s)\nController Model(s)","category":"page"},{"location":"developer/#Avoiding-Mass-Matrices","page":"Developer Guide","title":"Avoiding Mass Matrices","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to take advantage of as many features of the DifferentialEquations package as possible (including local sensitivity analysis), at this point in time we recommend that the governing differential equations for models be reformulated to avoid using mass matrices whenever possible.","category":"page"},{"location":"structures/rigidbody/#Rigid-Body-Model","page":"Rigid Body","title":"Rigid Body Model","text":"","category":"section"},{"location":"structures/rigidbody/#Theory","page":"Rigid Body","title":"Theory","text":"","category":"section"},{"location":"structures/rigidbody/","page":"Rigid Body","title":"Rigid Body","text":"A basic six degree of freedom rigid body model based on the SixDOF package.","category":"page"},{"location":"structures/rigidbody/#Type-Definition","page":"Rigid Body","title":"Type Definition","text":"","category":"section"},{"location":"structures/rigidbody/","page":"Rigid Body","title":"Rigid Body","text":"RigidBody","category":"page"},{"location":"structures/rigidbody/#AerostructuralDynamics.RigidBody","page":"Rigid Body","title":"AerostructuralDynamics.RigidBody","text":"RigidBody <: AbstractModel\n\nSix-degree of freedom rigid-body model with state variables x y z phi theta psi u v w p q r, inputs m I_xx I_yy I_zz I_xz I_xy I_yz F_x F_y F_z M_x M_y M_z, and zero parameters.\n\n\n\n\n\n","category":"type"},{"location":"structures/rigidbody/#Constructors","page":"Rigid Body","title":"Constructors","text":"","category":"section"},{"location":"structures/rigidbody/","page":"Rigid Body","title":"Rigid Body","text":"RigidBody()","category":"page"},{"location":"structures/rigidbody/#AerostructuralDynamics.RigidBody-Tuple{}","page":"Rigid Body","title":"AerostructuralDynamics.RigidBody","text":"RigidBody()\n\nInitialize an object of type RigidBody\n\n\n\n\n\n","category":"method"},{"location":"structures/rigidbody/#Example-Initialization","page":"Rigid Body","title":"Example Initialization","text":"","category":"section"},{"location":"structures/rigidbody/","page":"Rigid Body","title":"Rigid Body","text":"using AerostructuralDynamics #hide\nmodel = RigidBody()\nnothing #hide","category":"page"},{"location":"library/internals/","page":"Internals","title":"Internals","text":"Modules = [AerostructuralDynamics]\nPublic = false\nPrivate = true","category":"page"},{"location":"library/internals/#AerostructuralDynamics.AbstractModel","page":"Internals","title":"AerostructuralDynamics.AbstractModel","text":"AbstractModel\n\nSupertype for all models.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#AerostructuralDynamics.InterfaceModel","page":"Internals","title":"AerostructuralDynamics.InterfaceModel","text":"InterfaceModel <: AbstractModel\n\nSupertype for all models which are used to extend 2D models to 3D models.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#AerostructuralDynamics.LiftingLineSection","page":"Internals","title":"AerostructuralDynamics.LiftingLineSection","text":"LiftingLineSection <: AbstractModel\n\nLifting line section model with state variables v_x v_y v_z omega_x omega_y omega_z, inputs F_x F_y F_z M_x M_y M_z, and zero parameters.  Two-dimensional aerodynamic models may be extended to three-dimensional models by coupling with this model.  Note that this model has no rate equations of its own since its state variables are defined as functions of the 3D structural model's state variables.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#AerostructuralDynamics.LiftingLineSection-Tuple{}","page":"Internals","title":"AerostructuralDynamics.LiftingLineSection","text":"LiftingLineSection()\n\nInitialize an object of type LiftingLineSection\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.LiftingLineSectionControl","page":"Internals","title":"AerostructuralDynamics.LiftingLineSectionControl","text":"LiftingLineSectionControl <: AbstractModel\n\nLifting line section control input model with state variable delta, zero inputs, and zero parameters.  Two-dimensional control surface models may be extended to three dimensional models by coupling with this model.  Note that this model has no rate equations of its own since its state variables are defined as functions of the 3D system's control inputs.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#AerostructuralDynamics.NoStateModel","page":"Internals","title":"AerostructuralDynamics.NoStateModel","text":"NoStateModel <: AbstractModel\n\nSupertype for all models which contain no state variables.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#AerostructuralDynamics.ResidualModel","page":"Internals","title":"AerostructuralDynamics.ResidualModel","text":"ResidualModel <: AbstractModel\n\nSupertype for all models whose state variables may be defined by solving a set of residual equations.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#AerostructuralDynamics.UnsteadyModel","page":"Internals","title":"AerostructuralDynamics.UnsteadyModel","text":"UnsteadyModel <: AbstractModel\n\nSupertype for all models which represent dynamic systems of equations.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#AerostructuralDynamics.additional_parameter_indices-Tuple{Any}","page":"Internals","title":"AerostructuralDynamics.additional_parameter_indices","text":"additional_parameter_indices(models)\n\nReturn the indices of the additional parameters for the coupling function corresponding to the models in models\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.coupling_inplaceness-Union{Tuple{Vararg{Type, N}}, Tuple{N}} where N","page":"Internals","title":"AerostructuralDynamics.coupling_inplaceness","text":"coupling_inplaceness(::Type{T1}, ::Type{T2}, ..., ::Type{TN})\n\nReturn InPlace() if the functions associated with the coupling function for coupled models T1, T2, ... TN are in-place or OutOfPlace() if the functions associated with the coupling function for coupled models T1, T2, ... TN are out-of-place.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.get_coupling_parameter_jacobian","page":"Internals","title":"AerostructuralDynamics.get_coupling_parameter_jacobian","text":"get_coupling_parameter_jacobian(model)\nget_coupling_parameter_jacobian(model, p)\nget_coupling_parameter_jacobian(model, dx, x, y, p, t)\n\nCalculate the jacobian of the coupling function for model with respect to the parameters\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.get_coupling_parameter_jacobian!","page":"Internals","title":"AerostructuralDynamics.get_coupling_parameter_jacobian!","text":"get_coupling_parameter_jacobian!(J, model)\nget_coupling_parameter_jacobian!(J, model, p)\nget_coupling_parameter_jacobian!(J, model, dx, x, p, t)\n\nIn-place version of get_coupling_parameter_jacobian\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.get_coupling_rate_jacobian","page":"Internals","title":"AerostructuralDynamics.get_coupling_rate_jacobian","text":"get_coupling_rate_jacobian(model)\nget_coupling_rate_jacobian(model, p)\nget_coupling_rate_jacobian(model, dx, x, p, t)\n\nCalculate the jacobian of the coupling function for model with respect to the state rates\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.get_coupling_rate_jacobian!","page":"Internals","title":"AerostructuralDynamics.get_coupling_rate_jacobian!","text":"get_coupling_rate_jacobian!(J, model)\nget_coupling_rate_jacobian!(J, model, p)\nget_coupling_rate_jacobian!(J, model, dx, x, p, t)\n\nIn-place version of get_coupling_rate_jacobian.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.get_coupling_state_jacobian","page":"Internals","title":"AerostructuralDynamics.get_coupling_state_jacobian","text":"get_coupling_state_jacobian(model)\nget_coupling_state_jacobian(model, p)\nget_coupling_state_jacobian(model, dx, x, y, p, t)\n\nCalculate the jacobian of the coupling function for model with respect to the state variables\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.get_coupling_state_jacobian!","page":"Internals","title":"AerostructuralDynamics.get_coupling_state_jacobian!","text":"get_coupling_state_jacobian!(J, model)\nget_coupling_state_jacobian!(J, model, p)\nget_coupling_state_jacobian!(J, model, dx, x, p, t)\n\nIn-place version of get_coupling_state_jacobian\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.get_coupling_time_gradient","page":"Internals","title":"AerostructuralDynamics.get_coupling_time_gradient","text":"get_coupling_time_gradient(model)\nget_coupling_time_gradient(model, p)\nget_coupling_time_gradient(model, dx, x, y, p, t)\n\nCalculate the derivative of the coupling function for model with respect to time\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.get_coupling_time_gradient!","page":"Internals","title":"AerostructuralDynamics.get_coupling_time_gradient!","text":"get_coupling_time_gradient!(dT, model)\nget_coupling_time_gradient!(dT, model, p)\nget_coupling_time_gradient!(dT, model, dx, x, p, t)\n\nIn-place version of get_coupling_time_gradient\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.inplaceness-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Internals","title":"AerostructuralDynamics.inplaceness","text":"inplaceness(::Type{T})\n\nReturn InPlace() if functions associated with model T are in-place or OutOfPlace() if functions associated with model T are out-of-place.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.input_jacobian_type-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Internals","title":"AerostructuralDynamics.input_jacobian_type","text":"input_jacobian_type(::Type{T})\n\nReturn\n\nEmpty(), if the jacobian of the residual expression associated with model T  with respect to the inputs is an empty matrix\nZeros(), if the jacobian of the residual expression associated with model T  with respect to the inputs is a zero matrix\nIdentity(), if the jacobian of the residual expression associated with  model T with respect to the inputs is the identity matrix\nInvariant(), if the jacobian of the residual expression associated with  model T with respect to the inputs is independent of the state rates,  state variables, inputs, parameters, and time.\nConstant(), if the jacobian of the residual expression associated with  model T with respect to the inputs is independent of the state rates,  state variables, inputs, and time.\nLinear(), if the jacobian of the residual expression associated with model T  with respect to the inputs may vary with respect to time, and is  linear with respect to the inputs.\nNonlinear(), if the jacobian of the residual expression associated with  model T with respect to the inputs may vary with respect to time,  and is nonlinear with respect to the inputs.\n\nIf no method is defined for the specified type, return Nonlinear().\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.number_of_additional_parameters","page":"Internals","title":"AerostructuralDynamics.number_of_additional_parameters","text":"number_of_additional_parameters(models...)\n\nReturn the total number of additional parameters corresponding to the model coupling.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.parameter_jacobian_type-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Internals","title":"AerostructuralDynamics.parameter_jacobian_type","text":"parameter_jacobian_type(::Type{T})\n\nReturn\n\nEmpty(), if the jacobian of the residual expression associated with model T  with respect to the parameters is an empty matrix\nZeros(), if the jacobian of the residual expression associated with model T  with respect to the parameters is a zero matrix\nIdentity(), if the jacobian of the residual expression associated with  model T with respect to the parameters is the identity matrix\nInvariant(), if the jacobian of the residual expression associated with  model T with respect to the parameters is independent of the state rates,  state variables, inputs, parameters, and time.\nConstant(), if the jacobian of the residual expression associated with  model T with respect to the parameters is independent of the state rates,  state variables, inputs, and time.\nLinear(), if the jacobian of the residual expression associated with model T  with respect to the parameters may vary with respect to time, and is  linear with respect to the parameters.\nNonlinear(), if the jacobian of the residual expression associated with  model T with respect to the parameters may vary with respect to time,  and is nonlinear with respect to the parameters.\n\nIf no method is defined for the specified type, return Nonlinear().\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.rate_jacobian_type-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Internals","title":"AerostructuralDynamics.rate_jacobian_type","text":"rate_jacobian_type(::Type{T})\n\nReturn\n\nEmpty(), if the jacobian of the residual expression associated with model T  with respect to the state rates is an empty matrix\nZeros(), if the jacobian of the residual expression associated with model T  with respect to the state rates is a zero matrix\nIdentity(), if the jacobian of the residual expression associated with  model T with respect to the state rates is the identity matrix\nInvariant(), if the jacobian of the residual expression associated with  model T with respect to the state rates is independent of the state rates,  state variables, inputs, parameters, and time.\nConstant(), if the jacobian of the residual expression associated with  model T with respect to the state rates is independent of the state rates,  state variables, inputs, and time.\nLinear(), if the jacobian of the residual expression associated with model T  with respect to the state rates may vary with respect to time, and is  linear with respect to the state rates.\nNonlinear(), if the jacobian of the residual expression associated with  model T with respect to the state rates may vary with respect to time,  and is nonlinear with respect to the state rates.\n\nIf no method is defined for the specified type, return Nonlinear().\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.separate_additional_parameters","page":"Internals","title":"AerostructuralDynamics.separate_additional_parameters","text":"separate_additional_parameters(model, p)\n\nSeparate the additional parameter vector entries in p corresponding to the model coupling, if applicable.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#AerostructuralDynamics.state_jacobian_type-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Internals","title":"AerostructuralDynamics.state_jacobian_type","text":"state_jacobian_type(::Type{T})\n\nReturn\n\nEmpty(), if the jacobian of the residual expression associated with model T  with respect to the state variables is an empty matrix\nZeros(), if the jacobian of the residual expression associated with model T  with respect to the state variables is a zero matrix\nIdentity(), if the jacobian of the residual expression associated with  model T with respect to the state variables is the identity matrix\nInvariant(), if the jacobian of the residual expression associated with  model T with respect to the state variables is independent of the state rates,  state variables, inputs, parameters, and time.\nConstant(), if the jacobian of the residual expression associated with  model T with respect to the state variables is independent of the state rates,  state variables, inputs, and time.\nLinear(), if the jacobian of the residual expression associated with model T  with respect to the state variables may vary with respect to time, and is  linear with respect to the states.\nNonlinear(), if the jacobian of the residual expression associated with  model T with respect to the state variables may vary with respect to time,  and is nonlinear with respect to the states.\n\nIf no method is defined for the specified type, return Nonlinear().\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#AerostructuralDynamics.time_gradient_type-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Internals","title":"AerostructuralDynamics.time_gradient_type","text":"time_gradient_type(::Type{T})\n\nReturn\n\nEmpty(), if the derivative of the residual expression associated with model T  with respect to time is an empty matrix\nZeros(), if the derivative of the residual expression associated with model T  with respect to time is a zero matrix\nInvariant(), if the derivative of the residual expression associated with  model T with respect to time is independent of the state rates,  state variables, inputs, parameters, and time.\nConstant(), if the derivative of the residual expression associated with  model T with respect to time is independent of the state rates,  state variables, inputs, and time.\nLinear(), if the derivative of the residual expression associated with model T  with respect to time may vary with respect to time, and is  linear with respect to time.\nNonlinear(), if the derivative of the residual expression associated with  model T with respect to time may vary with respect to time,  and is nonlinear with respect to time.\n\nIf no method is defined for the specified type, return Nonlinear().\n\n\n\n\n\n","category":"method"},{"location":"couplings/liftingline-rigidbody/#[LiftingLine](@ref)-[RigidBody](@ref)","page":"Lifting Line + Rigid Body","title":"LiftingLine + RigidBody","text":"","category":"section"},{"location":"couplings/liftingline-rigidbody/#Theory","page":"Lifting Line + Rigid Body","title":"Theory","text":"","category":"section"},{"location":"couplings/liftingline-rigidbody/","page":"Lifting Line + Rigid Body","title":"Lifting Line + Rigid Body","text":"This model is defined by coupling the lifting line aerodynamics model with the rigid body model.","category":"page"},{"location":"couplings/liftingline-rigidbody/#Constructors","page":"Lifting Line + Rigid Body","title":"Constructors","text":"","category":"section"},{"location":"couplings/liftingline-rigidbody/","page":"Lifting Line + Rigid Body","title":"Lifting Line + Rigid Body","text":"couple_models(aero::LiftingLine, stru::RigidBody)","category":"page"},{"location":"couplings/liftingline-rigidbody/#AerostructuralDynamics.couple_models-Tuple{LiftingLine, RigidBody}","page":"Lifting Line + Rigid Body","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::LiftingLine, dyn::RigidBody)\n\nCreate a coupled model using a lifting line aerodynamic model and a rigid body dynamics model.  This model introduces additional parameters corresponding to the length, position, and orientation of each lifting line element L p_e e_1 e_2 e_3, followed by the freestream air density rho_infty, rigid body inertial properties m Ixx Iyy Izz Ixz Ixy Iyz, and the additional forces/moments applied on the body F_x F_y F_z M_x M_y M_z.\n\nNOTE: When using this model, the local frame for each lifting line element should be oriented with the x-axis in the chordwise direction, the y-axis in the spanwise direction (out the right wing), and the z-axis in the airfoil normal direction\n\n\n\n\n\n","category":"method"},{"location":"couplings/liftingline-rigidbody/#Example-Initialization","page":"Lifting Line + Rigid Body","title":"Example Initialization","text":"","category":"section"},{"location":"couplings/liftingline-rigidbody/","page":"Lifting Line + Rigid Body","title":"Lifting Line + Rigid Body","text":"using AerostructuralDynamics #hide\nmodel = couple_models(LiftingLine{6}(Wagner()), RigidBody())\nnothing #hide","category":"page"},{"location":"couplings/liftingline-gxbeam/#[LiftingLine](@ref)-[GEBT](@ref)","page":"Lifting Line + Geometrically Exact Beam Theory","title":"LiftingLine + GEBT","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam/#Theory","page":"Lifting Line + Geometrically Exact Beam Theory","title":"Theory","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam/","page":"Lifting Line + Geometrically Exact Beam Theory","title":"Lifting Line + Geometrically Exact Beam Theory","text":"This model is defined by coupling the lifting line aerodynamics model with the geometrically exact beam theory model.","category":"page"},{"location":"couplings/liftingline-gxbeam/#Constructors","page":"Lifting Line + Geometrically Exact Beam Theory","title":"Constructors","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam/","page":"Lifting Line + Geometrically Exact Beam Theory","title":"Lifting Line + Geometrically Exact Beam Theory","text":"couple_models(aero::LiftingLine, stru::GEBT)","category":"page"},{"location":"couplings/liftingline-gxbeam/#AerostructuralDynamics.couple_models-Tuple{LiftingLine, GEBT}","page":"Lifting Line + Geometrically Exact Beam Theory","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::LiftingLine, stru::GEBT)\n\nCreate a coupled model using a lifting line aerodynamic model and a geometrically exact beam theory model.  This model introduces additional parameters corresponding to the freestream air density rho_infty, followed by the external loads F_xi F_yi F_zi M_xi M_yi M_zi or displacements u_xi u_yi u_zi theta_xi theta_yi theta_zi for each node, followed by the constant distributed loads f_xi f_yi f_zi m_xi m_yi m_zi applied on each beam element (excluding aerodynamic loads), followed by the body frame linear and angular velocities u v w p q r.\n\nNOTE: When using this model, the local frame for each beam element should be oriented with the x-axis along the beam's axis, the y-axis forward, and the z-axis normal to the surface\n\n\n\n\n\n","category":"method"},{"location":"couplings/liftingline-gxbeam/#Example-Initialization","page":"Lifting Line + Geometrically Exact Beam Theory","title":"Example Initialization","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam/","page":"Lifting Line + Geometrically Exact Beam Theory","title":"Lifting Line + Geometrically Exact Beam Theory","text":"using AerostructuralDynamics, GXBeam, LinearAlgebra\n\n# discretization\nN = 8 # number of elements\n\n# geometric properties\nspan = 6.096 # m (wing half span)\nchord = 1.8288 # m (chord)\n\n# structural section properties\nxea = 0.33*chord # m (elastic axis, from leading edge)\nEIcc = 9.77e6 # N*m^2 (flat bending rigidity)\nGJ = 0.99e6 # N*m^2 (torsional rigidity)\nμ = 35.71 # kg/m (mass per unit length)\nxcm = 0.43*chord # m (center of mass, from leading edge)\ni11 = 8.64 # kg*m (moment of inertia about elastic axis)\ni22 = 0.1*i11 # moment of inertia about beam y-axis\ni33 = 0.9*i11 # moment of inertia about beam z-axis\n\n# define geometry\nxpt = range(0, 0, length=N+1) # point x-coordinates (in body frame)\nypt = range(0, span, length=N+1) # point y-coordinates (in body frame)\nzpt = range(0, 0, length=N+1) # point z-coordinates (in body frame)\npoints = [[xpt[i],ypt[i],zpt[i]] for i = 1:N+1]\nstart = 1:N # starting point of each beam element\nstop = 2:N+1 # ending point of each beam element\nframes = fill([0 1 0; 1 0 0; 0 0 -1], N) # local to body frame transformation\ncompliance = fill(Diagonal([0, 0, 0, 1/GJ, 1/EIcc, 0]), N) # compliance matrix\nxm2 = xea - xcm\nmass = fill([\n    μ 0 0 0 0 -μ*xm2;\n    0 μ 0 0 0 0;\n    0 0 μ μ*xm2 0 0;\n    0 0 μ*xm2 i11 0 0;\n    0 0 0 0 i22 0;\n    -μ*xm2 0 0 0 0 i33], N) # mass matrix\nassembly = GXBeam.Assembly(points, start, stop; frames, compliance, mass)\n\n# boundary condition initialization\nprescribed = Dict(\n    # fixed left edge\n    1 => GXBeam.PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n        theta_z=0),\n)\n\naero = LiftingLine{N}(Wagner())\n\nstru = GEBT(assembly, prescribed)\n\nmodel = couple_models(aero, stru)\n\nnothing #hide","category":"page"},{"location":"couplings/quasisteady-section/#[QuasiSteady](@ref)-[TypicalSection](@ref)","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"QuasiSteady + TypicalSection","text":"","category":"section"},{"location":"couplings/quasisteady-section/#Theory","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Theory","text":"","category":"section"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"This model is defined by coupling quasi-steady thin airfoil theory aerodynamics","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"with the typical section model.  ","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"To facilitate this coupling, the freestream velocity components u and v are assumed to be aligned with the undeflected chordwise and normal directions, respectively, so that","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"u approx U_infty \nv approx doth \nomega approx dottheta","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"where U_infty is the freestream velocity magnitude, theta is pitch, and h is plunge. To capture the effect of twist on the circulatory lift (since it is no longer implicitly modeled by the fracvu quantity) twist is added to the effective angle of attack from the quasi-steady model so that the effective angle of attack is now given by","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"alpha_texteff = theta - fracvu + fracbuleft( frac12 - a right) omega - alpha_0","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"The original expression for the effective angle of attack may be used by defining the new variable barv = u theta + v such that","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"alpha_texteff = -fracbarvu + fracbuleft( frac12 - a right) omega - alpha_0","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"A small angle assumption is also used to define the lift about the reference location as","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"mathcalL approx mathcalN","category":"page"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"where mathcalN is the normal force per unit span at the reference location.","category":"page"},{"location":"couplings/quasisteady-section/#Constructors","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Constructors","text":"","category":"section"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"couple_models(aero::QuasiSteady, stru::TypicalSection)","category":"page"},{"location":"couplings/quasisteady-section/#AerostructuralDynamics.couple_models-Tuple{QuasiSteady, TypicalSection}","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::QuasiSteady, stru::TypicalSection)\n\nCreate an aerostructural model using a quasi-steady aerodynamics model and a two-degree of freedom typical section model.  This model introduces the freestream velocity U and air density rho as additional parameters.\n\n\n\n\n\n","category":"method"},{"location":"couplings/quasisteady-section/#Example-Usage","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Example Usage","text":"","category":"section"},{"location":"couplings/quasisteady-section/","page":"Quasi-Steady Thin Airfoil Theory + Typical Section","title":"Quasi-Steady Thin Airfoil Theory + Typical Section","text":"Aeroelastic Analysis of a Typical Section","category":"page"},{"location":"guide/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# this is placed here to pre-install matplotlib so the documentation doesn't get cluttered with the installation print statements.\nusing Plots\npyplot()\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"In this guide we introduce you to the basic functionality of this package in a step by step manner.  This is a good starting point for learning about how to use this package.  For more details about how to use a particular model or combination models, refer to the model documentation.  For more examples of how to use this package see the examples.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"guide/#Overview","page":"Getting Started","title":"Overview","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"AerostructuralDynamics is designed to simulate and assess the stability of complex aerostructural systems.  It does this by constructing a system of first order ordinary differential equations and associated jacobians for various aerostructural systems which may be used to find equilibrium points, perform stability analyses, and/or perform time domain simulations.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"This package is designed to be modular, so that models may be easily swapped out for alternative models.  It is also designed to be extensible, so that new models may be incorporated with minimal effort.  To achieve these aims, this package assumes that the governing equations for all models may be expressed as the implicit ordinary differential equation","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"0 = f(dotxxypt)","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"where f(dotx x y p t) is a residual function, dotx is a vector of state rates, x is a vector of state variables, y is a vector of time-varying parameters, p is a vector of time-independent parameters, and t is the current time.  For the purposes of this package we will refer to the time-varying parameters y as \"inputs\" and the time-independent parameters p as \"parameters\".","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Since the governing equations for all models in this package follow the same general form, the process for performing analyses using any standalone and/or coupled model provided by this package is the same.  First, the relevant standalone and/or coupled model must be initialized.  Then, the model's initial state rates, states, inputs, parameters, and time must be defined.  Finally, the chosen analysis is performed.  We demonstrate how to perform these steps in the following sections.","category":"page"},{"location":"guide/#Initializing-Models","page":"Getting Started","title":"Initializing Models","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"If you haven't yet, now would be a good time to install AerostructuralDynamics.  It can be installed from the Julia REPL by typing ] (to enter the package manager) and then running the following command.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"pkg> add https://flow.byu.edu/AerostructuralDynamics.jl","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Now, that the package is installed we need to load it so that we can use it.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using AerostructuralDynamics\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For the purposes of this guide, we will be working with a two-degree-of-freedom typical section model, as shown in the following figure.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Our goal is to create an 2D aeroelastic model which we can use to simulate the behavior of this system.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For the aerodynamic model, we will be using Peters' finite state model with four aerodynamic state variables (see Peters).  For the structural model, we will be using the typical section model (see TypicalSection).  To create a coupled model using these models, we use the couple_models function.  Details about how to initialize these models may be found in the model documentation.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# initialize the aerodynamic model\naerodynamic_model = Peters{4}()\n\n# initialize the structural model\nstructural_model = TypicalSection()\n\n# initialize the structural model\ncoupled_model = couple_models(aerodynamic_model, structural_model)\n\nnothing #hide","category":"page"},{"location":"guide/#Defining-State-Rates,-State-Variables,-Inputs,-and-Parameters","page":"Getting Started","title":"Defining State Rates, State Variables, Inputs, and Parameters","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"As described in the documentation for the Peters model, its state, input, and parameter vectors are defined as","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"x_textaero = beginbmatrix lambda_1  lambda_2  vdots  lambda_N endbmatrix quad\ny_textaero = beginbmatrix u  v  omega endbmatrix quad\np = beginbmatrix a  b  a_0  alpha_0 endbmatrix","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"where lambda_1 lambda_2 dots lambda_N are the aerodynamic states, u is the chordwise freestream velocity, v is the normal freestream velocity, omega is the angular freestream velocity, a is the normalized reference location relative to the semi-chord, b is the semi-chord, a_0 is the section lift slope, and alpha_0 is the section zero lift angle of attack.  Positive freestream velocity components are defined as shown in the following figure.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"As described in the documentation for the TypicalSection model, the state, input, and parameter vectors for the typical section model are defined as","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"x_textstru = beginbmatrix h  theta  doth  dottheta endbmatrix quad y_textstru = beginbmatrix mathcalL  mathcalM endbmatrix quad p_textstru = beginbmatrix k_h  k_theta  m  S_theta  I_theta endbmatrix","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"where h is plunge, theta is pitch, mathcalL is the lift per unit span, mathcalM is the moment per unit span about the reference point, k_h is the linear spring constant, and k_theta is the torsional spring constant, m is the mass per unit span, S_theta is the structural imbalance, and I_θ is the mass moment of inertia about the reference point.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"In this package, we define the state variables and inputs of a coupled model as the state variables and inputs of its component models concatenated.  We also define the parameters of a coupled model as the parameters of its component models concatenated, followed by a set of additional parameters which are specific to the coupled model.  As noted in the documentation for the coupled model we are using in this guide, the additional parameters introduced by the coupled model we consider in this example are the freestream velocity U_infty and air density rho.  The state, input, and parameter vectors for this coupled model are therefore","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"x_textcoupled = beginbmatrix lambda_1  lambda_2  vdots  lambda_N  h  theta  doth  dottheta endbmatrix quad y_textcoupled = beginbmatrix u  v  omega  mathcalL  mathcalM endbmatrix quad p_textcoupled = beginbmatrix a  b  a_0  alpha_0  k_h  k_theta  m  S_theta  I_theta  U_infty  rho endbmatrix","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Rate, state, input, and parameter vectors may either be constructed directly or initialized using the get_states, get_inputs, and/or get_parameters convenience functions.  In either case, refer to the model documentation for the proper variable order and/or argument names.  In the following block of code, we set the parameters for our coupled model directly.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# non-dimensional parameters\na = -1/5 # reference point normalized location\ne = -1/10 # center of mass normalized location\nμ = 20 # = m/(ρ*pi*b^2) (mass ratio)\nr2 = 6/25 # = Iθ/(m*b^2) (radius of gyration about P)\nσ = 2/5 # = ωh/ωθ (natural frequency ratio)\nxθ = e - a\na0 = 2*pi # lift curve slope\nα0 = 0 # zero lift angle\ncd0 = 0\ncm0 = 0\nV = 1.0 # = U/(b*ωθ) (reduced velocity)\n\n# chosen dimensional parameters\nb = 1\nρ = 1\nωθ = 1\n\n# derived dimensional parameters\nm = μ*ρ*pi*b^2\nSθ = m*xθ*b\nIθ = r2*m*b^2\nωh = σ*ωθ\nkh = m*ωh^2\nkθ = Iθ*ωθ^2\nU = V*b*ωθ\n\n# parameters\np_aero = [a, b, a0, α0, cd0, cm0]\np_stru = [kh, kθ, m, Sθ, Iθ]\np_additional = [U, ρ]\np = vcat(p_aero, p_stru, p_additional)\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For standalone models, both inputs y parameters p are user-specified.  For coupled models, however, inputs to one model in the coupled system often correspond to outputs from another model in the coupled system.  For example, the lift and moment required by the typical section model are defined by Peter's finite state model and the velocities required by Peters' finite state model are defined as a function of the state variables of the typical section model.  To model these interdependencies, this package assumes that the inputs of a coupled model may be defined as a function of the state rates, states, and parameters of the coupled model as well as the current time.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"y = g(dotx x p t)","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To evaluate this function to find the inputs for a coupled model, the get_coupling_inputs function may be used.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# choose rates, state, and time at which to calculate the coupling inputs\ndx = zeros(number_of_states(coupled_model))\nx = zeros(number_of_states(coupled_model))\nt = 0\n\n# calculate the coupling inputs\ny = get_coupling_inputs(coupled_model, dx, x, p, t)\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"In order to more easily interpret the elements of the rate, state, input, and/or parameter vectors, the separate_states, separate_inputs, and/or separate_parameters functions may be used.  These functions separate and assign names to the elements of the state, input and/or parameter vectors so that the identity of each element in these vectors may be more easily understood.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"rates = separate_states(coupled_model, dx)\nstates = separate_states(coupled_model, x)\ninputs = separate_inputs(coupled_model, y)\nparameters = separate_parameters(coupled_model, p)\n\nnothing #hide","category":"page"},{"location":"guide/#Finding-an-Equilibrium-Point","page":"Getting Started","title":"Finding an Equilibrium Point","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To find equilibrium points, we first need to create an object of type DifferentialEquations.ODEFunction using the get_ode function.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# returns an ODEFunction\nf = get_ode(coupled_model)\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Then a steady state solution may be found using DifferentialEquations.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using DifferentialEquations\n\n# initial guess for state variables\nx0 = zeros(number_of_states(coupled_model))\n\n# steady state problem\nprob = SteadyStateProblem(f, x0, p)\n\n# steady state solution\nx_ss = solve(prob, SSRootfind())\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Since our system is linear with respect to the state variables it has one equilibrium point at the origin.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Note that the coupling inputs are calculated automatically as a function of the state variables and parameters for coupled models.  For standalone model evaluation, the inputs are appended to the end of the parameter vector.","category":"page"},{"location":"guide/#Performing-a-Stability-Analysis","page":"Getting Started","title":"Performing a Stability Analysis","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The stability of a model for a given set of state variables, inputs, and parameters may be determined by calling the get_eigen function, which returns eigenvalues, left eigenvectors, and right eigenvectors.  For nonlinear systems, the provided state variables must correspond to an equilibrium point for the stability analysis to be theoretically valid.  Since our aeroelastic system is linear with respect to the state variables, any set of state variables will yield the same result.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"λ, U, V = get_eigen(coupled_model, x_ss, p)\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"A positive real part corresponding to any eigenvalue returned from the get_eigen function indicates that the system is unstable for the provided set of state variables, inputs, and parameters.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For some models, we can visualize the mode shapes with the help of custom plot recipes provided by this package.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using Plots\npyplot()\n\n# Plot Recipes:\n# - plot(model, dx, x, p, t)\n# - plot(model, x, p, t) # assumes `dx = zero(x)`\n# - plot(model, sol, t) # plots the solution geometry at time `t`\n# - plot(model, sol) # plots the solution geometry at index `sol.tslocation`\n\n# visualize least stable eigenmode\niλ = argmax(real.(λ))\nλi = imag(λ[iλ])*1im # don't include damping\nvi = V[:,iλ]\n\n# animation time\nt1 = -pi/abs(imag(λi))\nt2 = pi/abs(imag(λi))\n\n# eigenvector scaling\nscaling = 0.5\n\n# create animation\nanim = @animate for t in range(t1, t2, length=100)\n\n    xi = x_ss + scaling*real.(vi*exp(λi*t))\n\n    plot(coupled_model, xi, p, t)\n\nend\n\n# save animation\ngif(anim, \"guide-eigenmode.gif\")\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/#Performing-a-Time-Domain-Simulation","page":"Getting Started","title":"Performing a Time Domain Simulation","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"To simulate the behavior of our model we first need to create an object of type DifferentialEquations.ODEFunction using the get_ode function.  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"f = get_ode(coupled_model)\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Then the DifferentialEquations package may be used to solve the ordinary differential equation corresponding to the model.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using DifferentialEquations\n\n# non-zero plunge degree of freedom\nx0 = [0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0]\n\n# simulate for 100 seconds\ntspan = (0.0, 100.0)\n\n# construct ODE problem\nprob = DifferentialEquations.ODEProblem(f, x0, tspan, p)\n\n# solve ODE\nsol = DifferentialEquations.solve(prob)\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We can use DifferentialEquations' built-in interface with the Plots package to plot the simulation results.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using Plots\npyplot()\n\nplot(sol,\n    vars = [5,6,7,8],\n    xlabel = \"t\",\n    ylabel = permutedims([\n        \"\\$h\\$\",\n        \"\\$\\\\theta\\$\",\n        \"\\$\\\\dot{h}\\$\",\n        \"\\$\\\\dot{\\\\theta}\\$\",\n        ]),\n    label = \"\",\n    layout = (4, 1),\n    size = (600,1200)\n    )\n\nsavefig(\"guide-solution.svg\") #hide\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For some models, we can also visualize the solution geometry and/or create animations with the help of custom plot recipes provided by this package.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# Plot Recipes:\n# - plot(model, dx, x, p, t)\n# - plot(model, x, p, t) # assumes `dx = zero(x)`\n# - plot(model, sol, t) # plots the solution geometry at time `t`\n# - plot(model, sol) # plots the solution geometry at index `sol.tslocation`\n\n# create animation\nanim = @animate for t in range(tspan[1], tspan[2], length=200)\n    plot(coupled_model, sol, t)\nend\n\n# save animation\ngif(anim, \"guide-simulation.gif\")\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"aerodynamics/liftingline/#Lifting-Line-Model","page":"Lifting Line","title":"Lifting Line Model","text":"","category":"section"},{"location":"aerodynamics/liftingline/#Theory","page":"Lifting Line","title":"Theory","text":"","category":"section"},{"location":"aerodynamics/liftingline/","page":"Lifting Line","title":"Lifting Line","text":"Two-dimensional aerodynamic models may be applied in the context of a three-dimensional analysis by applying these models at multiple chordwise sections along the span of one or more lifting surfaces.  This type of model is applicable when spanwise flow effects are negligible, which is often the case for high aspect ratio wings.","category":"page"},{"location":"aerodynamics/liftingline/","page":"Lifting Line","title":"Lifting Line","text":"The lifting line model implemented in this package assumes that the aerodynamics of each section is independent of the aerodynamics of the other sections, except as coupled through other models.  The state variables and inputs for this model correspond to the state variables, inputs, and parameters of each of the two-dimensional aerodynamic models, concatenated.  Rate equations are also concatenated.  ","category":"page"},{"location":"aerodynamics/liftingline/","page":"Lifting Line","title":"Lifting Line","text":"When coupled with a structural model, aircraft linear and angular accelerations are obtained from the structural model and transformed into the (deformed) local beam frame using an appropriate transformation matrix.  The local freestream velocities/accelerations and pitch rates/accelerations are then defined by a subset of the transformed linear and angular accelerations and cross-flow effects are neglected.   An inverse transformation may then be performed to transform the local aerodynamic forces/moments into the reference frame used by the structural model.","category":"page"},{"location":"aerodynamics/liftingline/#Type-Definition","page":"Lifting Line","title":"Type Definition","text":"","category":"section"},{"location":"aerodynamics/liftingline/","page":"Lifting Line","title":"Lifting Line","text":"LiftingLine","category":"page"},{"location":"aerodynamics/liftingline/#AerostructuralDynamics.LiftingLine","page":"Lifting Line","title":"AerostructuralDynamics.LiftingLine","text":"LiftingLine{NA,TA} <: AbstractModel\n\nLifting line model with NA cross sections, using the aerodynamic models in TA. State variables, inputs, and parameters correspond to the state variables, inputs, and parameters of each of the cross sections concatenated\n\n\n\n\n\n","category":"type"},{"location":"aerodynamics/liftingline/#Constructors","page":"Lifting Line","title":"Constructors","text":"","category":"section"},{"location":"aerodynamics/liftingline/","page":"Lifting Line","title":"Lifting Line","text":"LiftingLine(models)","category":"page"},{"location":"aerodynamics/liftingline/#AerostructuralDynamics.LiftingLine-Tuple{Any}","page":"Lifting Line","title":"AerostructuralDynamics.LiftingLine","text":"LiftingLine(models)\n\nConstruct a lifting line aerodynamic model given a tuple of 2D aerodynamic models.\n\n\n\n\n\nLiftingLine{NA}(model)\n\nConstruct a lifting line aerodynamic model using NA instances of model.\n\n\n\n\n\n","category":"method"},{"location":"aerodynamics/liftingline/#Example-Initialization","page":"Lifting Line","title":"Example Initialization","text":"","category":"section"},{"location":"aerodynamics/liftingline/","page":"Lifting Line","title":"Lifting Line","text":"using AerostructuralDynamics #hide\nmodel = LiftingLine{4}(Wagner())\nnothing #hide","category":"page"},{"location":"couplings/peters-section/#[Peters](@ref)-[TypicalSection](@ref)","page":"Peters' Finite State + Typical Section","title":"Peters + TypicalSection","text":"","category":"section"},{"location":"couplings/peters-section/#Theory","page":"Peters' Finite State + Typical Section","title":"Theory","text":"","category":"section"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"This model is defined by coupling Peter's finite state model","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"with the typical section model.  ","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"To facilitate this coupling, the freestream velocity components u and v are assumed to be aligned with the undeflected chordwise and normal directions, respectively, so that","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"u approx U_infty \nv approx doth \nomega approx dottheta","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"where U_infty is the freestream velocity magnitude, theta is pitch, and h is plunge. To capture the effect of twist on the circulatory lift (since it is no longer implicitly modeled by the fracvu quantity) twist is added to the effective angle of attack from Peter's finite state model so that the effective angle of attack is now given by","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"alpha_texteff = theta - fracvu + fracbuleft( frac12 - a right) omega  + fraclambda_0u - alpha_0","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"The original expression for the effective angle of attack may be used by defining the new variable barv = u theta + v such that","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"alpha_texteff = -fracbarvu + fracbuleft( frac12 - a right) omega + fraclambda_0u - alpha_0","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"A small angle assumption is also used to define the lift about the reference location as","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"mathcalL approx mathcalN","category":"page"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"where mathcalN is the normal force per unit span at the reference location.","category":"page"},{"location":"couplings/peters-section/#Constructors","page":"Peters' Finite State + Typical Section","title":"Constructors","text":"","category":"section"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"couple_models(aero::Peters, stru::TypicalSection)","category":"page"},{"location":"couplings/peters-section/#AerostructuralDynamics.couple_models-Tuple{Peters, TypicalSection}","page":"Peters' Finite State + Typical Section","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::Peters, stru::TypicalSection)\n\nCreate an aerostructural model using the unsteady aerodynamic model defined by Peters et al. and a two-degree of freedom typical section model.  This model introduces the freestream velocity U_infty and air density rho_infty as additional parameters.\n\n\n\n\n\n","category":"method"},{"location":"couplings/peters-section/#Example-Usage","page":"Peters' Finite State + Typical Section","title":"Example Usage","text":"","category":"section"},{"location":"couplings/peters-section/","page":"Peters' Finite State + Typical Section","title":"Peters' Finite State + Typical Section","text":"Aeroelastic Analysis of a Typical Section","category":"page"},{"location":"structures/gxbeam/#Geometrically-Exact-Beam-Theory-Model","page":"Geometrically Exact Beam Theory","title":"Geometrically Exact Beam Theory Model","text":"","category":"section"},{"location":"structures/gxbeam/#Theory","page":"Geometrically Exact Beam Theory","title":"Theory","text":"","category":"section"},{"location":"structures/gxbeam/","page":"Geometrically Exact Beam Theory","title":"Geometrically Exact Beam Theory","text":"A geometrically exact beam model implemented using the GXBeam package.","category":"page"},{"location":"structures/gxbeam/#Type-Definition","page":"Geometrically Exact Beam Theory","title":"Type Definition","text":"","category":"section"},{"location":"structures/gxbeam/","page":"Geometrically Exact Beam Theory","title":"Geometrically Exact Beam Theory","text":"GEBT","category":"page"},{"location":"structures/gxbeam/#AerostructuralDynamics.GEBT","page":"Geometrically Exact Beam Theory","title":"AerostructuralDynamics.GEBT","text":"GEBT <: AbstractModel\n\nGeometrically exact beam theory model, as implemented by the GXBeam package. State variables are as defined by GXBeam.  Inputs correspond to the external forces F_xi F_yi F_zi M_xi M_yi M_zi or displacements u_xi u_yi u_zi theta_xi theta_yi theta_zi applied to each node, followed by the distributed loads f_xi f_yi f_zi m_xi m_yi m_zi applied to each beam element, followed by the linear and angular velocity of the system. Parameters correspond to the location p_x p_y p_z of each node followed by each beam element's properties. Each beam element's properties are defined by a triad which defines the orientation of the beam element e_1x e_1y e_1z e_2x e_2y e_2z e_3x e_3y e_3z, followed by the 21 independent entries of the compliance matrix C_11 C_12 C_13 C_14 C_15 C_16 C_22 C_23 C_24 C_25 C_26 C_33 C_34 C_35 C_36 C_44 C_45 C_46 C_55 C_56 C_66, followed by the beam element's inertial properties mu x_m2 x_m3 i_22 i_33 i_23.\n\n\n\n\n\n","category":"type"},{"location":"structures/gxbeam/#Constructors","page":"Geometrically Exact Beam Theory","title":"Constructors","text":"","category":"section"},{"location":"structures/gxbeam/","page":"Geometrically Exact Beam Theory","title":"Geometrically Exact Beam Theory","text":"GEBT(assembly, prescribed)","category":"page"},{"location":"structures/gxbeam/#AerostructuralDynamics.GEBT-Tuple{Any, Any}","page":"Geometrically Exact Beam Theory","title":"AerostructuralDynamics.GEBT","text":"GEBT(assembly, prescribed; kwargs...)\n\nConstruct a geometrically exact beam theory structural model with connectivity as specified in assembly and displacement constraints as specified in prescribed.\n\nKeyword Arguments\n\nforce_scaling: Factor used to scale system forces/moments internally.  If  not specified, a suitable default will be chosen based on the entries of the  compliance matrix.\nmass_scaling: Factor used to scale system mass/inertia internally.  If not  specified, a suitable default will be chosen based on the entries of the  mass matrix.\n\n\n\n\n\n","category":"method"},{"location":"structures/gxbeam/#Example-Initialization","page":"Geometrically Exact Beam Theory","title":"Example Initialization","text":"","category":"section"},{"location":"structures/gxbeam/","page":"Geometrically Exact Beam Theory","title":"Geometrically Exact Beam Theory","text":"using AerostructuralDynamics, GXBeam, LinearAlgebra\n\n# discretization\nN = 8 # number of elements\n\n# geometric properties\nspan = 6.096 # m (wing half span)\nchord = 1.8288 # m (chord)\n\n# structural section properties\nxea = 0.33*chord # m (elastic axis, from leading edge)\nEIcc = 9.77e6 # N*m^2 (flat bending rigidity)\nGJ = 0.99e6 # N*m^2 (torsional rigidity)\nμ = 35.71 # kg/m (mass per unit length)\nxcm = 0.43*chord # m (center of mass, from leading edge)\ni11 = 8.64 # kg*m (moment of inertia about elastic axis)\ni22 = 0.1*i11 # moment of inertia about beam y-axis\ni33 = 0.9*i11 # moment of inertia about beam z-axis\n\n# define geometry\nxpt = range(0, 0, length=N+1) # point x-coordinates (in body frame)\nypt = range(0, span, length=N+1) # point y-coordinates (in body frame)\nzpt = range(0, 0, length=N+1) # point z-coordinates (in body frame)\npoints = [[xpt[i],ypt[i],zpt[i]] for i = 1:N+1]\nstart = 1:N # starting point of each beam element\nstop = 2:N+1 # ending point of each beam element\nframes = fill([0 1 0; 1 0 0; 0 0 -1], N) # local to body frame transformation\ncompliance = fill(Diagonal([0, 0, 0, 1/GJ, 1/EIcc, 0]), N) # compliance matrix\nxm2 = xea - xcm\nmass = fill([\n    μ 0 0 0 0 -μ*xm2;\n    0 μ 0 0 0 0;\n    0 0 μ μ*xm2 0 0;\n    0 0 μ*xm2 i11 0 0;\n    0 0 0 0 i22 0;\n    -μ*xm2 0 0 0 0 i33], N) # mass matrix\nassembly = GXBeam.Assembly(points, start, stop; frames, compliance, mass)\n\n# boundary condition initialization\nprescribed = Dict(\n    # fixed left edge\n    1 => GXBeam.PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n        theta_z=0),\n)\n\nmodel = GEBT(assembly, prescribed)\n\nnothing #hide","category":"page"},{"location":"couplings/liftingline-gxbeam-rigidbody/#[LiftingLine](@ref)-[GEBT](@ref)-[RigidBody](@ref)","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"LiftingLine + GEBT + RigidBody","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam-rigidbody/#Theory","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"Theory","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam-rigidbody/","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","text":"This model is defined by coupling the lifting line aerodynamics model with the geometrically exact beam theory model and the rigid body dynamics model.","category":"page"},{"location":"couplings/liftingline-gxbeam-rigidbody/#Constructors","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"Constructors","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam-rigidbody/","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","text":"couple_models(aero::LiftingLine, stru::GEBT, dyn::RigidBody)","category":"page"},{"location":"couplings/liftingline-gxbeam-rigidbody/#AerostructuralDynamics.couple_models-Tuple{LiftingLine, GEBT, RigidBody}","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::LiftingLine, stru::GEBT, dyn::RigidBody)\n\nCreate an aerostructural model using a lifting line aerodynamic model coupled with a geometrically exact beam theory and a rigid-body dynamics model.  This model introduces additional parameters corresponding to the freestream air density rho_infty, followed by the external loads F_xi F_yi F_zi M_xi M_yi M_zi or displacements u_xi u_yi u_zi theta_xi theta_yi theta_zi for each node, followed by the constant distributed loads f_xi f_yi f_zi m_xi m_yi m_zi applied on each beam element (excluding aerodynamic loads).\n\nNOTE: When using this model, the local frame for each beam element should be oriented with the x-axis along the beam's axis, the y-axis forward, and the z-axis normal to the surface\n\n\n\n\n\n","category":"method"},{"location":"couplings/liftingline-gxbeam-rigidbody/#Example-Initialization","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"Example Initialization","text":"","category":"section"},{"location":"couplings/liftingline-gxbeam-rigidbody/","page":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","title":"Lifting Line + Geometrically Exact Beam Theory + Rigid Body","text":"using AerostructuralDynamics, GXBeam, LinearAlgebra\n\n# discretization\nN = 8 # number of elements\n\n# geometric properties\nspan = 6.096 # m (wing half span)\nchord = 1.8288 # m (chord)\n\n# structural section properties\nxea = 0.33*chord # m (elastic axis, from leading edge)\nEIcc = 9.77e6 # N*m^2 (flat bending rigidity)\nGJ = 0.99e6 # N*m^2 (torsional rigidity)\nμ = 35.71 # kg/m (mass per unit length)\nxcm = 0.43*chord # m (center of mass, from leading edge)\ni11 = 8.64 # kg*m (moment of inertia about elastic axis)\ni22 = 0.1*i11 # moment of inertia about beam y-axis\ni33 = 0.9*i11 # moment of inertia about beam z-axis\n\n# define geometry\nxpt = range(0, 0, length=N+1) # point x-coordinates (in body frame)\nypt = range(0, span, length=N+1) # point y-coordinates (in body frame)\nzpt = range(0, 0, length=N+1) # point z-coordinates (in body frame)\npoints = [[xpt[i],ypt[i],zpt[i]] for i = 1:N+1]\nstart = 1:N # starting point of each beam element\nstop = 2:N+1 # ending point of each beam element\nframes = fill([0 1 0; 1 0 0; 0 0 -1], N) # local to body frame transformation\ncompliance = fill(Diagonal([0, 0, 0, 1/GJ, 1/EIcc, 0]), N) # compliance matrix\nxm2 = xea - xcm\nmass = fill([\n    μ 0 0 0 0 -μ*xm2;\n    0 μ 0 0 0 0;\n    0 0 μ μ*xm2 0 0;\n    0 0 μ*xm2 i11 0 0;\n    0 0 0 0 i22 0;\n    -μ*xm2 0 0 0 0 i33], N) # mass matrix\nassembly = GXBeam.Assembly(points, start, stop; frames, compliance, mass)\n\n# boundary condition initialization\nprescribed = Dict(\n    # fixed left edge\n    1 => GXBeam.PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n        theta_z=0),\n)\n\naero = LiftingLine{N}(Wagner())\n\nstru = GEBT(assembly, prescribed)\n\ndyn = RigidBody()\n\nmodel = couple_models(aero, stru, dyn)\n\nnothing #hide","category":"page"},{"location":"structures/section/#typical-section-model","page":"Typical Section","title":"Typical Section Model","text":"","category":"section"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"(Image: )","category":"page"},{"location":"structures/section/#Theory","page":"Typical Section","title":"Theory","text":"","category":"section"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"The equations of motion for this model are:","category":"page"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"beginbmatrix m  S_theta  S_theta  I_theta endbmatrix\nbeginbmatrix ddoth  ddottheta endbmatrix +\nbeginbmatrix k_h  0  0  k_h endbmatrix\nbeginbmatrix h  theta endbmatrix =\nbeginbmatrix -mathcalL  mathcalM endbmatrix","category":"page"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"where k_h is the linear spring constant, k_theta is the torsional spring constant, m is the mass per unit span, S_theta is the structural imbalance, I_theta is the mass moment of inertia, mathcalL is the lift per unit span, and mathcalM is the moment per unit span.","category":"page"},{"location":"structures/section/#Type-Definition","page":"Typical Section","title":"Type Definition","text":"","category":"section"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"TypicalSection","category":"page"},{"location":"structures/section/#AerostructuralDynamics.TypicalSection","page":"Typical Section","title":"AerostructuralDynamics.TypicalSection","text":"TypicalSection <: UnsteadyModel\n\nTypical section structural model with state variables h theta doth dottheta, inputs mathcalL mathcalM, and parameters k_h k_theta m S_theta I_theta\n\n\n\n\n\n","category":"type"},{"location":"structures/section/#Constructors","page":"Typical Section","title":"Constructors","text":"","category":"section"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"TypicalSection()","category":"page"},{"location":"structures/section/#AerostructuralDynamics.TypicalSection-Tuple{}","page":"Typical Section","title":"AerostructuralDynamics.TypicalSection","text":"TypicalSection()\n\nInitialize an object of type TypicalSection\n\n\n\n\n\n","category":"method"},{"location":"structures/section/#Example-Usage","page":"Typical Section","title":"Example Usage","text":"","category":"section"},{"location":"structures/section/","page":"Typical Section","title":"Typical Section","text":"Aeroelastic Analysis of a Typical Section","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Aeroelastic-Analysis-of-a-Typical-Section","page":"Examples","title":"Aeroelastic Analysis of a Typical Section","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we demonstrate how to perform a two-dimensional aeroelastic analysis using a typical section model with two degrees of freedom.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The equations of motion for this model are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"m left(ddoth+b x_theta ddottheta right) + k_h h = -L \nI_P ddottheta + m b x_theta ddoth + k_theta = M","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where b is the semichord length, k_h is the linear spring constant, k_theta is the torsional spring constant, m is the mass per unit span, x_theta is the distance to the center of mass from the reference point, I_θ is the moment of inertia about the reference point, L is the lift per unit span, and M is the moment per unit span about the reference point.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This package has a number of different two-dimensional aerodynamic models which we may use to model the aerodynamics of the typical section model.  These models include a steady-state model, a quasi-steady model, an unsteady aerodynamic model based on Wagner's function, and Peters' finite state aerodynamic model.  We will perform an aeroelastic analysis using each of these models and compare the results.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The non-dimensional parameters we will use are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"a = -15 quad e = -110  \nr^2 = fracI_Pm b^2 quad sigma = fracomega_homega_theta \nmu = fracmrho_infty pi b^2 quad V = fracUb omega_theta","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where a is the normalized distance from the semichord to the reference point, e is the normalized distance from the semichord to the center of mass, and omega_h and omega_theta are the uncoupled natural frequencies, defined as follows.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"omega_h = sqrtfrack_hm quad omega_theta = sqrtfrack_thetaI_P","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AerostructuralDynamics, DifferentialEquations, LinearAlgebra\n\n# reduced velocity range\nV = range(1e-6, 3.1, length=5000) # = U/(b*ωθ) (reduced velocity)\n\n# non-dimensional parameters\na = -1/5 # reference point normalized location\ne = -1/10 # center of mass normalized location\nμ = 20 # = m/(ρ*pi*b^2) (mass ratio)\nr2 = 6/25 # = Iθ/(m*b^2) (radius of gyration about P)\nσ = 2/5 # = ωh/ωθ (natural frequency ratio)\nxθ = e - a\na0 = 2*pi # lift curve slope\nα0 = 0 # zero lift angle\ncd0 = 0\ncm0 = 0\n\n# chosen dimensional parameters\nb = 1\nρ = 1\nωθ = 1\n\n# derived dimensional parameters\nm = μ*ρ*pi*b^2\nSθ = m*xθ*b\nIθ = r2*m*b^2\nωh = σ*ωθ\nkh = m*ωh^2\nkθ = Iθ*ωθ^2\n\n# dimensionalized velocity\nU = V*b*ωθ\n\n# aerodynamic models\naerodynamic_models = (Steady(), QuasiSteady(), Wagner(), Peters{6}())\n\n# structural model\nstructural_model = TypicalSection()\n\n# eigenvalue/eigenvector storage\nλ = Vector{Matrix{ComplexF64}}(undef, length(aerodynamic_models))\nUλ = Vector{Array{ComplexF64,3}}(undef, length(aerodynamic_models))\nVλ = Vector{Array{ComplexF64,3}}(undef, length(aerodynamic_models))\n\n# loop through each aerodynamic model\nfor (ia, aerodynamic_model) in enumerate(aerodynamic_models)\n\n    # coupled model\n    model = couple_models(aerodynamic_model, structural_model)\n\n    # ode representation of the coupled model\n    f = get_ode(model)\n\n    # equilibrium rates are zero\n    dx = zeros(number_of_states(model))\n\n    # initial guess for equilibrium states\n    x0 = zeros(number_of_states(model))\n\n    # current time\n    t = 0.0\n\n    # eigenvalue/eigenvector storage\n    nλ = number_of_states(model)\n    λ[ia] = zeros(ComplexF64, nλ, length(V))\n    Uλ[ia] = zeros(ComplexF64, nλ, nλ, length(V))\n    Vλ[ia] = zeros(ComplexF64, nλ, nλ, length(V))\n\n    # loop through each reduced frequency\n    for i = 1:length(V)\n\n        # set parameters\n        p_aero = [a, b, a0, α0, cd0, cm0]\n        p_stru = [kh, kθ, m, Sθ, Iθ]\n        p_input = [U[i], ρ]\n        p = vcat(p_aero, p_stru, p_input)\n\n        # find equilibrium point\n        x = solve(SteadyStateProblem(f, x0, p))\n\n        # find corresponding inputs\n        y = get_coupling_inputs(model, dx, x, p, t)\n\n        # perform linear stability analysis\n        λi, Uλi, Vλi = get_eigen(model, dx, x, y, p, t)\n\n        # correlate eigenvalues\n        if i > 1\n            # previous left eigenvector matrix\n            Uλpi = Uλ[ia][:,:,i-1]\n\n            # current mass matrix\n            Mi = get_rate_jacobian(model, dx, x, y, p, t)\n\n            # use correlation matrix to correlate eigenmodes\n            perm, corruption = correlate_eigenmodes(Uλpi, Mi, Vλi)\n\n            # re-arrange eigenmodes\n            λi = λi[perm]\n            Uλi = Uλi[perm,:]\n            Vλi = Vλi[:,perm]\n        end\n\n        # save eigenvalues/eigenvectors\n        λ[ia][:,i] = λi\n        Uλ[ia][:,:,i] = Uλi\n        Vλ[ia][:,:,i] = Vλi\n    end\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We now plot the results for each aerodynamic model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\nsp1 = plot(\n    title = \"Non-Dimensional Frequency\",\n    xlim = (0,3.1),\n    xtick = 0.0:0.5:3.0,\n    xlabel = \"\\$ \\\\frac{U}{b \\\\omega_\\\\theta} \\$\",\n    ylim = (0, 1.05),\n    ytick = 0.0:0.2:1.0,\n    ylabel = \"\\$ \\\\frac{\\\\Omega}{\\\\omega_\\\\theta} \\$\",\n    framestyle = :zerolines,\n    titlefontsize = 14,\n    guidefontsize = 14,\n    legendfontsize = 11,\n    tickfontsize = 11,\n    legend = :topright,\n    foreground_color_legend = nothing,\n    background_color_legend = nothing,\n    minorgrid=true\n    )\n\nsp2 = plot(\n    title = \"Non-Dimensional Damping\",\n    xlim = (0,3.1),\n    xtick = 0.0:0.5:3.0,\n    xlabel = \"\\$ \\\\frac{U}{b \\\\omega_\\\\theta} \\$\",\n    ylim = (-0.7, 0.605),\n    ytick = -0.6:0.2:0.6,\n    ylabel = \"\\$ \\\\frac{Γ}{\\\\omega_\\\\theta} \\$\",\n    framestyle = :zerolines,\n    titlefontsize = 14,\n    guidefontsize = 14,\n    legendfontsize = 11,\n    tickfontsize = 11,\n    legend = :topleft,\n    foreground_color_legend = nothing,\n    background_color_legend = nothing,\n    minorgrid = true\n    )\n\nlabels = [\"Steady\", \"Quasi-Steady\", \"Wagner\", \"Peters (N=6)\"]\n\nfor ia = 1:length(aerodynamic_models)\n\n    plot!(sp1, V, imag.(λ[ia][1,:])/ωθ,\n        label = labels[ia],\n        color = ia,\n        markersize = 1,\n        markerstrokewidth = 0,\n        )\n\n    for i = 2:size(λ[ia], 1)\n        plot!(sp1, V, imag.(λ[ia][i,:])/ωθ,\n            label = \"\",\n            color = ia,\n            markersize = 1,\n            markerstrokewidth = 0,\n            )\n    end\n\n    plot!(sp2, V, real.(λ[ia][1,:])/ωθ,\n        label = labels[ia],\n        color = ia,\n        markersize = 1,\n        markerstrokewidth = 0,\n        )\n\n    for i = 2:size(λ[ia], 1)\n        plot!(sp2, V, real.(λ[ia][i,:])/ωθ,\n            label = \"\",\n            color = ia,\n            markersize = 1,\n            markerstrokewidth = 0,\n            )\n    end\nend\n\np1 = plot(sp1, sp2, layout = (2, 1), size = (600, 800))\n\nsavefig(p1, \"typical-section-stability.svg\") #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Using the Wagner and/or Peters aerodynamic models yields a flutter reduced velocity around 2.2, while the steady and/or quasi-steady aerodynamic models predict significantly lower flutter velocities.  The aerodynamic state variables of the Wagner and Peters models allows these models to capture the impact of vortex shedding on the lift and drag of the profile, therefore we can expect these models to yield more accurate results than the steady-state and quasi-steady models.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can visualize and/or create animations of the flutter mode with the help of custom plot recipes.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# flutter reduced velocity\nVf = 2.2\n\n# aerodynamic model\nia = 4 # Peter's finite state model\n\n# coupled model\nmodel = couple_models(aerodynamic_models[ia], structural_model)\n\n# flutter mode identity\nit = argmin(abs.(V .- Vf))\niλ = argmin(abs.(real.(λ[ia][:,it])))\n\n# flutter mode eigenvalue and eigenvector\nλf = λ[ia][iλ,it]\nvf = Vλ[ia][:,iλ,it]\n\n# flutter mode state rates\ndxf = zeros(number_of_states(model))\n\n# flutter mode state variables\nxf = zeros(number_of_states(model))\n\n# flutter mode parameters\np_aero = [a, b, a0, α0, cd0, cm0]\np_stru = [kh, kθ, m, Sθ, Iθ]\np_input = [Vf*b*ωθ, ρ]\npf = vcat(p_aero, p_stru, p_input)\n\n# animation time\nt1 = -pi/abs(imag(λf))\nt2 = pi/abs(imag(λf))\n\n# eigenvector scaling\nscaling = 0.5\n\n# create animation\nanim = @animate for t in range(t1, t2, length=50)\n\n    xi = xf + scaling*real.(vf*exp(λf*t))\n\n    plot(model, dxf, xi, pf, t)\n\nend\n\n# save animation\ngif(anim, \"typical-section-flutter-mode.gif\")\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The non-dimensional parameters we use for this example match those used by Hodges and Pierce in \"Introduction to Structural Dynamics and Aeroelasticity\".  Hodges and Pierce performed the analysis using a steady state model and Peter's finite state model with six state variables.   The results presented here for the steady-state and Peters' finite state models match the results presented by Hodges and Pierce in \"Introduction to Structural Dynamics and Aeroelasticity\", which validates our implementation of these models.  Additionally, since the flutter speed predicted by the Wagner and Peters' models match, we can be reasonably confident that the Wagner unsteady aerodynamic model is also implemented correctly.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Time domain simulations may also be used in order to determine a system's stability.  To perform time domain simulations, an object representing the ordinary differential equations corresponding to the model may be generated using the get_ode function and then solved using the DifferentialEquations package.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using DifferentialEquations\n\n# models\naerodynamic_model = Peters{6}()\nstructural_model = TypicalSection()\ncoupled_model = couple_models(aerodynamic_model, structural_model)\n\n# non-dimensional parameters\na = -1/5 # reference point normalized location\ne = -1/10 # center of mass normalized location\nμ = 20 # = m/(ρ*pi*b^2) (mass ratio)\nr2 = 6/25 # = Iθ/(m*b^2) (radius of gyration about P)\nσ = 2/5 # = ωh/ωθ (natural frequency ratio)\nxθ = e - a\na0 = 2*pi # lift curve slope\nα0 = 0 # zero lift angle\ncd0 = 0\ncm0 = 0\nV = 1.0 # = U/(b*ωθ) (reduced velocity)\n\n# chosen dimensional parameters\nb = 1\nρ = 1\nωθ = 1\n\n# derived dimensional parameters\nm = μ*ρ*pi*b^2\nSθ = m*xθ*b\nIθ = r2*m*b^2\nωh = σ*ωθ\nkh = m*ωh^2\nkθ = Iθ*ωθ^2\nU = V*b*ωθ\n\n# parameters\np_aero = [a, b, a0, α0, cd0, cm0]\np_stru = [kh, kθ, m, Sθ, Iθ]\np_additional = [U, ρ]\np = vcat(p_aero, p_stru, p_additional)\n\n# initial states\nu0_aero = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\nu0_stru = [1.0, 0.0, 0.0, 0.0] # non-zero plunge degree of freedom\nx0 = vcat(u0_aero, u0_stru)\n\n# simulate from 0 to 10 seconds\ntspan = (0.0, 100.0)\n\n# construct ODE function\nf = get_ode(coupled_model)\n\n# construct ODE problem\nprob = DifferentialEquations.ODEProblem(f, x0, tspan, p)\n\n# solve ODE\nsol = DifferentialEquations.solve(prob)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can then plot the solution using DifferentialEquations' built-in interface with the Plots package.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\nplot(sol,\n    vars = [7,8,9,10],\n    xlabel = \"t\",\n    ylabel = permutedims([\n        \"\\$h\\$\",\n        \"\\$\\\\theta\\$\",\n        \"\\$\\\\dot{h}\\$\",\n        \"\\$\\\\dot{\\\\theta}\\$\",\n        ]),\n    label = \"\",\n    layout = (4, 1),\n    size = (600,1200)\n    )\n\nsavefig(\"typical-section-solution.svg\") #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also visualize and/or create animations of the solution geometry with the help of custom plot recipes.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Plot Recipes:\n# - plot(model, dx, x, p, t)\n# - plot(model, sol) # plots the solution geometry at index `sol.tslocation`\n# - plot(model, sol, t) # plots the solution geometry at time `t`\n\n# create animation\nanim = @animate for t in range(tspan[1], tspan[2], length=200)\n    plot(coupled_model, sol, t)\nend\n\n# save animation\ngif(anim, \"typical-section-simulation.gif\")\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Visualizing the solution geometry is especially helpful for identifying mode shapes.  For example, we can visualize the mode shape of the flutter mode for this system.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Plot Recipes:\n# - plot(model, dx, x, p, t)\n# - plot(model, sol) # plots the solution geometry at index `sol.tslocation`\n# - plot(model, sol, t) # plots the solution geometry at time `t`\n\n# create animation\nanim = @animate for t in range(tspan[1], tspan[2], length=200)\n    plot(coupled_model, sol, t)\nend\n\n# save animation\ngif(anim, \"typical-section-flutter-mode.gif\")\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Aeroelastic-Analysis-of-the-Goland-Wing","page":"Examples","title":"Aeroelastic Analysis of the Goland Wing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we demonstrate how to perform a three-dimensional aeroelastic analysis using the Goland wing, a low-aspect ratio prismatic metallic wing, which has been extensively used for validation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Goland wing is a cantilevered wing with a 20 ft span and 6 ft chord.  Its airfoil consists of a 4% thick parabolic arc.  There are two configurations for this wing, one with a tip store and one without.  The configuration we consider in this example is the configuration without a tip store.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The deflections of Goland wing are relatively small, so linear structural models are sufficient for modeling the wing's structure.  However, to demonstrate the capabilities of this package, we will use a nonlinear geometrically exact beam theory model.  ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the aerodynamics, we use a lifting line model which is capable of using a variety of 2D models to model section lift and moment coefficients.  While this type of aerodynamic model is inappropriate for this wing due to the wing's low aspect ratio, we use it so that we can obtain a better comparison between our results and the results of other aeroelastic analyses of the Goland wing performed with lifting line aerodynamics.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AerostructuralDynamics, GXBeam, DifferentialEquations, LinearAlgebra\n\n# discretization\nN = 8 # number of elements\n\n# geometric properties\nspan = 6.096 # m (20 ft span)\nchord = 1.8288 # m (6 ft chord)\n\n# structural section properties\nxea = 0.33*chord # m (elastic axis, from leading edge)\nEIcc = 9.77e6 # N*m^2 (flat bending rigidity)\nGJ = 0.99e6 # N*m^2 (torsional rigidity)\nμ = 35.71 # kg/m (mass per unit length)\nxcm = 0.43*chord # m (center of mass, from leading edge)\ni11 = 8.64 # kg*m (moment of inertia about elastic axis)\ni22 = 0.1*i11 # moment of inertia about beam y-axis\ni33 = 0.9*i11 # moment of inertia about beam z-axis\n\n# freestream properties\nVinf = vcat(1, 5:5:200) # m/s (velocity)\nα = 0 # angle of attack\n\n# aerodynamic section properties\nxref = xea/chord # normalized reference location (relative to leading edge)\na = xref - 0.5 # normalized reference location (relative to semi-chord)\nb = chord / 2 # m (semi-chord)\nρ = 1.02 # kg/m^3 (air density)\na0 = 0.85*(2*pi) # lift slope (for each section)\nα0 = 0 # zero lift angle of attack (for each section)\n\n# define geometry\nxpt = range(0, 0, length=N+1) # point x-coordinates (in body frame)\nypt = range(0, span, length=N+1) # point y-coordinates (in body frame)\nzpt = range(0, 0, length=N+1) # point z-coordinates (in body frame)\npoints = [[xpt[i],ypt[i],zpt[i]] for i = 1:N+1]\nstart = 1:N # starting point of each beam element\nstop = 2:N+1 # ending point of each beam element\nframes = fill([0 1 0; 1 0 0; 0 0 -1], N) # local to body frame transformation\ncompliance = fill(Diagonal([0, 0, 0, 1/GJ, 1/EIcc, 0]), N) # compliance matrix\nxm2 = xea - xcm\nmass = fill([\n    μ 0 0 0 0 -μ*xm2;\n    0 μ 0 0 0 0;\n    0 0 μ μ*xm2 0 0;\n    0 0 μ*xm2 i11 0 0;\n    0 0 0 0 i22 0;\n    -μ*xm2 0 0 0 0 i33], N) # mass matrix\nassembly = GXBeam.Assembly(points, start, stop; frames, compliance, mass)\n\nprescribed = Dict(\n    # fixed left edge\n    1 => GXBeam.PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n        theta_z=0),\n)\n\n# prescribed point conditions\npoint_conditions = zeros(6, length(assembly.points))\n\n# additional distributed loads\nelement_loads = zeros(6, length(assembly.elements))\n\n# construct aerodynamic model\naerodynamic_model = LiftingLine{N}(Peters{6}())\n\n# construct structural model\nstructural_model = GEBT(assembly, prescribed)\n\n# define coupled model\nmodel = couple_models(aerodynamic_model, structural_model)\n\n# construct ODE function\nf = get_ode(model)\n\n# current time\nt = 0.0\n\n# eigenvalue/eigenvector storage\nnev = 12*N\nλ = zeros(ComplexF64, nev, length(Vinf))\nUλ = zeros(ComplexF64, nev, number_of_states(model), length(Vinf))\nVλ = zeros(ComplexF64, number_of_states(model), nev, length(Vinf))\n\n# initial guess for state variables\nx0 = zeros(number_of_states(model))\n\n# loop through each velocity\nfor i = 1:length(Vinf)\n\n    println(Vinf[i])\n\n    # set parameters\n    p_aero = get_parameters(aerodynamic_model; section_parameters =\n        fill((a = a, b = b, a0 = a0, alpha0 = α0), N))\n\n    p_stru = get_parameters(structural_model; assembly = assembly)\n\n    p_additional = get_additional_parameters(model;\n        rho = ρ,\n        point_conditions = point_conditions,\n        element_loads = element_loads,\n        x = Vinf[i],\n        v = 0,\n        w = 0,\n        p = 0,\n        q = 0,\n        r = 0,\n        )\n\n    p = vcat(p_aero, p_stru, p_additional)\n\n    # find state variables corresponding to steady state operating conditions\n    sol = solve(SteadyStateProblem(f, x0, p), SSRootfind())\n\n    # use state variables from steady state operating conditions\n    x = sol.x\n\n    # calculate inputs corresponding to steady state operating conditions\n    y = get_coupling_inputs(model, x, p, t)\n\n    # perform linear stability analysis\n    λi, Uλi, Vλi = get_eigen(model, x, y, p, t; nev)\n\n    # correlate eigenvalues\n    if i > 1\n        # previous left eigenvector matrix\n        Uλpi = Uλ[:,:,i-1]\n\n        # current mass matrix\n        Mi = get_mass_matrix(model, x, y, p, t)\n\n        # use correlation matrix to correlate eigenmodes\n        perm, corruption = AerostructuralDynamics.correlate_eigenmodes(Uλpi, Mi, Vλi)\n\n        # re-arrange eigenmodes\n        λi = λi[perm]\n        Uλi = Uλi[perm,:]\n        Vλi = Vλi[:,perm]\n    end\n\n    # save eigenvalues/eigenvectors\n    λ[:,i] = λi\n    Uλ[:,:,i] = Uλi\n    Vλ[:,:,i] = Vλi\n\n    # update initial guess for the state variables\n    x0 .= x\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To identify the flutter speed and frequency, we can plot the results.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\nsp1 = plot(\n    xlim = (0, 200),\n    xtick = 0:40:200,\n    xlabel = \"Velocity (m/s)\",\n    ylim = (0, 800),\n    ytick = 0:100:800,\n    ylabel = \"Frequency (rad/s)\",\n    framestyle = :zerolines,\n    titlefontsize = 14,\n    guidefontsize = 14,\n    legendfontsize = 11,\n    tickfontsize = 11,\n    legend = :topright,\n    foreground_color_legend = nothing,\n    background_color_legend = nothing,\n    minorgrid=true)\n\nsp2 = plot(\n    xlim = (0, 200),\n    xtick = 0:40:200,\n    xlabel = \"Velocity (m/s)\",\n    ylim = (-80, 20),\n    ytick = -80:20:20,\n    ylabel = \"Damping (1/s)\",\n    framestyle = :zerolines,\n    titlefontsize = 14,\n    guidefontsize = 14,\n    legendfontsize = 11,\n    tickfontsize = 11,\n    legend = :topright,\n    foreground_color_legend = nothing,\n    background_color_legend = nothing,\n    minorgrid=true)\n\nfor i = 1:size(λ, 1)\n\n    Vi = Vinf[:]\n    λi = λ[i,:]\n\n    if any(-80 .<= real.(λi) .<= 20)\n        plot!(sp1, Vi, imag.(λi),\n            label = \"\",\n            color = i,\n            markersize = 3,\n            markerstrokewidth = 0,\n            )\n    end\n\nend\n\nfor i = 1:size(λ, 1)\n\n    Vi = Vinf[:]\n    λi = λ[i,:]\n\n    if any(-80 .<= real.(λi) .<= 20)\n        plot!(sp2, Vi,\n            real.(λi),\n            label = \"\",\n            color = i,\n            markersize = 3,\n            markerstrokewidth = 0,\n            )\n    end\nend\n\np1 = plot(sp1, sp2, layout = (2, 1), size = (600, 800), show=true)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As predicted by this analysis, the flutter speed is 140 m/s and the flutter frequency is 69.7 rad/s.  These results are nearly identical to results by Palacios and Epureanu in \"An Intrinsic Description of the Nonlinear Aeroelasticity of Very Flexible Wings\" for a similar aeroelastic model.  We can therefore be reasonably confident that the models used for this example are implemented correctly.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using DifferentialEquations\n\nVinf = 100.0\n\nx0 = zeros(number_of_states(model))\n\n# set parameters\np_aero = get_parameters(aerodynamic_model; section_parameters =\n    fill((a = a, b = b, a0 = a0, alpha0 = α0), N))\n\np_stru = get_parameters(structural_model; assembly = assembly)\n\np_additional = get_additional_parameters(model;\n    rho = ρ,\n    point_conditions = point_conditions,\n    element_loads = element_loads,\n    x = 100.0,\n    v = 0,\n    w = 0,\n    p = 0,\n    q = 0,\n    r = 0,\n    )\n\np = vcat(p_aero, p_stru, p_additional)\n\n# update initial state variables with steady state solution\nx0 .= solve(SteadyStateProblem(f, x0, p), SSRootfind())\n\n# simulate from 0 to 10 seconds\ntspan = (0.0, 10.0)\n\n# construct ODE function\nf = get_ode(model)\n\n# construct ODE problem\nprob = DifferentialEquations.ODEProblem(f, x0, tspan, p)\n\n# solve ODE\nsol = DifferentialEquations.solve(prob)\n\nnothing #hide","category":"page"},{"location":"examples/#Aeroelastic-Analysis-of-a-Highly-Flexible-Cantilever-Wing","page":"Examples","title":"Aeroelastic Analysis of a Highly Flexible Cantilever Wing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we demonstrate how to perform a three-dimensional aeroelastic analysis using a highly flexible cantilever wing.  ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The wing we are considering in this example was created by modifying Daedalus aircraft data and is therefore representative of a high-altitude long-endurance wing.  It has a 16 meter span (from root to tip) and a 1 meter chord.  To model the wing's aerodynamics, we will use a lifting line model.  To model the wing's structure, we will use a geometrically exact beam theory model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AerostructuralDynamics, GXBeam, DifferentialEquations, LinearAlgebra\n\n# discretization\nN = 1 # number of elements\n\n# geometric properties\nspan = 16 # m\nchord = 1 # m\n\n# structural section properties\nGJ = 1e4 # N*m^2 (torsional rigidity)\nEIcc = 2e4 # N*m^2 (flat bending rigidity)\nEInn = 4e6 # N*m^2 (chord bending rigidity)\nμ = 0.75 # kg/m (mass per unit length)\ni11 = 0.1 # kg*m (moment of inertia about elastic axis)\ni22 = 0.1*i11 # moment of inertia about beam y-axis\ni33 = 0.9*i11 # moment of inertia about beam z-axis\n\n# freestream properties\nVinf = vcat(0.1, 1:35) # m/s (velocity)\nα = 2*pi/180 # angle of attack\n\n# aerodynamic section properties\na = 0.0 # normalized reference location (relative to semi-chord)\nb = chord / 2 # m (semi-chord)\nρ = 0.088 # kg/m^3 (air density)\na0 = 2*pi # lift slope (for each section)\nα0 = 0 # zero lift angle of attack (for each section)\n\n# define geometry\nxpt = range(0, 0, length=N+1) # point x-coordinates (in body frame)\nypt = range(0, span, length=N+1) # point y-coordinates (in body frame)\nzpt = range(0, 0, length=N+1) # point z-coordinates (in body frame)\npoints = [[xpt[i],ypt[i],zpt[i]] for i = 1:N+1]\nstart = 1:N # starting point of each beam element\nstop = 2:N+1 # ending point of each beam element\nframes = fill([0 1 0; 1 0 0; 0 0 -1], N) # local to body frame transformation\ncompliance = fill(Diagonal([0, 0, 0, 1/GJ, 1/EIcc, 1/EInn]), N) # compliance matrix\nmass = fill(Diagonal([μ, μ, μ, i11, i22, i33]), N)\nassembly = GXBeam.Assembly(points, start, stop; frames, compliance, mass)\n\nprescribed = Dict(\n    # fixed left edge\n    1 => GXBeam.PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n        theta_z=0),\n)\n\n# prescribed point conditions\npoint_conditions = zeros(6, length(assembly.points))\n\n# additional distributed loads\nelement_loads = zeros(6, length(assembly.elements))\n\n# construct aerodynamic model\naerodynamic_model = LiftingLine{N}(Peters{6}())\n\n# construct structural model\nstructural_model = GEBT(assembly, prescribed)\n\n# define coupled model\nmodel = couple_models(aerodynamic_model, structural_model)\n\n# construct ODE function\nf = get_ode(model)\n\n# current time\nt = 0.0\n\n# eigenvalue storage\nλ = zeros(ComplexF64, number_of_states(model), length(Vinf))\n\n# initial guess for state variables\nx0 = zeros(number_of_states(model))\n\n# loop through each velocity\nfor i = 1:length(Vinf)\n\n    # previous left eigenvector matrix\n    global Uλpi\n\n    # set parameters\n    p_aero = get_parameters(aerodynamic_model; section_parameters =\n        fill((a = a, b = b, a0 = a0, alpha0 = α0), N))\n\n    p_stru = get_parameters(structural_model; assembly = assembly)\n\n    p_additional = get_additional_parameters(model;\n        rho = ρ,\n        point_conditions = point_conditions,\n        element_loads = element_loads,\n        x = Vinf[i]*cos(α),\n        v = 0,\n        w = -Vinf[i]*sin(α),\n        p = 0,\n        q = 0,\n        r = 0,\n        )\n\n    p = vcat(p_aero, p_stru, p_additional)\n\n    # find state variables corresponding to steady state operating conditions\n    sol = solve(SteadyStateProblem(f, x0, p), SSRootfind())\n\n    # use state variables from steady state operating conditions\n    x = sol.x\n\n    # calculate inputs corresponding to steady state operating conditions\n    y = get_coupling_inputs(model, x, p, t)\n\n    # perform linear stability analysis\n    λi, Uλi, Vλi = get_eigen(model, x, y, p, t; nev = number_of_states(model))\n\n    # correlate eigenvalues\n    if i > 1\n        # calculate mass matrix\n        Mi = get_mass_matrix(model, x, y, p, t)\n\n        # use correlation matrix to correlate eigenmodes\n        perm, corruption = AerostructuralDynamics.correlate_eigenmodes(Uλpi, Mi, Vλi)\n\n        # re-arrange eigenmodes\n        λi = λi[perm]\n        Uλi = Uλi[perm,:]\n        Vλi = Vλi[:,perm]\n    end\n\n    # save eigenvalues\n    λ[:,i] = λi\n\n    # save previous left eigenvector matrix\n    Uλpi = Uλi\n\n    # update initial guess for the state variables\n    x0 .= x\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We now plot the results predicted using each aerodynamic model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\ndefault(\n    titlefontsize = 14,\n    legendfontsize = 11,\n    guidefontsize = 14,\n    tickfontsize = 11,\n    foreground_color_legend = nothing,\n    background_color_legend = nothing,\n    minorgrid=true,\n    framestyle = :zerolines)\n\nsp1 = plot(\n    xlim = (0, 35),\n    xtick = 0:5:35,\n    xlabel = \"Velocity (m/s)\",\n    ylim = (0, 350),\n    ytick = 0:50:350,\n    ylabel = \"Frequency (rad/s)\",\n    legend = :topright\n    )\n\nsp2 = plot(\n    xlim = (0, 35),\n    xtick = 0:5:35,\n    xlabel = \"Velocity (m/s)\",\n    ylim = (-12, 8),\n    ytick = -12:4:8,\n    ylabel = \"Damping (1/s)\",\n    legend = :topleft\n    )\n\nfor i = 1:size(λ, 1)\n\n    Vi = Vinf[:]\n    λi = λ[i,:]\n\n    if any(abs.(λi) .< 1e4)\n        plot!(sp1, Vi, imag.(λi),\n            label = \"\",\n            color = i,\n            markersize = 3,\n            markerstrokewidth = 0,\n            )\n    end\n\nend\n\nfor i = 1:size(λ, 1)\n\n    Vi = Vinf[:]\n    λi = λ[i,:]\n\n    if any(abs.(λi) .< 1e4)\n        plot!(sp2, Vi,\n            real.(λi)./abs.(λi)*100,\n            label = \"\",\n            color = i,\n            markersize = 3,\n            markerstrokewidth = 0,\n            )\n    end\nend\n\np1 = plot(sp1, sp2, layout = (2, 1), size = (600, 800), show=true)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As predicted by this analysis, the flutter speed is 140 m/s and the flutter frequency is 69.7 rad/s.  These results are nearly identical to results by Palacios and Epureanu in \"An Intrinsic Description of the Nonlinear Aeroelasticity of Very Flexible Wings\" for a similar aeroelastic model.  We can therefore be reasonably confident that the models used for this example are implemented correctly.","category":"page"},{"location":"examples/#Aeroelastic-Analysis-of-a-Blended-Wing-Body-Aircraft","page":"Examples","title":"Aeroelastic Analysis of a Blended-Wing-Body Aircraft","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we demonstrate how to perform a three-dimensional aeroelastic analysis using geometrically exact beam theory in combination with a rigid body dynamics model and various aerodynamic models.  ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AerostructuralDynamics, GXBeam, NLsolve, LinearAlgebra\n\n# discretization\nNB = 6 # number of elements on body\nNW = 12 # number of elements on wing\nN = NB + NW # number of elements on blended wing body aircraft\n\n# wing geometry\nchord = [1.39, 0.55, 0.55] # m (chord lengths in -x-direction)\nybreak = [0.0, 0.89, 3.25] # m (span break locations in y-direction)\nsweep = 30 * pi/180 # leading edge sweep\n\n# stiffness properties\nEA = [1.69e8, 1.55e8] # N (extension stiffness)\nGJ = [2.25e6, 1.10e4] # N*m^2 (torsion stiffness)\nEIcc = [7.5e5, 1.14e4] # N*m^2 (out-of-plane bending stiffness)\nEInn = [3.5e7, 1.3e5] # N*m^2 (in-plane bending stiffness)\n\n# inertial properties\nμ = [50.0, 6.2] # kg/m (mass per unit length)\ni11 = [4.5, 5.08e-3] # kg*m (rotational inertia per unit length)\ni22 = [0.7, 5.0e-4] # kg*m (flat bending inertia per unit length)\ni33 = [22, 4.63e-3] # kg*m (edge bending inertia per unit length)\n\n# axis locations\nxref = [0.6438, 0.4560, 0.4560] .* chord # reference axis location (from leading edge)\nxcm = [0.6438, 0.4560, 0.4560] .* chord # center of gravity (from leading edge)\n\n# body definition\nxpt1 = range(0 + xref[1], ybreak[1]*tan(sweep) + xref[2]; length=NB+1)\nypt1 = range(0, ybreak[1]; length=NB+1)\nzpt1 = range(0, 0; length=NB+1)\npoints1 = [[xpt1[i],ypt1[i],zpt1[i]] for i = 1:NB+1]\nframes1 = fill( , NB)\ncompliance1 = fill(Diagonal([1/EA, 0, 0, 1/GJ, 1/EIcc, 1/EInn]), NB)\nmass1 = fill(Diagonal([μ[1], μ[1], μ[1], i11[1], i22[1], i33[1]]), NB)\na1 = linterp(xref[1]/chord[1] - 0.5, xref[2]/chord[2] - 0.5, length=NB)\nb1 = linterp(chord[1]/2, chord[2]/2, length=NB) # m (semi-chord)\na01 = fill(2*pi, NB) # lift slope (for each section)\nα01 = fill(0.0, NB) # zero lift angle of attack (for each section)\n\n# wing definition\nxpt2 = range(ybreak[1]*tan(sweep) + xref[2], ybreak[2]*tan(sweep) + xref[3];\n    length=NW+1)\nypt2 = range(ybreak[1], ybreak[2]; length=NW+1)\nzpt2 = range(0, 0; length=NW+1)\npoints2 = [[xpt2[i],ypt2[i],zpt2[i]] for i = 1:NW+1]\nframes2 = fill( , NW)\ncompliance2 = fill(Diagonal([1/EA[2], 0, 0, 1/GJ[2], 1/EIcc[2], 1/EInn[2]]), NW)\nmass2 = fill(Diagonal([μ[2], μ[2], μ[2], i11[2], i22[2], i33[2]]), NW)\na2 = linterp(xref[2]/chord[2] - 0.5, xref[3]/chord[3] - 0.5; length = NW)\nb2 = linterp(chord[2]/2, chord[3]/2; length = NW) # m (semi-chord)\na02 = fill(2*pi, NW) # lift slope (for each section)\nα02 = fill(0.0, NW) # zero lift angle of attack (for each section)\n\n# define beam assembly\npoints = vcat(points1, points2[2:end])\nframes = vcat(frames1, frames2)\nstart = 1:N # starting point of each beam element\nstop = 2:N+1 # ending point of each beam element\nassembly = GXBeam.Assembly(points, start, stop; frames, compliance, mass)\n\n# define aerodynamic section properties\na = vcat(a1, a2)\nb = vcat(b1, b2)\na0 = vcat(a01, a02)\nα0 = vcat(α01, α02)\nρ = 1.02 # kg/m^3 (air density)\n\n# boundary condition initialization\nprescribed = Dict(\n    # fixed left edge\n    1 => GXBeam.PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0,\n        theta_z=0),\n)\n\n# construct aerodynamic model\naerodynamic_model = LiftingLine{N}(Peters{6}())\n\n# construct structural model\nstructural_model = GEBT(assembly, prescribed)\n\n# rigid body dynamics model\ndynamics_model = RigidBody()\n\n# define simulation models\nmodel = couple_models(aerodynamic_model, structural_model, dynamics_model)\n\n# eigenvalue storage\nλ = zeros(ComplexF64, number_of_states(model), length(Vinf))\n\nx0 = zeros(number_of_states(model))\n\n# loop through each velocity\nfor i = 1:length(Vinf)\n\n    println(\"Vinf: \", Vinf[i])\n\n    # set state variables, parameters, and current time\n    p_aero = vcat([(a[i], b[i], a0[i], α0[i]) for i = 1:N]...)\n    p_stru = set_parameters(structural_model, assembly)\n    p_additional = vcat(-Vinf[i]*cos(α), 0, -Vinf[i]*sin(α), ρ,\n        set_inputs(structural_model, assembly; prescribed=prescribed))\n    p = vcat(p_aero, p_stru, p_additional)\n    t = 0\n\n    # find state variables corresponding to steady state operating conditions\n    fresid = x -> get_rates(model, x, get_coupling_inputs(model, x, p, t), p, t)\n    sol = nlsolve(fresid, x0)\n    x = sol.zero\n\n    # calculate the inputs corresponding to steady state operating conditions\n    y = get_coupling_inputs(model, x, p, t)\n\n    # calculate the mass matrix corresponding to steady state operating conditions\n    M = get_mass_matrix(model, x, y, p, t)\n\n    # calculate the jacobian corresponding to steady state operating conditions\n    J = get_state_jacobian(model, x, y, p, t)\n\n    # solve the generalized eigenvalue problem\n    λ[:,i] = sort(eigvals(J, M), by=LinearAlgebra.eigsortby)\n\n    # update initial guess for the state variables\n    x0 .= x\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We now plot the results predicted using each aerodynamic model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\ndefault(\n    titlefontsize = 14,\n    legendfontsize = 11,\n    guidefontsize = 14,\n    tickfontsize = 11,\n    foreground_color_legend = nothing,\n    background_color_legend = nothing,\n    minorgrid=true,\n    framestyle = :zerolines)\n\nsp1 = plot(\n    xlim = (0, 200),\n    xtick = 0:40:200,\n    xlabel = \"Velocity (m/s)\",\n    ylim = (0, 1000),\n    ytick = 0:100:1000,\n    ylabel = \"Frequency (rad/s)\",\n    legend = :topright\n    )\n\nsp2 = plot(\n    xlim = (0, 200),\n    xtick = 0:40:200,\n    xlabel = \"Velocity (m/s)\",\n    ylim = (-80, 20),\n    ytick = -80:20:20,\n    ylabel = \"Damping (1/s)\",\n    legend = :topleft\n    )\n\nfor i = 1:size(λ, 1)\n\n    Vi = Vinf[:]\n    λi = λ[i,:]\n\n    scatter!(sp1, Vi, imag.(λi),\n        label = \"\",\n        color = 1,\n        markersize = 3,\n        markerstrokewidth = 0,\n        )\nend\n\nfor i = 1:size(λ, 1)\n\n    Vi = Vinf[:]\n    λi = λ[i,:]\n\n    scatter!(sp2, Vi,\n        real.(λi),\n        label = \"\",\n        color = 1,\n        markersize = 3,\n        markerstrokewidth = 0,\n        )\nend\n\np1 = plot(sp1, sp2, layout = (2, 1), size = (600, 800), show=true)\n","category":"page"},{"location":"couplings/steady-section/#[Steady](@ref)-[TypicalSection](@ref)","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady + TypicalSection","text":"","category":"section"},{"location":"couplings/steady-section/#Theory","page":"Steady Thin Airfoil Theory + Typical Section","title":"Theory","text":"","category":"section"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"This model is defined by coupling steady thin airfoil theory aerodynamics","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"with the typical section model.  ","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"By making use of a small angle assumption, the freestream velocity components are defined as","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"u approx U_infty \nv approx U_infty theta \nomega approx 0","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"where U_infty is the freestream velocity magnitude, theta is the pitch angle, u is the chordwise freestream velocity, v is the normal freestream velocity, and omega is the freestream angular velocity. A small angle assumption is also used to define the lift about the reference location as","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"mathcalL approx mathcalN","category":"page"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"where mathcalN is the normal force per unit span at the reference location.","category":"page"},{"location":"couplings/steady-section/#Constructors","page":"Steady Thin Airfoil Theory + Typical Section","title":"Constructors","text":"","category":"section"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"couple_models(aero::Steady, stru::TypicalSection)","category":"page"},{"location":"couplings/steady-section/#AerostructuralDynamics.couple_models-Tuple{Steady, TypicalSection}","page":"Steady Thin Airfoil Theory + Typical Section","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::Steady, stru::TypicalSection)\n\nCreate an aerostructural model using a steady aerodynamics model and a two-degree of freedom typical section model.  This model introduces the freestream velocity U and air density rho as additional parameters.\n\n\n\n\n\n","category":"method"},{"location":"couplings/steady-section/#Example-Usage","page":"Steady Thin Airfoil Theory + Typical Section","title":"Example Usage","text":"","category":"section"},{"location":"couplings/steady-section/","page":"Steady Thin Airfoil Theory + Typical Section","title":"Steady Thin Airfoil Theory + Typical Section","text":"Aeroelastic Analysis of a Typical Section","category":"page"},{"location":"couplings/wagner-section/#[Wagner](@ref)-[TypicalSection](@ref)","page":"Wagner's Function + Typical Section","title":"Wagner + TypicalSection","text":"","category":"section"},{"location":"couplings/wagner-section/#Theory","page":"Wagner's Function + Typical Section","title":"Theory","text":"","category":"section"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"This model is defined by coupling Wagner's function unsteady aerodynamics","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"with the typical section model.  ","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"(Image: )","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"To facilitate this coupling, the freestream velocity components u and v are assumed to be aligned with the undeflected chordwise and normal directions, respectively, so that","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"u approx U_infty \nv approx doth \nomega approx dottheta","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"where U_infty is the freestream velocity magnitude, theta is pitch, and h is plunge. To capture the effect of twist on the circulatory lift (since it is no longer implicitly modeled by the fracvu quantity) twist is added to the effective angle of attack from the Wagner's function model so that the effective angle of attack is now given by","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"alpha_texteff = left(theta - fracvu + fracbu left( frac12 - a right) omega - alpha_0 right) phi(0) + fraclambda_1u + fraclambda_2u","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"The original expression for the effective angle of attack may be used by defining the new variable barv = u theta + v such that","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"alpha_texteff = left(-fracbarvu + fracbu left( frac12 - a right) omega - alpha_0 right) phi(0) + fraclambda_1u + fraclambda_2u","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"A small angle assumption is also used to define the lift about the reference location as","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"mathcalL approx mathcalN","category":"page"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"where mathcalN is the normal force per unit span at the reference location.","category":"page"},{"location":"couplings/wagner-section/#Constructors","page":"Wagner's Function + Typical Section","title":"Constructors","text":"","category":"section"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"couple_models(aero::Wagner, stru::TypicalSection)","category":"page"},{"location":"couplings/wagner-section/#AerostructuralDynamics.couple_models-Tuple{Wagner, TypicalSection}","page":"Wagner's Function + Typical Section","title":"AerostructuralDynamics.couple_models","text":"couple_models(aero::Wagner, stru::TypicalSection)\n\nCreate an aerostructural model using an unsteady aerodynamic model based on Wagner's function and a two-degree of freedom typical section model.  This model introduces the freestream velocity U_infty and air density rho_infty as additional parameters.\n\n\n\n\n\n","category":"method"},{"location":"couplings/wagner-section/#Example-Usage","page":"Wagner's Function + Typical Section","title":"Example Usage","text":"","category":"section"},{"location":"couplings/wagner-section/","page":"Wagner's Function + Typical Section","title":"Wagner's Function + Typical Section","text":"Aeroelastic Analysis of a Typical Section","category":"page"},{"location":"#AerostructuralDynamics","page":"Home","title":"AerostructuralDynamics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Aerostructural Dynamics Analysis and Simulation Framework","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author: Taylor McDonnell","category":"page"},{"location":"","page":"Home","title":"Home","text":"AerostructuralDynamics is an extensible multi-fidelity modeling and analysis framework which is designed to simulate the behavior of coupled and/or decoupled aerodynamic, structural, and/or rigid-body dynamics models.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Provides a framework for coupling multiple models together for analysis and/or simulation.\nDefines a variety of aerodynamic, structural, dynamics, control surface, and control system models\nAerodynamics Models:\nSteady and/or Quasi-Steady Thin Airfoil Theory (2D)\nWagner's Function (2D)\nPeters' Finite State (2D)\nLifting Line (3D)\nStructural Dynamics Models:\nTwo Degree of Freedom Typical Section (2D)\nGeometrically Exact Beam Theory (As implemented by GXBeam) (3D)\nDynamics Models:\nRigid Body (3D)\nControl Surface Models:\nSteady State Linear Flap (2D)\nLifting Line Flaps (3D)\nControl System Models:\nTrim (3D)\nInterfaces with DifferentialEquations\nVerified and/or validated against theoretical, computational, and/or experimental results (see the examples)\nMay be easily extended to include additional models and/or model couplings.  (See the developer guide, pull requests are welcome)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Enter the package manager by typing ] and then run the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://flow.byu.edu/AerostructuralDynamics.jl","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Getting Started section of the documentation.","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for AerostructuralDynamics.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"See the Models section of the manual for documentation covering the individual models.","category":"page"},{"location":"library/public/#Contents","page":"Public","title":"Contents","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"library/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"library/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"library/public/#Getting-Model-Properties","page":"Public","title":"Getting Model Properties","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following methods may be used to determine the properties of a model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"number_of_states\nnumber_of_inputs\nnumber_of_parameters","category":"page"},{"location":"library/public/#AerostructuralDynamics.number_of_states","page":"Public","title":"AerostructuralDynamics.number_of_states","text":"number_of_states(model)\n\nReturn the total number of state variables corresponding to the model or models.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.number_of_inputs","page":"Public","title":"AerostructuralDynamics.number_of_inputs","text":"number_of_inputs(model)\n\nReturn the total number of inputs corresponding to the model or models.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.number_of_parameters","page":"Public","title":"AerostructuralDynamics.number_of_parameters","text":"number_of_parameters(model)\n\nReturn the total number of parameters corresponding to the model or models.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Getting-Model-Indices","page":"Public","title":"Getting Model Indices","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following methods may be used to find the state, input, and parameter indices associated with each model in a coupled model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"state_indices\ninput_indices\nparameter_indices","category":"page"},{"location":"library/public/#AerostructuralDynamics.state_indices","page":"Public","title":"AerostructuralDynamics.state_indices","text":"state_indices(models)\n\nReturn the indices corresponding to the state variables for each model in models\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.input_indices","page":"Public","title":"AerostructuralDynamics.input_indices","text":"input_indices(models)\n\nReturn the indices corresponding to the input variables for each model in models\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.parameter_indices","page":"Public","title":"AerostructuralDynamics.parameter_indices","text":"parameter_indices(models)\n\nReturn the indices corresponding to the parameters for each model in models\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Getting-Model-Inputs","page":"Public","title":"Getting Model Inputs","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following methods may be used to calculate the value of the inputs for a coupled model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"get_coupling_inputs\nget_coupling_inputs!","category":"page"},{"location":"library/public/#AerostructuralDynamics.get_coupling_inputs","page":"Public","title":"AerostructuralDynamics.get_coupling_inputs","text":"get_coupling_inputs(models, dx, x, p, t)\n\nCalculate the inputs to the specified combination of models.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.get_coupling_inputs!","page":"Public","title":"AerostructuralDynamics.get_coupling_inputs!","text":"get_coupling_inputs!(y, models::NTuple{N,AbstractModel}, dx, x, p, t) where N\n\nIn-place version of get_coupling_inputs\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Getting-State-Rates","page":"Public","title":"Getting State Rates","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following methods may be used to calculate the value of the state rates for a model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"get_rates\nget_rates!","category":"page"},{"location":"library/public/#Getting-Mass-Matrices","page":"Public","title":"Getting Mass Matrices","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following methods may be used to calculate the mass matrix for a model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"get_mass_matrix\nget_mass_matrix!","category":"page"},{"location":"library/public/#Getting-Jacobians","page":"Public","title":"Getting Jacobians","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following methods may be used to calculate the jacobian of the state rates for a model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"get_state_jacobian\nget_state_jacobian!","category":"page"},{"location":"library/public/#AerostructuralDynamics.get_state_jacobian","page":"Public","title":"AerostructuralDynamics.get_state_jacobian","text":"get_state_jacobian(model)\nget_state_jacobian(model, p)\nget_state_jacobian(model, dx, x, y, p, t)\n\nCalculate the jacobian of the residual function for model with respect to the state variables\n\n\n\n\n\n","category":"function"},{"location":"library/public/#AerostructuralDynamics.get_state_jacobian!","page":"Public","title":"AerostructuralDynamics.get_state_jacobian!","text":"get_state_jacobian!(J, model)\nget_state_jacobian!(J, model, p)\nget_state_jacobian!(J, model, dx, x, y, p, t)\n\nIn-place version of get_state_jacobian\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Performing-a-Stability-Analysis","page":"Public","title":"Performing a Stability Analysis","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following method may be used to perform a stability analysis for a model.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"get_eigen","category":"page"},{"location":"library/public/#AerostructuralDynamics.get_eigen","page":"Public","title":"AerostructuralDynamics.get_eigen","text":"get_eigen(model::TM, x, p; kwargs...)\n\nReturn the eigenvalues, left eigenvector matrix, and right eigenvector matrix corresponding to the model for state variables x and parameters p.\n\nFor in-place models, the number of eigenvalues to compute may be specified using the nev keyword argument.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Interfacing-with-DifferentialEquations","page":"Public","title":"Interfacing with DifferentialEquations","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The following method may be used to construct a function for use with DifferentialEquations.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"get_ode","category":"page"},{"location":"library/public/#AerostructuralDynamics.get_ode","page":"Public","title":"AerostructuralDynamics.get_ode","text":"get_ode(model)\nget_ode(model, p)\n\nConstruct an ODEFunction corresponding to the specified model or models which may be solved using DifferentialEquations.\n\n\n\n\n\n","category":"function"}]
}
