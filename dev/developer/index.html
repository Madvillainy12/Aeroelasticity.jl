<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developer Guide · AerostructuralDynamics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AerostructuralDynamics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/">Getting Started</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Models</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Aerodynamic Models</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../aerodynamics/steady/">Steady Thin Airfoil Theory</a></li><li><a class="tocitem" href="../aerodynamics/quasisteady/">Quasi-Steady Thin Airfoil Theory</a></li><li><a class="tocitem" href="../aerodynamics/wagner/">Wagner&#39;s Function</a></li><li><a class="tocitem" href="../aerodynamics/peters/">Peters&#39; Finite State</a></li><li><a class="tocitem" href="../aerodynamics/liftingline/">Lifting Line</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Structural Models</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../structures/section/">Typical Section</a></li><li><a class="tocitem" href="../structures/rigidbody/">Rigid Body</a></li><li><a class="tocitem" href="../structures/gxbeam/">Geometrically Exact Beam Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Coupled Models</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../couplings/steady-section/">Steady Thin Airfoil Theory + Typical Section</a></li><li><a class="tocitem" href="../couplings/quasisteady-section/">Quasi-Steady Thin Airfoil Theory + Typical Section</a></li><li><a class="tocitem" href="../couplings/wagner-section/">Wagner&#39;s Function + Typical Section</a></li><li><a class="tocitem" href="../couplings/peters-section/">Peters&#39; Finite State + Typical Section</a></li><li><a class="tocitem" href="../couplings/liftingline-rigidbody/">Lifting Line + Rigid Body</a></li><li><a class="tocitem" href="../couplings/liftingline-gxbeam/">Lifting Line + Geometrically Exact Beam Theory</a></li><li><a class="tocitem" href="../couplings/liftingline-gxbeam-rigidbody/">Lifting Line + Geometrically Exact Beam Theory + Rigid Body</a></li></ul></li></ul></li><li><a class="tocitem" href="../interface/">Interface</a></li><li class="is-active"><a class="tocitem" href>Developer Guide</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-New-Model"><span>Creating a New Model</span></a></li><li><a class="tocitem" href="#Creating-a-New-Model-Coupling"><span>Creating a New Model Coupling</span></a></li><li><a class="tocitem" href="#Aeroelastic-Model"><span>Aeroelastic Model</span></a></li><li><a class="tocitem" href="#Model-Ordering"><span>Model Ordering</span></a></li><li><a class="tocitem" href="#Avoiding-Mass-Matrices"><span>Avoiding Mass Matrices</span></a></li><li><a class="tocitem" href="#"><span></span></a></li><li><a class="tocitem" href="#Typical-Section-Model"><span>Typical Section Model</span></a></li><li><a class="tocitem" href="#Performance-Overloads"><span>Performance Overloads</span></a></li><li><a class="tocitem" href="#Peters&#39;-Finite-State-Model"><span>Peters&#39; Finite State Model</span></a></li><li><a class="tocitem" href="#Aeroelastic-Model-2"><span>Aeroelastic Model</span></a></li><li><a class="tocitem" href="#Model-Ordering-2"><span>Model Ordering</span></a></li><li><a class="tocitem" href="#Avoiding-Mass-Matrices-2"><span>Avoiding Mass Matrices</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Developer Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Developer Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/AerostructuralDynamics.jl/blob/master/docs/src/developer.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Developer&#39;s-Guide"><a class="docs-heading-anchor" href="#Developer&#39;s-Guide">Developer&#39;s Guide</a><a id="Developer&#39;s-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Developer&#39;s-Guide" title="Permalink"></a></h1><p>In this guide, we describe how to create new models and/or couplings.</p><h2 id="Creating-a-New-Model"><a class="docs-heading-anchor" href="#Creating-a-New-Model">Creating a New Model</a><a id="Creating-a-New-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-New-Model" title="Permalink"></a></h2><p>In this section, we describe in detail how to construct a new model.  To illustrate this process, we also provide example code which could be used to re-implement the <a href="../structures/section/#AerostructuralDynamics.TypicalSection"><code>TypicalSection</code></a> model.</p><h3 id="Manipulating-a-Model&#39;s-Governing-Equations"><a class="docs-heading-anchor" href="#Manipulating-a-Model&#39;s-Governing-Equations">Manipulating a Model&#39;s Governing Equations</a><a id="Manipulating-a-Model&#39;s-Governing-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulating-a-Model&#39;s-Governing-Equations" title="Permalink"></a></h3><p>Before a model can be used with this package, its governing equations must be manipulated so that it satisfies the ordinary differential equation (or differential algebraic equation in mass matrix form)</p><p class="math-container">\[M(x,y,p,t)\dot{x} = f(x,y,p,t)\]</p><p>where <span>$M(x, y, p, t)$</span> is a function which defines the mass matrix corresponding to the differential equation, <span>$f(x, y, p, t)$</span> is a function which defines the mass matrix multiplied state rates, <span>$x$</span> is a vector of state variables, <span>$y$</span> is a vector of inputs, <span>$p$</span> is a vector of parameters, and <span>$t$</span> is the current time.  State variables are variables which have rate equations associated with them.  Inputs, or coupling variables, are variables  which may be defined in time using other models.  Parameters are variables which are user-specified and constant in time.</p><p>For example, the governing differential equations for the <a href="../structures/section/#AerostructuralDynamics.TypicalSection"><code>TypicalSection</code></a> model are typically expressed as the second order ordinary differential equation</p><p class="math-container">\[\begin{bmatrix} m &amp; S_\theta \\ S_\theta &amp; I_\theta \end{bmatrix}
\begin{Bmatrix} \ddot{h} \\ \ddot{\theta} \end{Bmatrix} +
\begin{bmatrix} k_h &amp; 0 \\ 0 &amp; k_h \end{bmatrix}
\begin{Bmatrix} h \\ \theta \end{Bmatrix} =
\begin{Bmatrix} -\mathcal{L} \\ \mathcal{M} \end{Bmatrix}\]</p><p>where <span>$k_h$</span> is the linear spring constant, <span>$k_\theta$</span> is the torsional spring constant, <span>$m$</span> is the mass per unit span, <span>$S_\theta$</span> is the structural imbalance, <span>$I_\theta$</span> is the mass moment of inertia, <span>$\mathcal{L}$</span> is the lift per unit span, and <span>$\mathcal{M}$</span> is the moment per unit span.  Expressed in the form expected by this package, the governing differential equation for the typical section model is</p><p class="math-container">\[M \dot{x} = K x + D y\]</p><p>where</p><p class="math-container">\[x = \begin{bmatrix} h &amp; \theta &amp; \dot{h} &amp; \dot{\theta} \end{bmatrix}^T \quad
y = \begin{bmatrix} \mathcal{L} &amp; \mathcal{M} \end{bmatrix}^T\]</p><p class="math-container">\[M =
\begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; m &amp; S_\theta \\
    0 &amp; 0 &amp; S_\theta &amp; I_P
\end{bmatrix}
\quad
K =
\begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
-k_h &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; -k_\theta &amp; 0 &amp; 0
\end{bmatrix}
\quad
D =
\begin{bmatrix}
0 &amp; 0 \\
0 &amp; 0 \\
-1 &amp; 0 \\
0 &amp; 1
\end{bmatrix}\]</p><p>A special type of model which trivially satisfies the form of the governing differential equations expected by this package is a model with no state variables and/or inputs.  These models are designated as being subtypes of abstract type <a href="../interface/#AerostructuralDynamics.NoStateModel"><code>NoStateModel</code></a> and are used solely to define the inputs of other models.  For example, the <a href="../aerodynamics/steady/#AerostructuralDynamics.Steady"><code>Steady</code></a> and <a href="../aerodynamics/quasisteady/#AerostructuralDynamics.QuasiSteady"><code>QuasiSteady</code></a> models may be used to calculate the inputs corresponding to the <a href="../structures/section/#AerostructuralDynamics.TypicalSection"><code>TypicalSection</code></a> model, but have no state variables of their own.</p><h3 id="Defining-a-Model&#39;s-Type"><a class="docs-heading-anchor" href="#Defining-a-Model&#39;s-Type">Defining a Model&#39;s Type</a><a id="Defining-a-Model&#39;s-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-Model&#39;s-Type" title="Permalink"></a></h3><p>Once the governing differential equations for a model has been manipulated into the expected format, and the state variables, inputs, and parameters for the model have been identified, the first step in defining a new model is to define a new type.  A docstring should also be provided along with the new type definition which defines the identities of the elements of the state, input, and parameter vectors for the model.  For example, the type definition for the <a href="../structures/section/#AerostructuralDynamics.TypicalSection"><code>TypicalSection</code></a> model is</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    TypicalSection &lt;: AbstractModel

Typical section structural model with state variables ``h, \\theta, \\dot{h},
\\dot{\\theta}``, inputs ``\\mathcal{L}, \\mathcal{M}``, and parameters ``k_h,
k_\\theta, m, S_\\theta, I_\\theta``
&quot;&quot;&quot;
struct TypicalSection &lt;: AbstractModel end</code></pre><h3 id="Defining-Model-Traits"><a class="docs-heading-anchor" href="#Defining-Model-Traits">Defining Model Traits</a><a id="Defining-Model-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Model-Traits" title="Permalink"></a></h3><p>The next step in defining a new model is to define the model&#39;s properties.  At a minimum, this requires defining new methods for the <a href="../interface/#AerostructuralDynamics.number_of_states"><code>number_of_states</code></a>, <a href="../interface/#AerostructuralDynamics.number_of_inputs"><code>number_of_inputs</code></a>, <a href="../interface/#AerostructuralDynamics.number_of_parameters"><code>number_of_parameters</code></a>, and <a href="@ref"><code>inplaceness</code></a> functions, though additional method definitions may be necessary.  For example, the <a href="../structures/section/#AerostructuralDynamics.TypicalSection"><code>TypicalSection</code></a> model&#39;s properties are defined in the following block of code.</p><pre><code class="language-julia hljs">number_of_states(::Type{TypicalSection}) = 4
number_of_inputs(::Type{TypicalSection}) = 2
number_of_parameters(::Type{TypicalSection}) = 5
inplaceness(::Type{TypicalSection}) = OutOfPlace()
mass_matrix_type(::Type{TypicalSection}) = Linear()
state_jacobian_type(::Type{TypicalSection}) = Linear()
input_jacobian_type(::Type{TypicalSection}) = Constant()</code></pre><p>The length of the model&#39;s state, input and parameter vectors is specified by defining new methods for the <a href="../interface/#AerostructuralDynamics.number_of_states"><code>number_of_states</code></a>, <a href="../interface/#AerostructuralDynamics.number_of_inputs"><code>number_of_inputs</code></a>, and <a href="../interface/#AerostructuralDynamics.number_of_parameters"><code>number_of_parameters</code></a> functions.  For out-of-place models, these methods must operate the model type so that the vector sizes are completely inferrable.  For in-place models, this restriction is loosened and these methods may operate on model instances instead.</p><p>Whether a model uses in-place or out-of-place function definitions is specified by defining a new method for the <a href="@ref"><code>inplaceness</code></a> function, which operates on the model type. For performance reasons, in-place functions are generally preferred.  The one exception is for models with small numbers of state variables, in which case the preferred approach is to use static arrays with out-of-place functions.</p><p>The properties of the model&#39;s mass matrix, state jacobian, and/or input jacobian are defined by defining new methods for the <a href="@ref"><code>mass_matrix_type</code></a>, <a href="@ref"><code>state_jacobian_type</code></a>, and/or <a href="@ref"><code>input_jacobian_type</code></a> functions, respectively.  By default, these properties assume their loosest possible definitions.</p><h3 id="Defining-Methods-for-Governing-Equations"><a class="docs-heading-anchor" href="#Defining-Methods-for-Governing-Equations">Defining Methods for Governing Equations</a><a id="Defining-Methods-for-Governing-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Methods-for-Governing-Equations" title="Permalink"></a></h3><p>Once the properties of a model have been defined, methods must be provided for the model which define its governing equations.  The right hand side of the governing structural differential equations is calculated using the <a href="../interface/#AerostructuralDynamics.get_rates"><code>get_rates</code></a> function for out-of-place models or the <a href="../interface/#AerostructuralDynamics.get_rates!"><code>get_rates!</code></a> function for in-place models.  For models with mass matrices, a new method must also be defined for the <a href="../interface/#AerostructuralDynamics.get_mass_matrix"><code>get_mass_matrix</code></a> function (or <a href="../interface/#AerostructuralDynamics.get_mass_matrix!"><code>get_mass_matrix!</code></a> function if the model&#39;s functions are in-place functions).  For constant mass matrices (<code>mass_matrix_type(typeof(model)) == Constant()</code>), this function should be defined without the <code>x</code>, <code>y</code>, <code>p</code>, and <code>t</code> arguments.  </p><p>For example, the governing equations for the <a href="../structures/section/#AerostructuralDynamics.TypicalSection"><code>TypicalSection</code></a> model may be defined using the following block of code</p><pre><code class="language-julia hljs">function get_rates(::TypicalSection, x, y, p, t)
    # extract state variables
    h, θ, hdot, θdot = x
    # extract inputs
    L, M = y
    # extract parameters
    kh, kθ, m, Sθ, Iθ = p
    # calculate state rates
    return SVector(hdot, θdot, -kh*h - L, -kθ*θ + M)
end

function get_mass_matrix(::MyTypicalSection, x, y, p, t)
    # extract structural parameters
    kh, kθ, m, Sθ, Iθ = p
    # calculate mass matrix
    return @SMatrix [1 0 0 0; 0 1 0 0; 0 0 m Sθ; 0 0 Sθ Iθ]
end</code></pre><h3 id="Defining-Methods-for-Jacobians"><a class="docs-heading-anchor" href="#Defining-Methods-for-Jacobians">Defining Methods for Jacobians</a><a id="Defining-Methods-for-Jacobians-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Methods-for-Jacobians" title="Permalink"></a></h3><p>Unless otherwise specified, the jacobian of the governing differential equations for a given model with respect to the state variables and/or inputs is calculated when necessary using forward automatic differentiation (enabled by the <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff</a> package).  While this approach for computing the jacobians is convenient and exact, alternative methods for computing jacobians may be more computationally efficient.  To manually define the jacobian of the right hand side of the governing equations with respect to the state variables, a new method for <a href="../interface/#AerostructuralDynamics.get_state_jacobian"><code>get_state_jacobian</code></a> (or <a href="../interface/#AerostructuralDynamics.get_state_jacobian!"><code>get_state_jacobian!</code></a> for in-place models) may be defined.  To manually define the jacobian of the right hand side of the governing equations with respect to the inputs, a new method for <a href="@ref"><code>get_input_jacobian</code></a> may be defined.  For example, for the <a href="../structures/section/#AerostructuralDynamics.TypicalSection"><code>TypicalSection</code></a> model, these jacobians may be defined analytically using the following block of code</p><pre><code class="language-julia hljs">function get_state_jacobian(::MyTypicalSection, q, r, p, t)
    # extract parameters
    a, b, kh, kθ, m, xθ, Ip = p
    # return jacobian
    return @SMatrix [0 0 1 0; 0 0 0 1; -kh 0 0 0; 0 -kθ 0 0]
end

get_input_jacobian(::MyTypicalSection) = @SMatrix [0 0; 0 0; -1 0; 0 1]</code></pre><p>Note that while there is no in-place version of the <a href="@ref"><code>get_input_jacobian</code></a> function it may be constructed as either a linear map (for large matrices) or static array (for small matrices) in order to avoid allocations.</p><h3 id="Defining-Methods-for-Unit-Testing"><a class="docs-heading-anchor" href="#Defining-Methods-for-Unit-Testing">Defining Methods for Unit Testing</a><a id="Defining-Methods-for-Unit-Testing-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Methods-for-Unit-Testing" title="Permalink"></a></h3><p>In order to test whether provided mass matrices are correct for a given model, a new method for <a href="@ref"><code>get_lhs()</code></a> (which defines the left hand side of the governing differential equations) must be provided.  Since this function is only used for testing, there is no in-place version of this function.  For the <a href="../structures/section/#AerostructuralDynamics.TypicalSection"><code>TypicalSection</code></a> model this function could be defined as follows</p><pre><code class="language-julia hljs">function get_lhs(::TypicalSection, dq, q, r, p, t)
    # extract structural parameters
    kh, kθ, m, Sθ, Iθ = p
    # extract state rates
    dh, dθ, dhdot, dθdot = dq
    # calculate mass matrix product
    return SVector(dh, dθ, m*dhdot + Sθ*dθdot, Sθ*dhdot + Iθ*dθdot)
end</code></pre><h2 id="Creating-a-New-Model-Coupling"><a class="docs-heading-anchor" href="#Creating-a-New-Model-Coupling">Creating a New Model Coupling</a><a id="Creating-a-New-Model-Coupling-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-New-Model-Coupling" title="Permalink"></a></h2><p>In this section, we describe in detail how to construct a new model by coupling multiple existing models together.  To illustrate this process, we also provide example code which could be used to re-implement the <a href="../aerodynamics/wagner/#AerostructuralDynamics.Wagner"><code>Wagner</code></a> + <a href="../structures/section/#AerostructuralDynamics.TypicalSection"><code>TypicalSection</code></a> model coupling.</p><h3 id="Coupled-Model-Theory"><a class="docs-heading-anchor" href="#Coupled-Model-Theory">Coupled Model Theory</a><a id="Coupled-Model-Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Coupled-Model-Theory" title="Permalink"></a></h3><p>Coupled models in this package are defined by concatenating the governing differential equations, state variables, inputs, and parameters of multiple independent models into a single monolithic system.  As a result, coupled models defined by this package have the same general form as independent models in this package, that is, they may be defined by the ordinary differential equation (or differential algebraic equation in mass matrix form)</p><p class="math-container">\[M(x,y,p,t)\dot{x} = f(x,y,p,t)\]</p><p>where <span>$M(x, y, p, t)$</span> is a function which defines the mass matrix corresponding to the coupled model&#39;s governing differential equation, <span>$f(x, y, p, t)$</span> is a function which defines the mass matrix multiplied state rates, <span>$x$</span> is a vector of states, <span>$y$</span> is a vector of inputs (coupling variables), <span>$p$</span> is a vector of parameters, and <span>$t$</span> is the current time.</p><p>We assume the inputs for coupled models may be expressed as a function of the coupled model&#39;s state variables and parameters, as well as the current time.  Denoting such a function as <code>g(x, p, t)</code>, the inputs may then be expressed as <span>$y = g(x, p, t)$</span>.  The governing differential equations for the coupled model then reduce to</p><p class="math-container">\[M(x, p, t)\dot{x} = f(x, p, t)\]</p><p>For example, the</p><p>This allows each model to influence other models through</p><p>If we now assume that the inputs to the coupled model may be defined as a function of the state variables and parameters of the coupled model, as well as the current time, then</p><p>We also assume the inputs for the coupled model may be expressed as a function of the coupled model&#39;s state variables and parameters, as well as the current time.  This assumption allows the state variables and parameters from each coupled model to influence the governing differential equations of the other coupled models through their input variables.</p><p>To model the interactions between models, we assume that the inputs to each component model may be defined as a function of the state variables, par</p><p>we assume that each model the interactions between models may be captured through each model&#39;s influence on the inputs corresponding to the governing equations of other models.</p><p>We also assume the inputs for the coupled model may be expressed as a function of the coupled model&#39;s state variables and parameters, as well as the current time.  This assumption allows the state variables and parameters from each coupled model to influence the governing differential equations of the other coupled models through their input variables.</p><p>We assume the inputs for the coupled model may be expressed</p><p>Each of the models which make up a coupled model influence other models through the other models inputs.  We</p><p>The inputs which correspond to each Each of the models which make up</p><p class="math-container">\[y = g(x, p, t) - M_y(x,p,t) \dot{x} =
\begin{Bmatrix}
g_\text{aero}(x, p, t) - M_{y,\text{aero}}(x,p,t) \dot{x} \\
g_\text{stru}(x, p, t) - M_{y,\text{stru}}(x,p,t) \dot{x}
\end{Bmatrix}\]</p><p>To model the interactions between models</p><p>Coupled models defined by this package also satisfy the ordinary differential equation (or differential algebraic equation in mass matrix form)</p><p class="math-container">\[M(x,y,p,t)\dot{x} = f(x,y,p,t)\]</p><p>where <span>$M(x, y, p, t)$</span> is a function which defines the mass matrix corresponding to the differential equation, <span>$f(x, y, p, t)$</span> is a function which defines the mass matrix multiplied state rates, <span>$x$</span> is a vector of states, <span>$y$</span> is a vector of inputs (coupling variables), <span>$p$</span> is a vector of parameters, and <span>$t$</span> is the current time.</p><p>The state variables for coupled models</p><h2 id="Aeroelastic-Model"><a class="docs-heading-anchor" href="#Aeroelastic-Model">Aeroelastic Model</a><a id="Aeroelastic-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Aeroelastic-Model" title="Permalink"></a></h2><p>To form a new aeroelastic model, we will be coupling Peters&#39; finite state model with the typical section structural model.</p><h3 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h3><p>State variables for all models (including coupled models) in this package satisfy the ordinary differential equation (or differential algebraic equation in mass matrix form)</p><p class="math-container">\[M(x,y,p,t)\dot{x} = f(x,y,p,t)\]</p><p>where <span>$M(x, y, p, t)$</span> is a function which defines the mass matrix corresponding to the differential equation, <span>$f(x, y, p, t)$</span> is a function which defines the mass matrix multiplied state rates, <span>$x$</span> is a vector of states, <span>$y$</span> is a vector of inputs (coupling variables), <span>$p$</span> is a vector of parameters, and <span>$t$</span> is the current time.</p><p>We assume the state variables of the coupled model correspond to the state variables of all of its subcomponent models concatenated, the inputs of the coupled model correspond to the inputs of all of its subcomponent models concatenated, and the parameters of the coupled model correspond to the parameters of all of its subcomponent models concatenated, followed by an additional set of parameters.</p><p class="math-container">\[x = \begin{Bmatrix} x_\text{aero} \\ x_\text{stru} \end{Bmatrix} \quad
y = \begin{Bmatrix} y_\text{aero} \\ y_\text{stru} \end{Bmatrix} \quad
p = \begin{Bmatrix} p_\text{aero} \\ p_\text{stru} \\ p_\text{additional} \end{Bmatrix}\]</p><p>We also assume the inputs for the coupled model may be expressed as a function of the coupled model&#39;s state variables and parameters, as well as the current time.  This assumption allows the state variables and parameters from each coupled model to influence the governing differential equations of the other coupled models through their input variables.</p><p class="math-container">\[y = g(x, p, t) = \begin{Bmatrix} g_\text{aero}(x, p, t) \\ g_\text{stru}(x, p, t) \end{Bmatrix}\]</p><p>If the state rates of the coupled model are linearly dependent on the inputs, the definition of the inputs of the coupled model may be expanded to include a linear dependency on the coupled model&#39;s state rates.  Since this term will eventually be moved to the left side of the governing differential equations for the coupled model, we define it as a negative quantity.</p><p class="math-container">\[y = g(x, p, t) - M_y(x,p,t) \dot{x} =
\begin{Bmatrix}
g_\text{aero}(x, p, t) - M_{y,\text{aero}}(x,p,t) \dot{x} \\
g_\text{stru}(x, p, t) - M_{y,\text{stru}}(x,p,t) \dot{x}
\end{Bmatrix}\]</p><p>With these assumptions, the coupled system of equations may be defined as</p><p class="math-container">\[M(x,p,t) \dot{x} = f(x,p,t)\]</p><p class="math-container">\[M = \begin{bmatrix}
    M_\text{aero} &amp; 0 \\
    0 &amp; M_\text{stru}
\end{bmatrix} +
\begin{bmatrix}
    \frac{\partial f_\text{aero}}{\partial y_\text{aero}} &amp; 0 \\
    0 &amp; \frac{\partial f_\text{stru}}{\partial y_\text{stru}}
\end{bmatrix}
\begin{bmatrix}
    M_{y,\text{aero}} \\
    M_{y,\text{stru}}
\end{bmatrix} \quad\]</p><p>and the associated jacobian is</p><p class="math-container">\[\frac{\partial f_x}{\partial x} = \begin{bmatrix}
\frac{\partial f_\text{aero}}{\partial x_\text{aero}} &amp; 0 \\
0 &amp; \frac{\partial f_\text{stru}}{\partial x_\text{stru}}
\end{bmatrix} +
\begin{bmatrix}
    \frac{\partial f_\text{aero}}{\partial y_\text{aero}} &amp; 0 \\
    0 &amp; \frac{\partial f_\text{stru}}{\partial y_\text{stru}}
\end{bmatrix}
\begin{bmatrix}
    \frac{\partial g_\text{aero}}{\partial x_\text{aero}} &amp;
    \frac{\partial g_\text{aero}}{\partial x_\text{stru}} \\
    \frac{\partial g_\text{stru}}{\partial x_\text{aero}} &amp;
    \frac{\partial g_\text{stru}}{\partial x_\text{stru}}
\end{bmatrix}\]</p><h4 id="Aerodynamic-Model-Inputs"><a class="docs-heading-anchor" href="#Aerodynamic-Model-Inputs">Aerodynamic Model Inputs</a><a id="Aerodynamic-Model-Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Aerodynamic-Model-Inputs" title="Permalink"></a></h4><p>The freestream velocity components <span>$u$</span> and <span>$v$</span> are assumed to be aligned with the undeflected chordwise and normal directions, respectively, so that</p><p class="math-container">\[u \approx U_\infty \\
v \approx \dot{h} \\
\omega \approx \dot{\theta}\]</p><p>where <span>$U_\infty$</span> is the freestream velocity magnitude, <span>$\theta$</span> is pitch, and <span>$h$</span> is plunge. To capture the effect of twist on the circulatory lift (since it is no longer implicitly modeled by the <span>$\frac{v}{u}$</span> quantity) twist is added to the effective angle of attack from Peter&#39;s finite state model so that the effective angle of attack is now given by</p><p class="math-container">\[\alpha_\text{eff} = \theta - \frac{v}{u} + \frac{b}{u}\left( \frac{1}{2} - a \right) \omega  + \frac{\lambda_0}{u} - \alpha_0\]</p><p>The original expression for the effective angle of attack may be used by defining the new variable <span>$\bar{v} = u \theta + v$</span> such that</p><p class="math-container">\[\alpha_\text{eff} = -\frac{\bar{v}}{u} + \frac{b}{u}\left( \frac{1}{2} - a \right) \omega + \frac{\lambda_0}{u} - \alpha_0\]</p><p>With these assumptions, the inputs for Peters&#39; finite state model are</p><p class="math-container">\[u = U_\infty \\
\omega = \dot{\theta} \\
\dot{v} = \ddot{h} \\
\dot{\omega} = \ddot{\theta}\]</p><h4 id="Structural-Model-Inputs"><a class="docs-heading-anchor" href="#Structural-Model-Inputs">Structural Model Inputs</a><a id="Structural-Model-Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-Model-Inputs" title="Permalink"></a></h4><p>A small angle assumption is also used to define the lift about the reference location as</p><p class="math-container">\[\mathcal{L} \approx \mathcal{N}\]</p><p>where <span>$\mathcal{N}$</span> is the normal force per unit span at the reference location.</p><p>With this assumption, the inputs for the typical section model is</p><p class="math-container">\[\mathcal{L} = a_0 \rho_\infty u^2 b \alpha_\text{eff} + \pi \rho b^2 \left(-\dot{v} + u\omega - a b \dot{\omega} \right) \\
\mathcal{M} = -\pi \rho_\infty b^3 \left[ -\frac{1}{2}\dot{v} + u\omega + b \left( \frac{1}{8} - \frac{a}{2} \right) \dot{\omega} \right] + b \left(\frac{1}{2} + a \right) \mathcal{L}\]</p><p>where</p><p class="math-container">\[\alpha = \theta - \frac{v}{u} + \frac{b}{u}\left( \frac{1}{2} - a \right) \omega + \frac{\lambda_0}{u} - \alpha_0\]</p><p>and</p><p class="math-container">\[\lambda_0 \approx \frac{1}{2} \sum_{n=1}^N b_n \lambda_n\]</p><h3 id="Defining-the-Coupled-Model"><a class="docs-heading-anchor" href="#Defining-the-Coupled-Model">Defining the Coupled Model</a><a id="Defining-the-Coupled-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Coupled-Model" title="Permalink"></a></h3><p>To define the coupled model, we define a new method for the <a href="../couplings/liftingline-gxbeam-rigidbody/#AerostructuralDynamics.couple_models-Tuple{LiftingLine, GEBT, RigidBody}"><code>couple_models</code></a> function.  This method should just return a tuple of models in the order in which their state variables, inputs, and parameters are defined.</p><pre><code class="language- hljs">&quot;&quot;&quot;
    couple_models(aero::Peters, stru::TypicalSection)

Create an aerostructural model using the unsteady aerodynamic model defined by
Peters et al. and a two-degree of freedom typical section model.  This model
introduces the freestream velocity ``U_\\infty`` and air density ``\\rho_\\infty``
as additional parameters.
&quot;&quot;&quot;
couple_models(aero::MyPeters, stru::MyTypicalSection) = (aero, stru)

nothing #hide</code></pre><h3 id="Defining-Input-Function-Properties"><a class="docs-heading-anchor" href="#Defining-Input-Function-Properties">Defining Input Function Properties</a><a id="Defining-Input-Function-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Input-Function-Properties" title="Permalink"></a></h3><p>Before we define the combined input function (and its associated functions) we need to define a few of its properties.</p><p>To define whether the combined input function should use an in-place or out-of-place format, we define a new method for the <a href="@ref"><code>inplaceness</code></a> function.</p><pre><code class="language- hljs">inplaceness(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = OutOfPlace()
nothing #hide</code></pre><p>To indicate input function mass matrix properties, we define a new method for the <a href="@ref"><code>mass_matrix_type</code></a> function.</p><pre><code class="language- hljs">mass_matrix_type(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = Linear()
nothing #hide</code></pre><p>To indicate the properties of the input function jacobian with respect to the state variables, we define a new method for the <a href="@ref"><code>state_jacobian_type</code></a> function.</p><pre><code class="language- hljs">state_jacobian_type(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = Nonlinear()
nothing #hide</code></pre><p>To define the number of additional parameters introduced by this model, we define a new method for the <a href="../interface/#AerostructuralDynamics.number_of_parameters"><code>number_of_parameters</code></a> function.</p><pre><code class="language- hljs">number_of_parameters(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = 2
nothing</code></pre><h3 id="Defining-Input-Function-Methods"><a class="docs-heading-anchor" href="#Defining-Input-Function-Methods">Defining Input Function Methods</a><a id="Defining-Input-Function-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Input-Function-Methods" title="Permalink"></a></h3><p>The portion of the inputs which is independent of the state rates is calculated using the <a href="../interface/#AerostructuralDynamics.get_inputs"><code>get_inputs</code></a> function for out-of-place aerodynamic load calculations and <a href="../interface/#AerostructuralDynamics.get_inputs!"><code>get_inputs!</code></a> function for in-place aerodynamic load calculations.</p><pre><code class="language- hljs">
function get_inputs(aero::MyPeters{N,TF,SV,SA}, stru::MyTypicalSection,
    s, p, t) where {N,TF,SV,SA}
    # extract state variables
    λ = s[SVector{N}(1:N)]
    h, θ, hdot, θdot = s[SVector{4}(N+1:N+4)]
    # extract parameters
    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p
    # extract model constants
    bbar = aero.b
    # local freestream velocity components
    u = U
    vbar = U*θ + hdot
    ω = θdot
    # circulatory load factor
    tmp1 = a0*ρ*u*b
    # non-circulatory load factor
    tmp2 = pi*ρ*b^3
    # constant based on geometry
    d = b/2 - a*b
    # induced flow velocity
    λ0 = 1/2 * bbar&#39;*λ
    # lift at reference point
    L = tmp1*(vbar + d*ω - λ0 - u*α0) + tmp2*u/b*ω
    # moment at reference point
    M = -tmp2*u*ω + (b/2 + a*b)*L
    # return portion of inputs that is not dependent on the state rates
    return SVector(u, ω, 0, 0, L, M)
end
nothing #hide</code></pre><p>For out-of-place input functions, the mass matrix is calculated using the <a href="../interface/#AerostructuralDynamics.get_input_mass_matrix"><code>AerostructuralDynamics.get_input_mass_matrix</code></a> function.  For in-place combined input functions, the mass matrix is calculated using the <a href="../interface/#AerostructuralDynamics.get_input_mass_matrix!"><code>AerostructuralDynamics.get_input_mass_matrix!</code></a> function.  For constant mass matrices, these functions are called without the <code>u</code>, <code>p</code>, and <code>t</code> arguments.</p><pre><code class="language- hljs">
function get_input_mass_matrix(aero::MyPeters{N,TF,SV,SA},
    stru::MyTypicalSection, s, p, t) where {N,TF,SV,SA}
    # extract parameters
    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p
    # local freestream velocity components
    vdot_dhdot = 1
    ωdot_dθdot = 1
    # non-circulatory load factor
    tmp = pi*ρ*b^3
    # lift at reference point
    L_dhdot = tmp/b
    L_dθdot = -tmp*a
    # moment at reference point
    M_dhdot = -tmp/2 + (b/2 + a*b)*L_dhdot
    M_dθdot = -tmp*(b/8 - a*b/2) + (b/2 + a*b)*L_dθdot
    # construct submatrices
    Mda = zeros(SMatrix{4,N,TF})
    Mds = @SMatrix [0 0 0 0; 0 0 0 0; 0 0 -vdot_dhdot 0; 0 0 0 -ωdot_dθdot]
    Mra = zeros(SMatrix{2,N,TF})
    Mrs = @SMatrix [0 0 -L_dhdot -L_dθdot; 0 0 -M_dhdot -M_dθdot]
    # assemble mass matrix
    return [Mda Mds; Mra Mrs]
end

nothing #hide</code></pre><h3 id="Input-Function-Performance-Overloads"><a class="docs-heading-anchor" href="#Input-Function-Performance-Overloads">Input Function Performance Overloads</a><a id="Input-Function-Performance-Overloads-1"></a><a class="docs-heading-anchor-permalink" href="#Input-Function-Performance-Overloads" title="Permalink"></a></h3><p>The jacobian of <span>$f_y$</span> with respect to the state variables is calculated using the <a href="../interface/#AerostructuralDynamics.get_input_state_jacobian"><code>AerostructuralDynamics.get_input_state_jacobian</code></a> function for out-of-place combined input functions and <a href="../interface/#AerostructuralDynamics.get_input_state_jacobian!"><code>AerostructuralDynamics.get_input_state_jacobian!</code></a> function for in-place combined inputs functions.</p><pre><code class="language- hljs">function get_input_state_jacobian(aero::MyPeters{N,TF,SV,SA},
    stru::MyTypicalSection, s, p, t) where {N,TF,SV,SA}
    # extract parameters
    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p
    # extract model constants
    bbar = aero.b
    # local freestream velocity components
    ω_θdot = 1
    # calculate aerodynamic loads
    L_λ = -a0*ρ*u*b/2*bbar&#39;
    M_λ = (b/2 + a*b)*L_λ
    L_θ = a0*ρ*u^2*b
    M_θ = (b/2 + a*b)*L_θ
    L_hdot = a0*ρ*u*b
    M_hdot = (b/2 + a*b)*L_hdot
    L_θdot = a0*ρ*u*b*(b/2 - a*b) + pi*ρ*b^2*u
    M_θdot = -pi*ρ*b^3*u + (b/2 + a*b)*L_θdot
    # construct sub-matrices
    Jda = zeros(SMatrix{4,N,TF}) # d(d)/d(dλ)
    Jds = @SMatrix [0 0 0 0; 0 0 0 ω_θdot; 0 0 0 0; 0 0 0 0]
    Jra = [L_λ; M_λ]
    Jrs = @SMatrix [0 L_θ L_hdot L_θdot; 0 M_θ M_hdot M_θdot]
    # return jacobian
    return [Jda Jds; Jra Jrs]
end
nothing #hide</code></pre><h3 id="Coupled-Model-Code"><a class="docs-heading-anchor" href="#Coupled-Model-Code">Coupled Model Code</a><a id="Coupled-Model-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Coupled-Model-Code" title="Permalink"></a></h3><p>Putting it all together, a complete representation of the input function associated with our coupled model may be defined using the following block of code.</p><pre><code class="language- hljs">&quot;&quot;&quot;
    couple_models(aero::Peters, stru::TypicalSection)

Create an aerostructural model using the unsteady aerodynamic model defined by
Peters et al. and a two-degree of freedom typical section model.  This model
introduces the freestream velocity ``U_\\infty`` and air density ``\\rho_\\infty``
as additional parameters.
&quot;&quot;&quot;
couple_models(aero::MyPeters, stru::MyTypicalSection) = (aero, stru)

# --- traits --- #

inplaceness(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = OutOfPlace()
mass_matrix_type(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = Linear()
state_jacobian_type(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = Nonlinear()
number_of_parameters(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = 2

# --- methods --- #

function get_inputs(aero::MyPeters{N,TF,SV,SA}, stru::MyTypicalSection,
    s, p, t) where {N,TF,SV,SA}
    # extract state variables
    λ = s[SVector{N}(1:N)]
    h, θ, hdot, θdot = s[SVector{4}(N+1:N+4)]
    # extract parameters
    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p
    # extract model constants
    bbar = aero.b
    # local freestream velocity components
    u = U
    vbar = U*θ + hdot
    ω = θdot
    # circulatory load factor
    tmp1 = a0*ρ*u*b
    # non-circulatory load factor
    tmp2 = pi*ρ*b^3
    # constant based on geometry
    d = b/2 - a*b
    # induced flow velocity
    λ0 = 1/2 * bbar&#39;*λ
    # lift at reference point
    L = tmp1*(vbar + d*ω - λ0 - u*α0) + tmp2*u/b*ω
    # moment at reference point
    M = -tmp2*u*ω + (b/2 + a*b)*L
    # return portion of inputs that is not dependent on the state rates
    return SVector(u, ω, 0, 0, L, M)
end


function get_input_mass_matrix(aero::MyPeters{N,TF,SV,SA},
    stru::MyTypicalSection, s, p, t) where {N,TF,SV,SA}
    # extract parameters
    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p
    # local freestream velocity components
    vdot_dhdot = 1
    ωdot_dθdot = 1
    # non-circulatory load factor
    tmp = pi*ρ*b^3
    # lift at reference point
    L_dhdot = tmp/b
    L_dθdot = -tmp*a
    # moment at reference point
    M_dhdot = -tmp/2 + (b/2 + a*b)*L_dhdot
    M_dθdot = -tmp*(b/8 - a*b/2) + (b/2 + a*b)*L_dθdot
    # construct submatrices
    Mda = zeros(SMatrix{4,N,TF})
    Mds = @SMatrix [0 0 0 0; 0 0 0 0; 0 0 -vdot_dhdot 0; 0 0 0 -ωdot_dθdot]
    Mra = zeros(SMatrix{2,N,TF})
    Mrs = @SMatrix [0 0 -L_dhdot -L_dθdot; 0 0 -M_dhdot -M_dθdot]
    # assemble mass matrix
    return [Mda Mds; Mra Mrs]
end

# --- performance overloads --- #

function get_input_state_jacobian(aero::MyPeters{N,TF,SV,SA},
    stru::MyTypicalSection, s, p, t) where {N,TF,SV,SA}
    # extract parameters
    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p
    # extract model constants
    bbar = aero.b
    # local freestream velocity components
    ω_θdot = 1
    # calculate aerodynamic loads
    L_λ = -a0*ρ*u*b/2*bbar&#39;
    M_λ = (b/2 + a*b)*L_λ
    L_θ = a0*ρ*u^2*b
    M_θ = (b/2 + a*b)*L_θ
    L_hdot = a0*ρ*u*b
    M_hdot = (b/2 + a*b)*L_hdot
    L_θdot = a0*ρ*u*b*(b/2 - a*b) + pi*ρ*b^2*u
    M_θdot = -pi*ρ*b^3*u + (b/2 + a*b)*L_θdot
    # construct sub-matrices
    Jda = zeros(SMatrix{4,N,TF}) # d(d)/d(dλ)
    Jds = @SMatrix [0 0 0 0; 0 0 0 ω_θdot; 0 0 0 0; 0 0 0 0]
    Jra = [L_λ; M_λ]
    Jrs = @SMatrix [0 L_θ L_hdot L_θdot; 0 M_θ M_hdot M_θdot]
    # return jacobian
    return [Jda Jds; Jra Jrs]
end</code></pre><h3 id="Example-Usage"><a class="docs-heading-anchor" href="#Example-Usage">Example Usage</a><a id="Example-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Usage" title="Permalink"></a></h3><pre><code class="language- hljs">using AerostructuralDynamics, LinearAlgebra

# reduced velocity range
V = range(0, 3.1, length=5000) # = U/(b*ωθ) (reduced velocity)

# non-dimensional parameters
a = -1/5 # reference point normalized location
e = -1/10 # center of mass normalized location
μ = 20 # = m/(ρ*pi*b^2) (mass ratio)
r2 = 6/25 # = Iθ/(m*b^2) (radius of gyration about P)
σ = 2/5 # = ωh/ωθ (natural frequency ratio)
xθ = e - a
a0 = 2*pi # lift curve slope
α0 = 0 # zero lift angle

# chosen dimensional parameters
b = 1
ρ = 1
ωθ = 1

# derived dimensional parameters
m = μ*ρ*pi*b^2
Sθ = m*xθ*b
Iθ = r2*m*b^2
ωh = σ*ωθ
kh = m*ωh^2
kθ = Iθ*ωθ^2

# dimensionalized velocity
U = V*b*ωθ

# aerodynamic models
aerodynamic_model = MyPeters{6}()

# structural model
structural_model = MyTypicalSection()

# coupled model
model = couple_models(aerodynamic_model, structural_model)

# eigenvalue storage
λ = zeros(ComplexF64, number_of_states(model), length(V))

# loop through each reduced frequency
for i = 1:length(V)
    # state variables
    u_aero = zeros(number_of_states(aerodynamic_model))
    u_stru = zeros(number_of_states(structural_model))
    u = vcat(u_aero, u_stru)

    # parameters
    p_aero = [a, b, a0, α0]
    p_stru = [kh, kθ, m, Sθ, Iθ]
    p_input = [U[i], ρ]
    p = vcat(p_aero, p_stru, p_input)

    # time
    t = 0.0

    # calculate inputs
    y = get_inputs(model, u, p, t)

    # perform linear stability analysis
    λ[:,i], Uλ, Vλ = get_eigen(model, u, y, p, t)
end

nothing #hide</code></pre><pre><code class="language- hljs">using Plots
pyplot()

default(
    titlefontsize = 14,
    legendfontsize = 11,
    guidefontsize = 14,
    tickfontsize = 11,
    foreground_color_legend = nothing,
    background_color_legend = nothing,
    minorgrid=true,
    framestyle = :zerolines)

sp1 = plot(
    title = &quot;Non-Dimensional Frequency&quot;,
    xlim = (0,3.1),
    xtick = 0.0:0.5:3.0,
    xlabel = &quot;\$ \\frac{U}{b \\omega_\\theta} \$&quot;,
    ylim = (0, 1.05),
    ytick = 0.0:0.2:1.0,
    ylabel = &quot;\$ \\frac{\\Omega}{\\omega_\\theta} \$&quot;,
    legend = :topright
    )

sp2 = plot(
    title = &quot;Non-Dimensional Damping&quot;,
    xlim = (0,3.1),
    xtick = 0.0:0.5:3.0,
    xlabel = &quot;\$ \\frac{U}{b \\omega_\\theta} \$&quot;,
    ylim = (-0.7, 0.605),
    ytick = -0.6:0.2:0.6,
    ylabel = &quot;\$ \\frac{Γ}{\\omega_\\theta} \$&quot;,
    legend = :topleft
    )

for i = 1:size(λ, 1)
    scatter!(sp1, V, imag.(λ[i,:])/ωθ,
        label = &quot;&quot;,
        color = 1,
        markersize = 1,
        markerstrokewidth = 0,
        )
end

for i = 1:size(λ, 1)
    scatter!(sp2, V, real.(λ[i,:])/ωθ,
        label = &quot;&quot;,
        color = 1,
        markersize = 1,
        markerstrokewidth = 0,
        )
end

p1 = plot(sp1, sp2, layout = (2, 1), size = (600, 800))

savefig(p1, &quot;example-stability.svg&quot;) #hide

nothing #hide</code></pre><p><img src="example-stability.svg" alt/></p><h2 id="Model-Ordering"><a class="docs-heading-anchor" href="#Model-Ordering">Model Ordering</a><a id="Model-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Ordering" title="Permalink"></a></h2><p>In general, we suggest that the following ordering of model state variables, inputs, and parameters is used when constructing input functions.</p><ol><li>Aerodynamics</li><li>Structural</li><li>Rigid Body (when present)</li></ol><h2 id="Avoiding-Mass-Matrices"><a class="docs-heading-anchor" href="#Avoiding-Mass-Matrices">Avoiding Mass Matrices</a><a id="Avoiding-Mass-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Avoiding-Mass-Matrices" title="Permalink"></a></h2><p>In order to take advantage of as many features of the DifferentialEquations package as possible (including local sensitivity analysis), at this point in time we recommend that the governing differential equations for models be reformulated to avoid using mass matrices whenever possible.</p><p>In this guide, we define a new aerodynamic and structural model and then couple them together to form a new aeroelastic model.  The same process may be followed to define and/or couple any number of models together.</p><ul><li><a href="#Developer&#39;s-Guide">Developer&#39;s Guide</a></li><ul><li><a href="#Creating-a-New-Model">Creating a New Model</a></li><ul><li><a href="#Manipulating-a-Model&#39;s-Governing-Equations">Manipulating a Model&#39;s Governing Equations</a></li><li><a href="#Defining-a-Model&#39;s-Type">Defining a Model&#39;s Type</a></li><li><a href="#Defining-Model-Traits">Defining Model Traits</a></li><li><a href="#Defining-Methods-for-Governing-Equations">Defining Methods for Governing Equations</a></li><li><a href="#Defining-Methods-for-Jacobians">Defining Methods for Jacobians</a></li><li><a href="#Defining-Methods-for-Unit-Testing">Defining Methods for Unit Testing</a></li></ul><li><a href="#Creating-a-New-Model-Coupling">Creating a New Model Coupling</a></li><ul><li><a href="#Coupled-Model-Theory">Coupled Model Theory</a></li></ul><li><a href="#Aeroelastic-Model">Aeroelastic Model</a></li><ul><li><a href="#Theory">Theory</a></li><li><a href="#Defining-the-Coupled-Model">Defining the Coupled Model</a></li><li><a href="#Defining-Input-Function-Properties">Defining Input Function Properties</a></li><li><a href="#Defining-Input-Function-Methods">Defining Input Function Methods</a></li><li><a href="#Input-Function-Performance-Overloads">Input Function Performance Overloads</a></li><li><a href="#Coupled-Model-Code">Coupled Model Code</a></li><li><a href="#Example-Usage">Example Usage</a></li></ul><li><a href="#Model-Ordering">Model Ordering</a></li><li><a href="#Avoiding-Mass-Matrices">Avoiding Mass Matrices</a></li><li><a href="#"></a></li><li><a href="#Typical-Section-Model">Typical Section Model</a></li><ul><li><a href="#Theory-2">Theory</a></li><li><a href="#Defining-a-New-Type">Defining a New Type</a></li><li><a href="#Defining-Model-Properties">Defining Model Properties</a></li><li><a href="#Defining-Model-Methods">Defining Model Methods</a></li></ul><li><a href="#Performance-Overloads">Performance Overloads</a></li><ul><li><a href="#Typical-Section-Model-Code">Typical Section Model Code</a></li></ul><li><a href="#Peters&#39;-Finite-State-Model">Peters&#39; Finite State Model</a></li><ul><li><a href="#Defining-a-New-Type-2">Defining a New Type</a></li><li><a href="#Defining-Model-Properties-2">Defining Model Properties</a></li><li><a href="#Defining-Model-Methods-2">Defining Model Methods</a></li><li><a href="#Performance-Overloads-2">Performance Overloads</a></li><li><a href="#Aerodynamic-Model-Code">Aerodynamic Model Code</a></li></ul><li><a href="#Aeroelastic-Model-2">Aeroelastic Model</a></li><ul><li><a href="#Theory-3">Theory</a></li><li><a href="#Defining-the-Coupled-Model-2">Defining the Coupled Model</a></li><li><a href="#Defining-Input-Function-Properties-2">Defining Input Function Properties</a></li><li><a href="#Defining-Input-Function-Methods-2">Defining Input Function Methods</a></li><li><a href="#Input-Function-Performance-Overloads-2">Input Function Performance Overloads</a></li><li><a href="#Coupled-Model-Code-2">Coupled Model Code</a></li><li><a href="#Example-Usage-2">Example Usage</a></li></ul><li><a href="#Model-Ordering-2">Model Ordering</a></li><li><a href="#Avoiding-Mass-Matrices-2">Avoiding Mass Matrices</a></li></ul></ul><h2 id><a class="docs-heading-anchor" href="#"></a><a id="-1"></a><a class="docs-heading-anchor-permalink" href="#" title="Permalink"></a></h2><h2 id="Typical-Section-Model"><a class="docs-heading-anchor" href="#Typical-Section-Model">Typical Section Model</a><a id="Typical-Section-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Typical-Section-Model" title="Permalink"></a></h2><p>The first model we will be constructing is the typical section structural model.  </p><p><img src="../typical-section.svg" alt/></p><p>The equations of motion for this model are:</p><p class="math-container">\[\begin{bmatrix} m &amp; S_\theta \\ S_\theta &amp; I_\theta \end{bmatrix}
\begin{Bmatrix} \ddot{h} \\ \ddot{\theta} \end{Bmatrix} +
\begin{bmatrix} k_h &amp; 0 \\ 0 &amp; k_h \end{bmatrix}
\begin{Bmatrix} h \\ \theta \end{Bmatrix} =
\begin{Bmatrix} -\mathcal{L} \\ \mathcal{M} \end{Bmatrix}\]</p><p>where <span>$k_h$</span> is the linear spring constant, <span>$k_\theta$</span> is the torsional spring constant, <span>$m$</span> is the mass per unit span, <span>$S_\theta$</span> is the structural imbalance, <span>$I_\theta$</span> is the mass moment of inertia, <span>$\mathcal{L}$</span> is the lift per unit span, and <span>$\mathcal{M}$</span> is the moment per unit span.</p><h3 id="Theory-2"><a class="docs-heading-anchor" href="#Theory-2">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-2" title="Permalink"></a></h3><p>State variables for all models in this package satisfy the ordinary differential equation (or differential algebraic equation in mass matrix form)</p><p class="math-container">\[M(x,y,p,t)\dot{x} = f(x,y,p,t)\]</p><p>where <span>$M(x, y, p, t)$</span> is a function which defines the mass matrix corresponding to the differential equation, <span>$f(x, y, p, t)$</span> is a function which defines the mass matrix multiplied state rates, <span>$x$</span> is a vector of states, <span>$y$</span> is a vector of inputs (coupling variables), <span>$p$</span> is a vector of parameters, and <span>$t$</span> is the current time.</p><p>The equations of motion for the typical section model when expressed in the form expected by this package are</p><p class="math-container">\[M \dot{x} = K x + D y\]</p><p>where</p><p class="math-container">\[x = \begin{bmatrix} h &amp; \theta &amp; \dot{h} &amp; \dot{\theta} \end{bmatrix}^T \quad
y = \begin{bmatrix} -\mathcal{L} &amp; \mathcal{M} \end{bmatrix}^T\]</p><p class="math-container">\[M =
\begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; m &amp; m b x_\theta \\
    0 &amp; 0 &amp; m b x_\theta &amp; I_P
\end{bmatrix}
\quad
K =
\begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
-k_h &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; -k_\theta &amp; 0 &amp; 0
\end{bmatrix}
\quad
D =
\begin{bmatrix}
0 &amp; 0 \\
0 &amp; 0 \\
-1 &amp; 0 \\
0 &amp; 1
\end{bmatrix}\]</p><h3 id="Defining-a-New-Type"><a class="docs-heading-anchor" href="#Defining-a-New-Type">Defining a New Type</a><a id="Defining-a-New-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-New-Type" title="Permalink"></a></h3><p>We start creating our model by defining a new type.  </p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    MyTypicalSection &lt;: AbstractModel

Typical section structural model with state variables ``h, \\theta, \\dot{h},
\\dot{\\theta}``, inputs ``\\mathcal{L}, \\mathcal{M}``, and parameters ``k_h,
k_\\theta, m, S_\\theta, I_\\theta``
&quot;&quot;&quot;
struct MyTypicalSection &lt;: AbstractModel end</code></pre><p>Note that the state, input, and parameter identities for each model should be documented in the docstring associated with their type since this docstring provides the primary source of documentation for a given model.</p><h3 id="Defining-Model-Properties"><a class="docs-heading-anchor" href="#Defining-Model-Properties">Defining Model Properties</a><a id="Defining-Model-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Model-Properties" title="Permalink"></a></h3><p>We now need to define a few model properties.</p><p>To indicate the number of state variables in our model, we define a new method for the <a href="../interface/#AerostructuralDynamics.number_of_states"><code>number_of_states</code></a> function.  In our case, we have four state variables <span>$h, \theta, \dot{h}, \dot{\theta}$</span>.</p><pre><code class="language-julia hljs">AerostructuralDynamics.number_of_states(::Type{MyTypicalSection}) = 4</code></pre><p>To indicate the number of inputs (coupling variables), we define a new method for the <a href="../interface/#AerostructuralDynamics.number_of_inputs"><code>number_of_inputs</code></a> function.  In our case, we have two inputs <span>$\\mathcal{L}, \\mathcal{M}$</span>.  We define these variables as inputs rather than parameters since they will be calculated as a function of the state variables of the coupled system, rather than prescribed directly.  For aeroelastic systems, the inputs for aerodynamic models typically correspond to structural deflections while the inputs for structural models typically correspond to aerodynamic loads.</p><pre><code class="language-julia hljs">AerostructuralDynamics.number_of_inputs(::Type{MyTypicalSection}) = 2</code></pre><p>To indicate the number of parameters, we define a new method for the <a href="../interface/#AerostructuralDynamics.number_of_parameters"><code>number_of_parameters</code></a> function.  In our case, we have five parameters <span>$k_h, k_\\theta, m, S_\\theta, I_\\theta$</span>.</p><pre><code class="language-julia hljs">AerostructuralDynamics.number_of_parameters(::Type{MyTypicalSection}) = 5</code></pre><p>To indicate whether our model uses in-place or out-of-place functions, we define a new method for the <a href="@ref"><code>inplaceness</code></a> function.  For performance reasons, in-place functions are generally preferred.  The one exception is for models with small numbers of state variables, in which case the preferred approach is to use static arrays with out-of-place functions.  For this model, we use the latter approach.</p><pre><code class="language-julia hljs">inplaceness(::Type{MyTypicalSection}) = OutOfPlace()</code></pre><p>To indicate mass matrix properties, we define a new method for the <a href="@ref"><code>mass_matrix_type</code></a> function.</p><pre><code class="language-julia hljs">mass_matrix_type(::Type{MyTypicalSection}) = Linear()</code></pre><p>To indicate the properties of the jacobian of the mass matrix multiplied state rates with respect to the state variables, we define a new method for the <a href="@ref"><code>state_jacobian_type</code></a> function.  This method definition is only required if the jacobian with respect to the state variables is manually defined.</p><pre><code class="language-julia hljs">state_jacobian_type(::Type{MyTypicalSection}) = Linear()</code></pre><p>To indicate the properties of the jacobian of the mass matrix multiplied state rates with respect to the inputs, we define a new method for the <a href="@ref"><code>input_jacobian_type</code></a> function.  This method definition is only required if the jacobian with respect to the inputs is manually defined.</p><pre><code class="language-julia hljs">input_jacobian_type(::Type{MyTypicalSection}) = Constant()</code></pre><h3 id="Defining-Model-Methods"><a class="docs-heading-anchor" href="#Defining-Model-Methods">Defining Model Methods</a><a id="Defining-Model-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Model-Methods" title="Permalink"></a></h3><p>Now that we have defined the properties of our model, we need to define the governing equations for its state variables.</p><p>The right hand side of the governing structural differential equations is calculated using the <a href="../interface/#AerostructuralDynamics.get_rates"><code>get_rates</code></a> function for out-of-place models or the <a href="../interface/#AerostructuralDynamics.get_rates!"><code>get_rates!</code></a> function for in-place models.  </p><pre><code class="language-julia hljs">function get_rates(::MyTypicalSection, x, y, p, t)
    # extract state variables
    h, θ, hdot, θdot = x
    # extract inputs
    L, M = y
    # extract parameters
    kh, kθ, m, Sθ, Iθ = p
    # calculate state rates
    return SVector(hdot, θdot, -kh*h - L, -kθ*θ + M)
end</code></pre><p>Since our model uses a mass matrix, we also need to define a new method for the <a href="../interface/#AerostructuralDynamics.get_mass_matrix"><code>get_mass_matrix</code></a> function (or <a href="../interface/#AerostructuralDynamics.get_mass_matrix!"><code>get_mass_matrix!</code></a> function if the model&#39;s functions are in-place functions).  For constant mass matrices, these functions are called without the <code>x</code>, <code>y</code>, <code>p</code>, and <code>t</code> arguments.  </p><pre><code class="language-julia hljs">function get_mass_matrix(::MyTypicalSection, x, y, p, t)
    # extract structural parameters
    kh, kθ, m, Sθ, Iθ = p
    # calculate mass matrix
    return @SMatrix [1 0 0 0; 0 1 0 0; 0 0 m Sθ; 0 0 Sθ Iθ]
end</code></pre><h2 id="Performance-Overloads"><a class="docs-heading-anchor" href="#Performance-Overloads">Performance Overloads</a><a id="Performance-Overloads-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Overloads" title="Permalink"></a></h2><p>The code we have presented so far fully defines the governing equations for the structural state variables of the typical section model.  At this point, we can either provide custom definitions for the jacobians associated with these governing equations, or allow the jacobians to be calculated using forward automatic differentiation (enabled by the <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff</a> package).  While the latter approach is convenient, the former approach is typically less computationally expensive.</p><p>The jacobian of the right hand side of the governing equations with respect to the state variables may be defined using the <a href="../interface/#AerostructuralDynamics.get_state_jacobian"><code>get_state_jacobian</code></a> function for out-of-place models or <a href="../interface/#AerostructuralDynamics.get_state_jacobian!"><code>get_state_jacobian!</code></a> function for in-place models.</p><pre><code class="language-julia hljs">function get_state_jacobian(::MyTypicalSection, q, r, p, t)
    # extract parameters
    a, b, kh, kθ, m, xθ, Ip = p
    # return jacobian
    return @SMatrix [0 0 1 0; 0 0 0 1; -kh 0 0 0; 0 -kθ 0 0]
end</code></pre><p>The jacobian of the right hand side of the governing equations with respect to the inputs may be defined using the <a href="@ref"><code>get_input_jacobian</code></a> function.  There is no out-of-place form for this function, however, it may be constructed as either a linear map (for large matrices) or static array (for small matrices) in order to avoid allocations.</p><pre><code class="language-julia hljs">get_input_jacobian(::MyTypicalSection) = @SMatrix [0 0; 0 0; -1 0; 0 1]</code></pre><h3 id="Typical-Section-Model-Code"><a class="docs-heading-anchor" href="#Typical-Section-Model-Code">Typical Section Model Code</a><a id="Typical-Section-Model-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Typical-Section-Model-Code" title="Permalink"></a></h3><p>Putting it all together, a complete representation of our typical section model for use with this package may be defined using the following block of code.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    MyTypicalSection &lt;: AbstractModel

Typical section structural model with state variables ``h, \\theta, \\dot{h},
\\dot{\\theta}``, inputs ``\\mathcal{L}, \\mathcal{M}``, and parameters ``k_h,
k_\\theta, m, S_\\theta, I_\\theta``
&quot;&quot;&quot;
struct MyTypicalSection &lt;: AbstractModel end

# --- Traits --- #

number_of_states(::Type{MyTypicalSection}) = 4
number_of_inputs(::Type{MyTypicalSection}) = 2
number_of_parameters(::Type{MyTypicalSection}) = 5
inplaceness(::Type{MyTypicalSection}) = OutOfPlace()
mass_matrix_type(::Type{MyTypicalSection}) = Linear()
state_jacobian_type(::Type{MyTypicalSection}) = Linear()
input_jacobian_type(::Type{MyTypicalSection}) = Constant()

# --- Methods --- #

function get_rates(::MyTypicalSection, x, y, p, t)
    # extract state variables
    h, θ, hdot, θdot = x
    # extract inputs
    L, M = y
    # extract parameters
    kh, kθ, m, Sθ, Iθ = p
    # calculate state rates
    return SVector(hdot, θdot, -kh*h - L, -kθ*θ + M)
end

function get_mass_matrix(::MyTypicalSection, x, y, p, t)
    # extract structural parameters
    kh, kθ, m, Sθ, Iθ = p
    # calculate mass matrix
    return @SMatrix [1 0 0 0; 0 1 0 0; 0 0 m Sθ; 0 0 Sθ Iθ]
end

# --- Performance Overloads --- #

function get_state_jacobian(::MyTypicalSection, x, y, p, t)
    # extract parameters
    a, b, kh, kθ, m, xθ, Ip = p
    # return jacobian
    return @SMatrix [0 0 1 0; 0 0 0 1; -kh 0 0 0; 0 -kθ 0 0]
end

get_input_jacobian(::MyTypicalSection) = @SMatrix [0 0; 0 0; -1 0; 0 1]</code></pre><h2 id="Peters&#39;-Finite-State-Model"><a class="docs-heading-anchor" href="#Peters&#39;-Finite-State-Model">Peters&#39; Finite State Model</a><a id="Peters&#39;-Finite-State-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Peters&#39;-Finite-State-Model" title="Permalink"></a></h2><p>The second model we will be constructing is Peters&#39; finite state unsteady aerodynamics model.</p><p><img src="../airfoil.svg" alt/></p><p>The normal force and moment at the reference location, as calculated using Peters&#39; finite state model are</p><p class="math-container">\[\mathcal{N} = a_0 \rho_\infty u^2 b \alpha_\text{eff} + \pi \rho b^2 \left(-\dot{v} + u\dot{\theta} - a b \ddot{\theta} \right) \\
\mathcal{M} = -\pi \rho_\infty b^3 \left[ -\frac{1}{2}\dot{v} + u\dot{\theta} + b \left( \frac{1}{8} - \frac{a}{2} \right) \ddot{\theta} \right] + b \left(\frac{1}{2} + a \right) \mathcal{N}\]</p><p>where <span>$u$</span> is the local freestream velocity in the chordwise direction, <span>$v$</span> is the local freestream velocity in the normal direction, <span>$\omega$</span> is the freestream angular velocity, <span>$a$</span> defines the reference location, <span>$b$</span> is the semichord, <span>$a_0$</span> is the lift curve slope, <span>$\rho_\infty$</span> is the air density, and <span>$\alpha_\text{eff}$</span> is the effective angle of attack.  The effective angle of attack for this model is defined as</p><p class="math-container">\[\alpha_\text{eff} = -\frac{v}{u} + \frac{b}{u}\left( \frac{1}{2} - a \right) \dot{\theta} + \frac{\lambda_0}{u}  - \alpha_0\]</p><p>where <span>$\lambda_0$</span> is the induced velocity, and <span>$\alpha_0$</span> is the zero lift angle of attack.</p><p>The induced velocity <span>$\lambda_0$</span> is approximated from a set of N induced-flow states <span>$\lambda_1, \lambda_2, \dots, \lambda_N$</span> as</p><p class="math-container">\[\lambda \approx \frac{1}{2} \sum_{n=1}^N b_n \lambda_n\]</p><p>The set of N first-order ordinary differential equations which govern the N finite aerodynamic states are derived by Peters et al. as</p><p class="math-container">\[\bar{A} \lambda + \frac{u}{b} \lambda = \bar{c} \left[ -\dot{v} + u\dot{\theta} + b \left(\frac{1}{2} - a \right) \ddot{\theta} \right]\]</p><p>where</p><p class="math-container">\[\bar{A} = \bar{D} + \bar{d} \bar{b}^T + \bar{c} \bar{d}^T + \frac{1}{2} \bar{c}  \bar{b}^T \\
\bar{D}_{nm} = \begin{cases}
\frac{1}{2n} &amp; n=m+1 \\
\frac{-1}{2n} &amp; n=m-1 \\
0 &amp; n \neq m \pm 1 \\
\end{cases}
\quad
\bar{b}_n = \begin{cases}
\left( -1 \right)^{n-1} \frac{(N+n-1)!}{(N-n-1)!}\frac{1}{\left(n!\right)^2} &amp; n \neq N \\
\left( -1 \right)^{n-1} &amp; n = N
\end{cases}
\quad
\bar{c}_n = \frac{2}{n}
\quad
\bar{d}_n = \begin{cases}
\frac{1}{2} &amp; n = 1 \\
0 &amp; n \neq 1
\end{cases}\]</p><p>The equations of motion for Peters&#39; finite state model, when expressed in the form expected by this package are:</p><p class="math-container">\[\bar{A}\dot{\lambda} = \bar{c}\left[ \dot{v} + u\omega + b \left(\frac{1}{2} - a\right) \dot{\omega} \right] - \frac{u}{b}\lambda\]</p><h3 id="Defining-a-New-Type-2"><a class="docs-heading-anchor" href="#Defining-a-New-Type-2">Defining a New Type</a><a class="docs-heading-anchor-permalink" href="#Defining-a-New-Type-2" title="Permalink"></a></h3><p>We start creating our aerodynamic model by defining a new type.  </p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    MyPeters{N,TF,SV,SA} &lt;: AbstractModel

Peter&#39;s finite state model with `N` state variables, inputs ``u, \\omega,
\\dot{v}, \\dot{\\omega}`` and parameters ``a, b, a_0, \\alpha_0``
&quot;&quot;&quot;
struct MyPeters{N,TF,TV&lt;:SVector{N,TF},TA&lt;:SMatrix{N,N,TF}} &lt;: AbstractModel
    A::TA
    b::TV
    c::TV
end</code></pre><p>Here <code>N</code> is the number of aerodynamic state variables and <code>TF</code> is the floating point type used to represent the constant matrices/vectors <span>$\bar{A}$</span>, <span>$\bar{b}$</span>, and <span>$\bar{c}$</span>.  We store these matrices/vectors as fields of the newly defined type since they are constants.</p><p>For convenience, we create a constructor which initializes matrix <span>$\bar{A}$</span> and vectors <span>$\bar{b}$</span> and <span>$\bar{c}$</span> given the number of aerodynamic state variables and floating point type.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    MyPeters{N,TF=Float64}()

Initialize an object of type `MyPeters` which has `N` aerodynamic
degrees of freedom.
&quot;&quot;&quot;
MyPeters{N}() where N = MyPeters{N,Float64}()

function MyPeters{N,TF}() where {N,TF}

    b = zeros(TF, N)
    for n = 1:N-1
        b[n] = (-1)^(n-1)*factorial(big(N + n - 1))/factorial(big(N - n - 1))*
            1/factorial(big(n))^2
    end
    b[N] = (-1)^(N-1)

    c = zeros(TF, N)
    for n = 1:N
        c[n] = 2/n
    end

    d = zeros(TF, N)
    d[1] = 1/2

    D = zeros(TF, N, N)
    for m in 1:N-1
        n = m + 1
        D[n, m] = 1/(2*n)
    end
    for m in 2:N
        n = m - 1
        D[n, m] = -1/(2*n)
    end

    A = D + d*b&#39; + c*d&#39; + 1/2*c*b&#39;

    return MyPeters(SMatrix{N,N,TF}(A), SVector{N,TF}(b), SVector{N,TF}(c))
end</code></pre><h3 id="Defining-Model-Properties-2"><a class="docs-heading-anchor" href="#Defining-Model-Properties-2">Defining Model Properties</a><a class="docs-heading-anchor-permalink" href="#Defining-Model-Properties-2" title="Permalink"></a></h3><p>We now need to define a few model properties.</p><p>To indicate the number of state variables in our model, we define a new method for the <a href="../interface/#AerostructuralDynamics.number_of_states"><code>number_of_states</code></a> function.  In this case, we have an arbitrary number of aerodynamic states, though typically 3-10 aerodynamic states are used.  This method must be defined for all models.</p><pre><code class="language-julia hljs">number_of_states(::Type{MyPeters{N,TF,SV,SA}}) where {N,TF,SV,SA} = N</code></pre><p>To indicate the number of inputs, we define a new method for the <a href="../interface/#AerostructuralDynamics.number_of_inputs"><code>number_of_inputs</code></a> function.  In this case, we have four inputs <span>$u, \dot{\theta}, \ddot{h}, \ddot{\theta}$</span>.  This method must be defined for all models.</p><pre><code class="language-julia hljs">number_of_inputs(::Type{&lt;:MyPeters}) = 4</code></pre><p>To indicate the number of parameters, we define a new method for the <a href="../interface/#AerostructuralDynamics.number_of_parameters"><code>number_of_parameters</code></a> function.  In this case, we have four parameters <span>$a, b, a_0, u_0$</span>.  This method must be defined for all models.</p><pre><code class="language-julia hljs">number_of_parameters(::Type{&lt;:MyPeters}) = 4</code></pre><p>To indicate whether we plan to use in-place or out-of-place functions, we define a new method for the <a href="@ref"><code>inplaceness</code></a> function.  This method must be defined for all models.</p><pre><code class="language-julia hljs">inplaceness(::Type{&lt;:MyPeters}) = OutOfPlace()</code></pre><p>To indicate mass matrix properties, we define a new method for the <a href="@ref"><code>mass_matrix_type</code></a> function.  This method must be defined for all models.</p><pre><code class="language-julia hljs">mass_matrix_type(::Type{&lt;:MyPeters}) = Constant()</code></pre><p>To indicate the properties of the jacobian of the state rates with respect to the state variables, we define a new method for the <a href="@ref"><code>state_jacobian_type</code></a> function.</p><pre><code class="language-julia hljs">state_jacobian_type(::Type{&lt;:MyPeters}) = Linear()</code></pre><p>To indicate the properties of the jacobian of the state rates with respect to the inputs, we define a new method for the <a href="@ref"><code>input_jacobian_type</code></a> function.</p><pre><code class="language-julia hljs">input_jacobian_type(::Type{&lt;:MyPeters}) = Nonlinear()</code></pre><h3 id="Defining-Model-Methods-2"><a class="docs-heading-anchor" href="#Defining-Model-Methods-2">Defining Model Methods</a><a class="docs-heading-anchor-permalink" href="#Defining-Model-Methods-2" title="Permalink"></a></h3><p>Now that we have defined the properties of our model, we need to define the governing equations for its state variables.</p><p>The right hand side of the governing differential equations is calculated using the <a href="../interface/#AerostructuralDynamics.get_rates"><code>get_rates</code></a> function for out-of-place models and <a href="../interface/#AerostructuralDynamics.get_rates!"><code>get_rates!</code></a> function for in-place models.  </p><pre><code class="language-julia hljs">function get_rates(model::MyPeters{N,TF,SV,SA}, x, y, p, t) where {N,TF,SV,SA}
    # extract aerodynamic states as statically sized vector
    λ = SVector{N}(x)
    # extract inputs
    u, ω, vdot, ωdot = y
    # extract parameters
    a, b, a0, α0 = p
    # extract model constants
    cbar = model.c
    # calculate rates
    return cbar*(vdot + u*ω + (b/2-a*b)*ωdot) - u/b*λ
end</code></pre><p>Since our model uses a mass matrix, we also need to define a new method for the <a href="../interface/#AerostructuralDynamics.get_mass_matrix"><code>get_mass_matrix</code></a> function (or <a href="../interface/#AerostructuralDynamics.get_mass_matrix!"><code>get_mass_matrix!</code></a> if the model&#39;s functions are in-place functions).  For constant mass matrices, this function is defined without the <code>x</code>, <code>y</code>, <code>p</code>, and <code>t</code> arguments.  </p><pre><code class="language-julia hljs">get_mass_matrix(model::MyPeters) = model.A</code></pre><h3 id="Performance-Overloads-2"><a class="docs-heading-anchor" href="#Performance-Overloads-2">Performance Overloads</a><a class="docs-heading-anchor-permalink" href="#Performance-Overloads-2" title="Permalink"></a></h3><p>The code we have presented so far fully defines the governing equations for the aerodynamic state variables of the Peters&#39; finite state model.  At this point, we can either provide custom definitions for the jacobians associated with these governing equations, or allow the jacobians to be calculated using forward automatic differentiation (enabled by the <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff</a> package).</p><p>The jacobian of the right hand side of the governing equations with respect to the state variables may be defined using the <a href="../interface/#AerostructuralDynamics.get_state_jacobian"><code>get_state_jacobian</code></a> function for out-of-place models and <a href="../interface/#AerostructuralDynamics.get_state_jacobian!"><code>get_state_jacobian!</code></a> function for in-place models.</p><pre><code class="language-julia hljs">function get_state_jacobian(model::MyPeters, x, y, p, t)
    # extract inputs
    u, ω, vdot, ωdot = y
    # extract parameters
    a, b, a0, α0 = p
    # extract model constants
    cbar = model.c
    # jacobian with respect to aerodynamic states
    return -u/b*Diagonal(one.(cbar))
end</code></pre><p>The jacobian of the right hand side of the governing equations with respect to the inputs is defined using the <a href="@ref"><code>get_input_jacobian</code></a> function.  </p><pre><code class="language-julia hljs">function get_input_jacobian(model::MyPeters, x, y, p, t)
    # extract aerodynamic states as statically sized vector
    λ = SVector{N}(x)
    # extract inputs
    u, ω, vdot, ωdot = y
    # extract parameters
    a, b, a0, α0 = p
    # extract model constants
    cbar = model.c
    # return jacobian
    return hcat(cbar*ω - λ/b, u*cbar, cbar, (b/2-a*b)*cbar)
end</code></pre><h3 id="Aerodynamic-Model-Code"><a class="docs-heading-anchor" href="#Aerodynamic-Model-Code">Aerodynamic Model Code</a><a id="Aerodynamic-Model-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Aerodynamic-Model-Code" title="Permalink"></a></h3><p>Putting it all together, a complete representation Peters&#39; finite state aerodynamic model may be defined using the following block of code.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    MyPeters{N,TF,SV,SA} &lt;: AbstractModel

Peter&#39;s finite state model with `N` state variables, inputs ``u, \\omega,
\\dot{v}, \\dot{\\omega}`` and parameters ``a, b, a_0, \\alpha_0``
&quot;&quot;&quot;
struct MyPeters{N,TF,TV&lt;:SVector{N,TF},TA&lt;:SMatrix{N,N,TF}} &lt;: AbstractModel
    A::TA
    b::TV
    c::TV
end

# --- Constructors --- #

&quot;&quot;&quot;
    MyPeters{N,TF=Float64}()

Initialize an object of type `MyPeters` which has `N` aerodynamic
degrees of freedom.
&quot;&quot;&quot;
MyPeters{N}() where N = MyPeters{N,Float64}()

function MyPeters{N,TF}() where {N,TF}

    b = zeros(TF, N)
    for n = 1:N-1
        b[n] = (-1)^(n-1)*factorial(big(N + n - 1))/factorial(big(N - n - 1))*
            1/factorial(big(n))^2
    end
    b[N] = (-1)^(N-1)

    c = zeros(TF, N)
    for n = 1:N
        c[n] = 2/n
    end

    d = zeros(TF, N)
    d[1] = 1/2

    D = zeros(TF, N, N)
    for m in 1:N-1
        n = m + 1
        D[n, m] = 1/(2*n)
    end
    for m in 2:N
        n = m - 1
        D[n, m] = -1/(2*n)
    end

    A = D + d*b&#39; + c*d&#39; + 1/2*c*b&#39;

    return MyPeters(SMatrix{N,N,TF}(A), SVector{N,TF}(b), SVector{N,TF}(c))
end

# --- Traits --- #

number_of_states(::Type{MyPeters{N,TF,SV,SA}}) where {N,TF,SV,SA} = N
number_of_inputs(::Type{&lt;:MyPeters}) = 4
number_of_parameters(::Type{&lt;:MyPeters}) = 4
inplaceness(::Type{&lt;:MyPeters}) = OutOfPlace()
mass_matrix_type(::Type{&lt;:MyPeters}) = Constant()
state_jacobian_type(::Type{&lt;:MyPeters}) = Linear()
input_jacobian_type(::Type{&lt;:MyPeters}) = Nonlinear()

# --- Methods --- #

function get_rates(model::MyPeters{N,TF,SV,SA}, x, y, p, t) where {N,TF,SV,SA}
    # extract aerodynamic states as statically sized vector
    λ = SVector{N}(x)
    # extract inputs
    u, ω, vdot, ωdot = y
    # extract parameters
    a, b, a0, α0 = p
    # extract model constants
    cbar = model.c
    # calculate rates
    return cbar*(vdot + u*ω + (b/2-a*b)*ωdot) - u/b*λ
end

get_mass_matrix(model::MyPeters) = model.A

# --- Performance Overloads --- #

function get_state_jacobian(model::MyPeters, x, y, p, t)
    # extract inputs
    u, ω, vdot, ωdot = y
    # extract parameters
    a, b, a0, α0 = p
    # extract model constants
    cbar = model.c
    # jacobian with respect to aerodynamic states
    return -u/b*Diagonal(one.(cbar))
end

function get_input_jacobian(model::MyPeters, x, y, p, t)
    # extract aerodynamic states as statically sized vector
    λ = SVector{N}(x)
    # extract inputs
    u, ω, vdot, ωdot = y
    # extract parameters
    a, b, a0, α0 = p
    # extract model constants
    cbar = model.c
    # return jacobian
    return hcat(cbar*ω - λ/b, u*cbar, cbar, (b/2-a*b)*cbar)
end</code></pre><h2 id="Aeroelastic-Model-2"><a class="docs-heading-anchor" href="#Aeroelastic-Model-2">Aeroelastic Model</a><a class="docs-heading-anchor-permalink" href="#Aeroelastic-Model-2" title="Permalink"></a></h2><p>To form a new aeroelastic model, we will be coupling Peters&#39; finite state model with the typical section structural model.</p><h3 id="Theory-3"><a class="docs-heading-anchor" href="#Theory-3">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-3" title="Permalink"></a></h3><p>State variables for all models (including coupled models) in this package satisfy the ordinary differential equation (or differential algebraic equation in mass matrix form)</p><p class="math-container">\[M(x,y,p,t)\dot{x} = f(x,y,p,t)\]</p><p>where <span>$M(x, y, p, t)$</span> is a function which defines the mass matrix corresponding to the differential equation, <span>$f(x, y, p, t)$</span> is a function which defines the mass matrix multiplied state rates, <span>$x$</span> is a vector of states, <span>$y$</span> is a vector of inputs (coupling variables), <span>$p$</span> is a vector of parameters, and <span>$t$</span> is the current time.</p><p>We assume the state variables of the coupled model correspond to the state variables of all of its subcomponent models concatenated, the inputs of the coupled model correspond to the inputs of all of its subcomponent models concatenated, and the parameters of the coupled model correspond to the parameters of all of its subcomponent models concatenated, followed by an additional set of parameters.</p><p class="math-container">\[x = \begin{Bmatrix} x_\text{aero} \\ x_\text{stru} \end{Bmatrix} \quad
y = \begin{Bmatrix} y_\text{aero} \\ y_\text{stru} \end{Bmatrix} \quad
p = \begin{Bmatrix} p_\text{aero} \\ p_\text{stru} \\ p_\text{additional} \end{Bmatrix}\]</p><p>We also assume the inputs for the coupled model may be expressed as a function of the coupled model&#39;s state variables and parameters, as well as the current time.  This assumption allows the state variables and parameters from each coupled model to influence the governing differential equations of the other coupled models through their input variables.</p><p class="math-container">\[y = g(x, p, t) = \begin{Bmatrix} g_\text{aero}(x, p, t) \\ g_\text{stru}(x, p, t) \end{Bmatrix}\]</p><p>If the state rates of the coupled model are linearly dependent on the inputs, the definition of the inputs of the coupled model may be expanded to include a linear dependency on the coupled model&#39;s state rates.  Since this term will eventually be moved to the left side of the governing differential equations for the coupled model, we define it as a negative quantity.</p><p class="math-container">\[y = g(x, p, t) - M_y(x,p,t) \dot{x} =
\begin{Bmatrix}
g_\text{aero}(x, p, t) - M_{y,\text{aero}}(x,p,t) \dot{x} \\
g_\text{stru}(x, p, t) - M_{y,\text{stru}}(x,p,t) \dot{x}
\end{Bmatrix}\]</p><p>With these assumptions, the coupled system of equations may be defined as</p><p class="math-container">\[M(x,p,t) \dot{x} = f(x,p,t)\]</p><p class="math-container">\[M = \begin{bmatrix}
    M_\text{aero} &amp; 0 \\
    0 &amp; M_\text{stru}
\end{bmatrix} +
\begin{bmatrix}
    \frac{\partial f_\text{aero}}{\partial y_\text{aero}} &amp; 0 \\
    0 &amp; \frac{\partial f_\text{stru}}{\partial y_\text{stru}}
\end{bmatrix}
\begin{bmatrix}
    M_{y,\text{aero}} \\
    M_{y,\text{stru}}
\end{bmatrix} \quad\]</p><p>and the associated jacobian is</p><p class="math-container">\[\frac{\partial f_x}{\partial x} = \begin{bmatrix}
\frac{\partial f_\text{aero}}{\partial x_\text{aero}} &amp; 0 \\
0 &amp; \frac{\partial f_\text{stru}}{\partial x_\text{stru}}
\end{bmatrix} +
\begin{bmatrix}
    \frac{\partial f_\text{aero}}{\partial y_\text{aero}} &amp; 0 \\
    0 &amp; \frac{\partial f_\text{stru}}{\partial y_\text{stru}}
\end{bmatrix}
\begin{bmatrix}
    \frac{\partial g_\text{aero}}{\partial x_\text{aero}} &amp;
    \frac{\partial g_\text{aero}}{\partial x_\text{stru}} \\
    \frac{\partial g_\text{stru}}{\partial x_\text{aero}} &amp;
    \frac{\partial g_\text{stru}}{\partial x_\text{stru}}
\end{bmatrix}\]</p><h4 id="Aerodynamic-Model-Inputs-2"><a class="docs-heading-anchor" href="#Aerodynamic-Model-Inputs-2">Aerodynamic Model Inputs</a><a class="docs-heading-anchor-permalink" href="#Aerodynamic-Model-Inputs-2" title="Permalink"></a></h4><p>The freestream velocity components <span>$u$</span> and <span>$v$</span> are assumed to be aligned with the undeflected chordwise and normal directions, respectively, so that</p><p class="math-container">\[u \approx U_\infty \\
v \approx \dot{h} \\
\omega \approx \dot{\theta}\]</p><p>where <span>$U_\infty$</span> is the freestream velocity magnitude, <span>$\theta$</span> is pitch, and <span>$h$</span> is plunge. To capture the effect of twist on the circulatory lift (since it is no longer implicitly modeled by the <span>$\frac{v}{u}$</span> quantity) twist is added to the effective angle of attack from Peter&#39;s finite state model so that the effective angle of attack is now given by</p><p class="math-container">\[\alpha_\text{eff} = \theta - \frac{v}{u} + \frac{b}{u}\left( \frac{1}{2} - a \right) \omega  + \frac{\lambda_0}{u} - \alpha_0\]</p><p>The original expression for the effective angle of attack may be used by defining the new variable <span>$\bar{v} = u \theta + v$</span> such that</p><p class="math-container">\[\alpha_\text{eff} = -\frac{\bar{v}}{u} + \frac{b}{u}\left( \frac{1}{2} - a \right) \omega + \frac{\lambda_0}{u} - \alpha_0\]</p><p>With these assumptions, the inputs for Peters&#39; finite state model are</p><p class="math-container">\[u = U_\infty \\
\omega = \dot{\theta} \\
\dot{v} = \ddot{h} \\
\dot{\omega} = \ddot{\theta}\]</p><h4 id="Structural-Model-Inputs-2"><a class="docs-heading-anchor" href="#Structural-Model-Inputs-2">Structural Model Inputs</a><a class="docs-heading-anchor-permalink" href="#Structural-Model-Inputs-2" title="Permalink"></a></h4><p>A small angle assumption is also used to define the lift about the reference location as</p><p class="math-container">\[\mathcal{L} \approx \mathcal{N}\]</p><p>where <span>$\mathcal{N}$</span> is the normal force per unit span at the reference location.</p><p>With this assumption, the inputs for the typical section model is</p><p class="math-container">\[\mathcal{L} = a_0 \rho_\infty u^2 b \alpha_\text{eff} + \pi \rho b^2 \left(-\dot{v} + u\omega - a b \dot{\omega} \right) \\
\mathcal{M} = -\pi \rho_\infty b^3 \left[ -\frac{1}{2}\dot{v} + u\omega + b \left( \frac{1}{8} - \frac{a}{2} \right) \dot{\omega} \right] + b \left(\frac{1}{2} + a \right) \mathcal{L}\]</p><p>where</p><p class="math-container">\[\alpha = \theta - \frac{v}{u} + \frac{b}{u}\left( \frac{1}{2} - a \right) \omega + \frac{\lambda_0}{u} - \alpha_0\]</p><p>and</p><p class="math-container">\[\lambda_0 \approx \frac{1}{2} \sum_{n=1}^N b_n \lambda_n\]</p><h3 id="Defining-the-Coupled-Model-2"><a class="docs-heading-anchor" href="#Defining-the-Coupled-Model-2">Defining the Coupled Model</a><a class="docs-heading-anchor-permalink" href="#Defining-the-Coupled-Model-2" title="Permalink"></a></h3><p>To define the coupled model, we define a new method for the <a href="../couplings/liftingline-gxbeam-rigidbody/#AerostructuralDynamics.couple_models-Tuple{LiftingLine, GEBT, RigidBody}"><code>couple_models</code></a> function.  This method should just return a tuple of models in the order in which their state variables, inputs, and parameters are defined.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    couple_models(aero::Peters, stru::TypicalSection)

Create an aerostructural model using the unsteady aerodynamic model defined by
Peters et al. and a two-degree of freedom typical section model.  This model
introduces the freestream velocity ``U_\\infty`` and air density ``\\rho_\\infty``
as additional parameters.
&quot;&quot;&quot;
couple_models(aero::MyPeters, stru::MyTypicalSection) = (aero, stru)</code></pre><h3 id="Defining-Input-Function-Properties-2"><a class="docs-heading-anchor" href="#Defining-Input-Function-Properties-2">Defining Input Function Properties</a><a class="docs-heading-anchor-permalink" href="#Defining-Input-Function-Properties-2" title="Permalink"></a></h3><p>Before we define the combined input function (and its associated functions) we need to define a few of its properties.</p><p>To define whether the combined input function should use an in-place or out-of-place format, we define a new method for the <a href="@ref"><code>inplaceness</code></a> function.</p><pre><code class="language-julia hljs">inplaceness(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = OutOfPlace()</code></pre><p>To indicate input function mass matrix properties, we define a new method for the <a href="@ref"><code>mass_matrix_type</code></a> function.</p><pre><code class="language-julia hljs">mass_matrix_type(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = Linear()</code></pre><p>To indicate the properties of the input function jacobian with respect to the state variables, we define a new method for the <a href="@ref"><code>state_jacobian_type</code></a> function.</p><pre><code class="language-julia hljs">state_jacobian_type(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = Nonlinear()</code></pre><p>To define the number of additional parameters introduced by this model, we define a new method for the <a href="../interface/#AerostructuralDynamics.number_of_parameters"><code>number_of_parameters</code></a> function.</p><pre><code class="language-julia hljs">number_of_parameters(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = 2
nothing</code></pre><h3 id="Defining-Input-Function-Methods-2"><a class="docs-heading-anchor" href="#Defining-Input-Function-Methods-2">Defining Input Function Methods</a><a class="docs-heading-anchor-permalink" href="#Defining-Input-Function-Methods-2" title="Permalink"></a></h3><p>The portion of the inputs which is independent of the state rates is calculated using the <a href="../interface/#AerostructuralDynamics.get_inputs"><code>get_inputs</code></a> function for out-of-place aerodynamic load calculations and <a href="../interface/#AerostructuralDynamics.get_inputs!"><code>get_inputs!</code></a> function for in-place aerodynamic load calculations.</p><pre><code class="language-julia hljs">function get_inputs(aero::MyPeters{N,TF,SV,SA}, stru::MyTypicalSection,
    s, p, t) where {N,TF,SV,SA}
    # extract state variables
    λ = s[SVector{N}(1:N)]
    h, θ, hdot, θdot = s[SVector{4}(N+1:N+4)]
    # extract parameters
    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p
    # extract model constants
    bbar = aero.b
    # local freestream velocity components
    u = U
    vbar = U*θ + hdot
    ω = θdot
    # circulatory load factor
    tmp1 = a0*ρ*u*b
    # non-circulatory load factor
    tmp2 = pi*ρ*b^3
    # constant based on geometry
    d = b/2 - a*b
    # induced flow velocity
    λ0 = 1/2 * bbar&#39;*λ
    # lift at reference point
    L = tmp1*(vbar + d*ω - λ0 - u*α0) + tmp2*u/b*ω
    # moment at reference point
    M = -tmp2*u*ω + (b/2 + a*b)*L
    # return portion of inputs that is not dependent on the state rates
    return SVector(u, ω, 0, 0, L, M)
end</code></pre><p>For out-of-place input functions, the mass matrix is calculated using the <a href="../interface/#AerostructuralDynamics.get_input_mass_matrix"><code>AerostructuralDynamics.get_input_mass_matrix</code></a> function.  For in-place combined input functions, the mass matrix is calculated using the <a href="../interface/#AerostructuralDynamics.get_input_mass_matrix!"><code>AerostructuralDynamics.get_input_mass_matrix!</code></a> function.  For constant mass matrices, these functions are called without the <code>u</code>, <code>p</code>, and <code>t</code> arguments.</p><pre><code class="language-julia hljs">function get_input_mass_matrix(aero::MyPeters{N,TF,SV,SA},
    stru::MyTypicalSection, s, p, t) where {N,TF,SV,SA}
    # extract parameters
    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p
    # local freestream velocity components
    vdot_dhdot = 1
    ωdot_dθdot = 1
    # non-circulatory load factor
    tmp = pi*ρ*b^3
    # lift at reference point
    L_dhdot = tmp/b
    L_dθdot = -tmp*a
    # moment at reference point
    M_dhdot = -tmp/2 + (b/2 + a*b)*L_dhdot
    M_dθdot = -tmp*(b/8 - a*b/2) + (b/2 + a*b)*L_dθdot
    # construct submatrices
    Mda = zeros(SMatrix{4,N,TF})
    Mds = @SMatrix [0 0 0 0; 0 0 0 0; 0 0 -vdot_dhdot 0; 0 0 0 -ωdot_dθdot]
    Mra = zeros(SMatrix{2,N,TF})
    Mrs = @SMatrix [0 0 -L_dhdot -L_dθdot; 0 0 -M_dhdot -M_dθdot]
    # assemble mass matrix
    return [Mda Mds; Mra Mrs]
end</code></pre><h3 id="Input-Function-Performance-Overloads-2"><a class="docs-heading-anchor" href="#Input-Function-Performance-Overloads-2">Input Function Performance Overloads</a><a class="docs-heading-anchor-permalink" href="#Input-Function-Performance-Overloads-2" title="Permalink"></a></h3><p>The jacobian of <span>$f_y$</span> with respect to the state variables is calculated using the <a href="../interface/#AerostructuralDynamics.get_input_state_jacobian"><code>AerostructuralDynamics.get_input_state_jacobian</code></a> function for out-of-place combined input functions and <a href="../interface/#AerostructuralDynamics.get_input_state_jacobian!"><code>AerostructuralDynamics.get_input_state_jacobian!</code></a> function for in-place combined inputs functions.</p><pre><code class="language-julia hljs">function get_input_state_jacobian(aero::MyPeters{N,TF,SV,SA},
    stru::MyTypicalSection, s, p, t) where {N,TF,SV,SA}
    # extract parameters
    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p
    # extract model constants
    bbar = aero.b
    # local freestream velocity components
    ω_θdot = 1
    # calculate aerodynamic loads
    L_λ = -a0*ρ*u*b/2*bbar&#39;
    M_λ = (b/2 + a*b)*L_λ
    L_θ = a0*ρ*u^2*b
    M_θ = (b/2 + a*b)*L_θ
    L_hdot = a0*ρ*u*b
    M_hdot = (b/2 + a*b)*L_hdot
    L_θdot = a0*ρ*u*b*(b/2 - a*b) + pi*ρ*b^2*u
    M_θdot = -pi*ρ*b^3*u + (b/2 + a*b)*L_θdot
    # construct sub-matrices
    Jda = zeros(SMatrix{4,N,TF}) # d(d)/d(dλ)
    Jds = @SMatrix [0 0 0 0; 0 0 0 ω_θdot; 0 0 0 0; 0 0 0 0]
    Jra = [L_λ; M_λ]
    Jrs = @SMatrix [0 L_θ L_hdot L_θdot; 0 M_θ M_hdot M_θdot]
    # return jacobian
    return [Jda Jds; Jra Jrs]
end</code></pre><h3 id="Coupled-Model-Code-2"><a class="docs-heading-anchor" href="#Coupled-Model-Code-2">Coupled Model Code</a><a class="docs-heading-anchor-permalink" href="#Coupled-Model-Code-2" title="Permalink"></a></h3><p>Putting it all together, a complete representation of the input function associated with our coupled model may be defined using the following block of code.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    couple_models(aero::Peters, stru::TypicalSection)

Create an aerostructural model using the unsteady aerodynamic model defined by
Peters et al. and a two-degree of freedom typical section model.  This model
introduces the freestream velocity ``U_\\infty`` and air density ``\\rho_\\infty``
as additional parameters.
&quot;&quot;&quot;
couple_models(aero::MyPeters, stru::MyTypicalSection) = (aero, stru)

# --- traits --- #

inplaceness(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = OutOfPlace()
mass_matrix_type(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = Linear()
state_jacobian_type(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = Nonlinear()
number_of_parameters(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = 2

# --- methods --- #

function get_inputs(aero::MyPeters{N,TF,SV,SA}, stru::MyTypicalSection,
    s, p, t) where {N,TF,SV,SA}
    # extract state variables
    λ = s[SVector{N}(1:N)]
    h, θ, hdot, θdot = s[SVector{4}(N+1:N+4)]
    # extract parameters
    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p
    # extract model constants
    bbar = aero.b
    # local freestream velocity components
    u = U
    vbar = U*θ + hdot
    ω = θdot
    # circulatory load factor
    tmp1 = a0*ρ*u*b
    # non-circulatory load factor
    tmp2 = pi*ρ*b^3
    # constant based on geometry
    d = b/2 - a*b
    # induced flow velocity
    λ0 = 1/2 * bbar&#39;*λ
    # lift at reference point
    L = tmp1*(vbar + d*ω - λ0 - u*α0) + tmp2*u/b*ω
    # moment at reference point
    M = -tmp2*u*ω + (b/2 + a*b)*L
    # return portion of inputs that is not dependent on the state rates
    return SVector(u, ω, 0, 0, L, M)
end


function get_input_mass_matrix(aero::MyPeters{N,TF,SV,SA},
    stru::MyTypicalSection, s, p, t) where {N,TF,SV,SA}
    # extract parameters
    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p
    # local freestream velocity components
    vdot_dhdot = 1
    ωdot_dθdot = 1
    # non-circulatory load factor
    tmp = pi*ρ*b^3
    # lift at reference point
    L_dhdot = tmp/b
    L_dθdot = -tmp*a
    # moment at reference point
    M_dhdot = -tmp/2 + (b/2 + a*b)*L_dhdot
    M_dθdot = -tmp*(b/8 - a*b/2) + (b/2 + a*b)*L_dθdot
    # construct submatrices
    Mda = zeros(SMatrix{4,N,TF})
    Mds = @SMatrix [0 0 0 0; 0 0 0 0; 0 0 -vdot_dhdot 0; 0 0 0 -ωdot_dθdot]
    Mra = zeros(SMatrix{2,N,TF})
    Mrs = @SMatrix [0 0 -L_dhdot -L_dθdot; 0 0 -M_dhdot -M_dθdot]
    # assemble mass matrix
    return [Mda Mds; Mra Mrs]
end

# --- performance overloads --- #

function get_input_state_jacobian(aero::MyPeters{N,TF,SV,SA},
    stru::MyTypicalSection, s, p, t) where {N,TF,SV,SA}
    # extract parameters
    a, b, a0, α0, kh, kθ, m, Sθ, Iθ, U, ρ = p
    # extract model constants
    bbar = aero.b
    # local freestream velocity components
    ω_θdot = 1
    # calculate aerodynamic loads
    L_λ = -a0*ρ*u*b/2*bbar&#39;
    M_λ = (b/2 + a*b)*L_λ
    L_θ = a0*ρ*u^2*b
    M_θ = (b/2 + a*b)*L_θ
    L_hdot = a0*ρ*u*b
    M_hdot = (b/2 + a*b)*L_hdot
    L_θdot = a0*ρ*u*b*(b/2 - a*b) + pi*ρ*b^2*u
    M_θdot = -pi*ρ*b^3*u + (b/2 + a*b)*L_θdot
    # construct sub-matrices
    Jda = zeros(SMatrix{4,N,TF}) # d(d)/d(dλ)
    Jds = @SMatrix [0 0 0 0; 0 0 0 ω_θdot; 0 0 0 0; 0 0 0 0]
    Jra = [L_λ; M_λ]
    Jrs = @SMatrix [0 L_θ L_hdot L_θdot; 0 M_θ M_hdot M_θdot]
    # return jacobian
    return [Jda Jds; Jra Jrs]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">get_input_state_jacobian (generic function with 1 method)</code></pre><h3 id="Example-Usage-2"><a class="docs-heading-anchor" href="#Example-Usage-2">Example Usage</a><a class="docs-heading-anchor-permalink" href="#Example-Usage-2" title="Permalink"></a></h3><pre><code class="language- hljs">using AerostructuralDynamics, LinearAlgebra

# reduced velocity range
V = range(0, 3.1, length=5000) # = U/(b*ωθ) (reduced velocity)

# non-dimensional parameters
a = -1/5 # reference point normalized location
e = -1/10 # center of mass normalized location
μ = 20 # = m/(ρ*pi*b^2) (mass ratio)
r2 = 6/25 # = Iθ/(m*b^2) (radius of gyration about P)
σ = 2/5 # = ωh/ωθ (natural frequency ratio)
xθ = e - a
a0 = 2*pi # lift curve slope
α0 = 0 # zero lift angle

# chosen dimensional parameters
b = 1
ρ = 1
ωθ = 1

# derived dimensional parameters
m = μ*ρ*pi*b^2
Sθ = m*xθ*b
Iθ = r2*m*b^2
ωh = σ*ωθ
kh = m*ωh^2
kθ = Iθ*ωθ^2

# dimensionalized velocity
U = V*b*ωθ

# aerodynamic models
aerodynamic_model = MyPeters{6}()

# structural model
structural_model = MyTypicalSection()

# coupled model
model = couple_models(aerodynamic_model, structural_model)

# eigenvalue storage
λ = zeros(ComplexF64, number_of_states(model), length(V))

# loop through each reduced frequency
for i = 1:length(V)
    # state variables
    u_aero = zeros(number_of_states(aerodynamic_model))
    u_stru = zeros(number_of_states(structural_model))
    u = vcat(u_aero, u_stru)

    # parameters
    p_aero = [a, b, a0, α0]
    p_stru = [kh, kθ, m, Sθ, Iθ]
    p_input = [U[i], ρ]
    p = vcat(p_aero, p_stru, p_input)

    # time
    t = 0.0

    # calculate inputs
    y = get_inputs(model, u, p, t)

    # perform linear stability analysis
    λ[:,i], Uλ, Vλ = get_eigen(model, u, y, p, t)
end

nothing #hide</code></pre><pre><code class="language- hljs">using Plots
pyplot()

default(
    titlefontsize = 14,
    legendfontsize = 11,
    guidefontsize = 14,
    tickfontsize = 11,
    foreground_color_legend = nothing,
    background_color_legend = nothing,
    minorgrid=true,
    framestyle = :zerolines)

sp1 = plot(
    title = &quot;Non-Dimensional Frequency&quot;,
    xlim = (0,3.1),
    xtick = 0.0:0.5:3.0,
    xlabel = &quot;\$ \\frac{U}{b \\omega_\\theta} \$&quot;,
    ylim = (0, 1.05),
    ytick = 0.0:0.2:1.0,
    ylabel = &quot;\$ \\frac{\\Omega}{\\omega_\\theta} \$&quot;,
    legend = :topright
    )

sp2 = plot(
    title = &quot;Non-Dimensional Damping&quot;,
    xlim = (0,3.1),
    xtick = 0.0:0.5:3.0,
    xlabel = &quot;\$ \\frac{U}{b \\omega_\\theta} \$&quot;,
    ylim = (-0.7, 0.605),
    ytick = -0.6:0.2:0.6,
    ylabel = &quot;\$ \\frac{Γ}{\\omega_\\theta} \$&quot;,
    legend = :topleft
    )

for i = 1:size(λ, 1)
    scatter!(sp1, V, imag.(λ[i,:])/ωθ,
        label = &quot;&quot;,
        color = 1,
        markersize = 1,
        markerstrokewidth = 0,
        )
end

for i = 1:size(λ, 1)
    scatter!(sp2, V, real.(λ[i,:])/ωθ,
        label = &quot;&quot;,
        color = 1,
        markersize = 1,
        markerstrokewidth = 0,
        )
end

p1 = plot(sp1, sp2, layout = (2, 1), size = (600, 800))

savefig(p1, &quot;example-stability.svg&quot;) #hide

nothing #hide</code></pre><p><img src="example-stability.svg" alt/></p><h2 id="Model-Ordering-2"><a class="docs-heading-anchor" href="#Model-Ordering-2">Model Ordering</a><a class="docs-heading-anchor-permalink" href="#Model-Ordering-2" title="Permalink"></a></h2><p>In general, we suggest that the following ordering of model state variables, inputs, and parameters is used when constructing input functions.</p><ol><li>Aerodynamics</li><li>Structural</li><li>Rigid Body (when present)</li></ol><h2 id="Avoiding-Mass-Matrices-2"><a class="docs-heading-anchor" href="#Avoiding-Mass-Matrices-2">Avoiding Mass Matrices</a><a class="docs-heading-anchor-permalink" href="#Avoiding-Mass-Matrices-2" title="Permalink"></a></h2><p>In order to take advantage of as many features of the DifferentialEquations package as possible (including local sensitivity analysis), at this point in time we recommend that the governing differential equations for models be reformulated to avoid using mass matrices whenever possible.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« Interface</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 28 July 2021 00:01">Wednesday 28 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
