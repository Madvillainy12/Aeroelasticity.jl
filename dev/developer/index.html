<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developer Guide · AerostructuralDynamics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AerostructuralDynamics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../theory/">Theory</a></li><li class="is-active"><a class="tocitem" href>Developer Guide</a><ul class="internal"><li><a class="tocitem" href="#Defining-a-Structural-Model"><span>Defining a Structural Model</span></a></li><li><a class="tocitem" href="#Defining-an-Aerodynamic-Model"><span>Defining an Aerodynamic Model</span></a></li><li><a class="tocitem" href="#Coupling-Aerodynamic-and-Structural-Models"><span>Coupling Aerodynamic and Structural Models</span></a></li><li><a class="tocitem" href="#Model-Ordering"><span>Model Ordering</span></a></li><li><a class="tocitem" href="#Avoiding-Mass-Matrices"><span>Avoiding Mass Matrices</span></a></li></ul></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Developer Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Developer Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/AerostructuralDynamics.jl/blob/master/docs/src/developer.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Developer&#39;s-Guide"><a class="docs-heading-anchor" href="#Developer&#39;s-Guide">Developer&#39;s Guide</a><a id="Developer&#39;s-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Developer&#39;s-Guide" title="Permalink"></a></h1><p>In this guide we demonstrate by example how to define aerodynamic and structural models and couple them together.</p><ul><li><a href="#Developer&#39;s-Guide">Developer&#39;s Guide</a></li><ul><li><a href="#Defining-a-Structural-Model">Defining a Structural Model</a></li><ul><li><a href="#Theory">Theory</a></li><li><a href="#Defining-a-New-Type">Defining a New Type</a></li><li><a href="#Defining-Model-Properties">Defining Model Properties</a></li><li><a href="#Mass-Matrix-Equation">Mass Matrix Equation</a></li><li><a href="#State-Rate-Equation">State Rate Equation</a></li><li><a href="#State-Rate-Jacobian">State Rate Jacobian</a></li><li><a href="#Input-Jacobian">Input Jacobian</a></li><li><a href="#Structural-Model-Code">Structural Model Code</a></li></ul><li><a href="#Defining-an-Aerodynamic-Model">Defining an Aerodynamic Model</a></li><ul><li><a href="#Theory-2">Theory</a></li><li><a href="#Defining-a-New-Type-2">Defining a New Type</a></li><li><a href="#Defining-Model-Properties-2">Defining Model Properties</a></li><li><a href="#Mass-Matrix-Equation-2">Mass Matrix Equation</a></li><li><a href="#State-Rate-Equation-2">State Rate Equation</a></li><li><a href="#State-Rate-Jacobian-2">State Rate Jacobian</a></li><li><a href="#Structural-Deflection-Jacobian">Structural Deflection Jacobian</a></li><li><a href="#Aerodynamic-Model-Code">Aerodynamic Model Code</a></li></ul><li><a href="#Coupling-Aerodynamic-and-Structural-Models">Coupling Aerodynamic and Structural Models</a></li><ul><li><a href="#Theory-3">Theory</a></li><li><a href="#Defining-Input-Function-Properties">Defining Input Function Properties</a></li><li><a href="#Input-Mass-Matrix-Equation">Input Mass Matrix Equation</a></li><li><a href="#Input-Equation">Input Equation</a></li><li><a href="#Input-Jacobian-2">Input Jacobian</a></li></ul><li><a href="#Model-Ordering">Model Ordering</a></li><li><a href="#Avoiding-Mass-Matrices">Avoiding Mass Matrices</a></li></ul></ul><h2 id="Defining-a-Structural-Model"><a class="docs-heading-anchor" href="#Defining-a-Structural-Model">Defining a Structural Model</a><a id="Defining-a-Structural-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-Structural-Model" title="Permalink"></a></h2><p>For demonstrating how to create a new structural model, we use a typical section model with two degrees of freedom, as shown in the following figure.</p><p><img src="../typical-section.svg" alt/></p><p>The equations of motion for this model are:</p><p class="math-container">\[m \left(\ddot{h}+b x_\theta \ddot{\theta} \right) + k_h h = -L \\
I_P \ddot{\theta} + m b x_\theta \ddot{h} + k_\theta = M\]</p><p>where <span>$a$</span> is the normalized distance from the semichord to the reference point, <span>$b$</span> is the semichord length, <span>$k_h$</span> is the linear spring constant, <span>$k_\theta$</span> is the torsional spring constant, <span>$m$</span> is the mass per unit span, <span>$x_\theta$</span> is the distance to the center of mass from the reference point, <span>$I_P$</span> is the moment of inertia about the reference point, <span>$L$</span> is the lift per unit span, and <span>$M_\frac{1}{4}$</span> is the quarter-chord moment per unit span.</p><h3 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h3><p>Structural state variables in this package satisfy the ordinary differential equation (or differential algebraic equation in mass matrix form)</p><p class="math-container">\[M_s(q,r,p_s,t)\dot{q} = f_s(q,r,p_s,t)\]</p><p>where <span>$M_s$</span> is a function which defines the structural mass matrix, <span>$f_s$</span> is a function which defines the mass matrix multiplied structural state rates, <span>$q$</span> is a vector of structural states, <span>$r$</span> is a vector of aerodynamic loads, <span>$p_s$</span> is a vector of structural parameters, and <span>$t$</span> is the current time.</p><p>The equations of motion for the typical section model when expressed in the form expected by this package are</p><p class="math-container">\[M \dot{q} = K q + D r\]</p><p>where</p><p class="math-container">\[q = \begin{bmatrix} h &amp; \theta &amp; \dot{h} &amp; \dot{\theta} \end{bmatrix}^T \quad
r = \begin{bmatrix} L &amp; M_\frac{1}{4} \end{bmatrix}^T\]</p><p class="math-container">\[M =
\begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; m &amp; m b x_\theta \\
    0 &amp; 0 &amp; m b x_\theta &amp; I_P
\end{bmatrix}
\quad
K =
\begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
-k_h &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; -k_\theta &amp; 0 &amp; 0
\end{bmatrix}
\quad
D =
\begin{bmatrix}
0 &amp; 0 \\
0 &amp; 0 \\
-1 &amp; 0 \\
b \left( \frac{1}{2} + a \right) &amp; 1
\end{bmatrix}\]</p><h3 id="Defining-a-New-Type"><a class="docs-heading-anchor" href="#Defining-a-New-Type">Defining a New Type</a><a id="Defining-a-New-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-New-Type" title="Permalink"></a></h3><p>We start creating our model by defining a new type.  </p><pre><code class="language-julia">&quot;&quot;&quot;
    MyTypicalSection &lt;: AbstractModel

Typical section structural model with state variables ``q = \\begin{bmatrix} h &amp;
θ &amp; \\dot{h} &amp; \\dot{\\theta} \\end{bmatrix}^T``, structural parameters ``p_s =
\\begin{bmatrix} a &amp; b &amp; k_h &amp; k_\\theta &amp; m &amp; x_\\theta &amp; I_P \\end{bmatrix}^T``,
and aerodynamic loads ``r = \\begin{bmatrix} L &amp; M_\\frac{1}{4} \\end{bmatrix}^T``
&quot;&quot;&quot;
struct MyTypicalSection &lt;: AbstractModel end</code></pre><p>Model parameters may be stored either as fields of the newly defined type or passed directly to the solver.  In this case, we choose to define all of the structural parameters as elements of the parameter vector.  In general, model constants should be stored as fields of the struct, whereas parameters that may change should be passed to the solver through the parameter vector.</p><p>Note that the state, parameter, and aerodynamic load variable identities should be documented in the docstring of the type definition since the type definition provides the primary (and sometimes only) source of documentation for a given model.</p><h3 id="Defining-Model-Properties"><a class="docs-heading-anchor" href="#Defining-Model-Properties">Defining Model Properties</a><a id="Defining-Model-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Model-Properties" title="Permalink"></a></h3><p>We now need to define a few model properties.</p><p>To indicate the number of state variables in our model, we define a new method for the <a href="../library/#AerostructuralDynamics.number_of_states"><code>number_of_states</code></a> function.  In our case, we have four structural state variables <span>$q = \begin{bmatrix} h &amp; \theta &amp; \dot{h} &amp; \dot{\theta} \end{bmatrix}^T$</span>.  This method must be defined for all models.</p><pre><code class="language-julia">number_of_states(::Type{MyTypicalSection}) = 4</code></pre><p>To indicate the number of aerodynamic load inputs, we define a new method for the <a href="../library/#AerostructuralDynamics.number_of_inputs"><code>number_of_inputs</code></a> function.  In our case, we have two aerodynamic loads <span>$r = \begin{bmatrix} L &amp; M_\frac{1}{4} \end{bmatrix}^T$</span>.  This method must be defined for all models.</p><pre><code class="language-julia">number_of_inputs(::Type{MyTypicalSection}) = 2</code></pre><p>To indicate the number of parameters, we define a new method for the <a href="../library/#AerostructuralDynamics.number_of_parameters"><code>number_of_parameters</code></a> function.  In our case, we have seven parameters <span>$p_s = \begin{bmatrix} a &amp; b &amp; k_h &amp; k_\theta &amp; m &amp; x_\theta &amp; I_P \end{bmatrix}^T$</span>.  This method must be defined for all models.</p><pre><code class="language-julia">number_of_parameters(::Type{MyTypicalSection}) = 7</code></pre><p>To indicate whether we plan to use in-place or out-of-place functions, we define a new method for the <a href="@ref"><code>inplaceness</code></a> function.  In general, for performance reasons, in-place functions are preferred.  The one exception is for models with small amounts of state variables, in which case the preferred approach is to use static arrays with out-of-place functions.  For this model, we use the latter approach.  This method must be defined for all models.</p><pre><code class="language-julia">inplaceness(::Type{MyTypicalSection}) = OutOfPlace()</code></pre><p>To indicate mass matrix properties, we define a new method for the <a href="@ref"><code>mass_matrix_type</code></a> function.  This method must be defined for all models.</p><pre><code class="language-julia">mass_matrix_type(::Type{MyTypicalSection}) = Varying()</code></pre><p>To indicate the properties of the jacobian of the state rates with respect to the state variables, we define a new method for the <a href="@ref"><code>state_jacobian_type</code></a> function.</p><pre><code class="language-julia">state_jacobian_type(::Type{MyTypicalSection}) = Varying()</code></pre><p>To indicate the properties of the jacobian of the state rates with respect to the inputs, we define a new method for the <a href="@ref"><code>input_jacobian_type</code></a> function.</p><pre><code class="language-julia">input_jacobian_type(::Type{MyTypicalSection}) = Varying()</code></pre><p>To indicate whether the state rates are linearly dependent on the aerodynamic loads, or in other words whether the governing structural equations can be expressed as  </p><p class="math-container">\[M_s(q,p_s,t)\dot{q} = f_s(q,p_s,t) + D_s(q,p_s,t)r\]</p><p>we define a new method for the <a href="@ref"><code>input_dependence_type</code></a> function.  Having a linear load dependence allows for greater flexibility when coupling the structural model with an aerodynamic model.</p><pre><code class="language-julia">input_dependence_type(::Type{MyTypicalSection}) = Linear()</code></pre><h3 id="Mass-Matrix-Equation"><a class="docs-heading-anchor" href="#Mass-Matrix-Equation">Mass Matrix Equation</a><a id="Mass-Matrix-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Mass-Matrix-Equation" title="Permalink"></a></h3><p>For out-of-place models, the mass matrix is calculated using the <a href="../library/#AerostructuralDynamics.get_mass_matrix-Union{Tuple{TM}, Tuple{TM, Vararg{Any, N} where N}} where TM"><code>get_mass_matrix</code></a> function.  For in-place models the mass matrix is calculated using the <a href="../library/#AerostructuralDynamics.get_mass_matrix!-Union{Tuple{TM}, Tuple{Any, TM, Vararg{Any, N} where N}} where TM"><code>get_mass_matrix!</code></a> function.  For constant mass matrices, these functions are called without the <code>q</code>, <code>r</code>, <code>p</code>, and <code>t</code> arguments.  </p><pre><code class="language-julia">function get_mass_matrix(::MyTypicalSection, q, r, p, t)
    # extract structural parameters
    a, b, kh, kθ, m, xθ, Ip = p
    # calculate mass matrix
    return @SMatrix [1 0 0 0; 0 1 0 0; 0 0 m m*b*xθ; 0 0 m*b*xθ Ip]
end</code></pre><h3 id="State-Rate-Equation"><a class="docs-heading-anchor" href="#State-Rate-Equation">State Rate Equation</a><a id="State-Rate-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#State-Rate-Equation" title="Permalink"></a></h3><p>The right hand side of the governing structural differential equations is calculated using the <a href="../library/#AerostructuralDynamics.get_rates-Union{Tuple{T}, Tuple{T, Any, Any, Any, Any}} where T"><code>get_rates</code></a> function for out-of-place models and <a href="../library/#AerostructuralDynamics.get_rates!-Union{Tuple{T}, Tuple{Any, T, Any, Any, Any, Any}} where T"><code>get_rates!</code></a> function for in-place models.  </p><pre><code class="language-julia">function get_rates(::MyTypicalSection, q, r, p, t)
    # extract structural states
    h, θ, hdot, θdot = q
    # extract aerodynamic loads
    L, M = r
    # extract structural parameters
    a, b, kh, kθ, m, xθ, Ip = p
    # calculate state rates
    return SVector(hdot, θdot, -kh*h - L, -kθ*θ + M + (b/2+a*b)*L)
end</code></pre><h3 id="State-Rate-Jacobian"><a class="docs-heading-anchor" href="#State-Rate-Jacobian">State Rate Jacobian</a><a id="State-Rate-Jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#State-Rate-Jacobian" title="Permalink"></a></h3><p>The jacobian of the right hand side of the governing structural equations with respect to the state variables is calculated using the <a href="../library/#AerostructuralDynamics.get_state_jacobian-Union{Tuple{T}, Tuple{T, Any, Any, Any, Any}} where T"><code>get_state_jacobian</code></a> function for out-of-place models and <a href="../library/#AerostructuralDynamics.get_state_jacobian!-Union{Tuple{T}, Tuple{Any, T, Vararg{Any, N} where N}} where T"><code>get_state_jacobian!</code></a> function for in-place models.</p><pre><code class="language-julia">function get_state_jacobian(::MyTypicalSection, q, r, p, t)
    # extract parameters
    a, b, kh, kθ, m, xθ, Ip = p
    # return jacobian
    return @SMatrix [0 0 1 0; 0 0 0 1; -kh 0 0 0; 0 -kθ 0 0]
end</code></pre><h3 id="Input-Jacobian"><a class="docs-heading-anchor" href="#Input-Jacobian">Input Jacobian</a><a id="Input-Jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#Input-Jacobian" title="Permalink"></a></h3><p>The jacobian of the right hand side of the governing structural equations with respect to the inputs is defined using the <a href="../library/#AerostructuralDynamics.get_input_jacobian-Union{Tuple{TM}, Tuple{TM, Vararg{Any, N} where N}} where TM"><code>get_input_jacobian</code></a> function.  There is no out-of-place form for this function, however, it may be constructed as a either a linear map (if large) or static array (if small) in order to avoid allocations.  </p><pre><code class="language-julia">function get_input_jacobian(::MyTypicalSection, q, r, p, t)
    # extract parameters
    a, b, kh, kθ, m, xθ, Ip = p
    # return jacobian
    return @SMatrix [0 0; 0 0; -1 0; b/2+a*b 1]
end</code></pre><h3 id="Structural-Model-Code"><a class="docs-heading-anchor" href="#Structural-Model-Code">Structural Model Code</a><a id="Structural-Model-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-Model-Code" title="Permalink"></a></h3><p>Putting it all together, a complete representation of our typical section model for use with this package may be defined using the following block of code.</p><pre><code class="language-julia">&quot;&quot;&quot;
    MyTypicalSection &lt;: AbstractModel

Typical section structural model with state variables ``q = \\begin{bmatrix} h &amp;
θ &amp; \\dot{h} &amp; \\dot{\\theta} \\end{bmatrix}^T``, structural parameters ``p_s =
\\begin{bmatrix} a &amp; b &amp; k_h &amp; k_\\theta &amp; m &amp; x_\\theta &amp; I_P \\end{bmatrix}^T``,
and aerodynamic loads ``r = \\begin{bmatrix} L &amp; M_\\frac{1}{4} \\end{bmatrix}^T``
&quot;&quot;&quot;
struct MyTypicalSection &lt;: AbstractModel end

# --- Traits --- #

number_of_states(::Type{MyTypicalSection}) = 4
number_of_inputs(::Type{MyTypicalSection}) = 2
number_of_parameters(::Type{MyTypicalSection}) = 7
inplaceness(::Type{MyTypicalSection}) = OutOfPlace()
mass_matrix_type(::Type{MyTypicalSection}) = Varying()
state_jacobian_type(::Type{MyTypicalSection}) = Varying()
input_jacobian_type(::Type{MyTypicalSection}) = Varying()
input_dependence_type(::Type{MyTypicalSection}) = Linear()

# --- Methods --- #

function get_mass_matrix(::MyTypicalSection, q, r, p, t)
    # extract structural parameters
    a, b, kh, kθ, m, xθ, Ip = p
    # calculate mass matrix
    return @SMatrix [1 0 0 0; 0 1 0 0; 0 0 m m*b*xθ; 0 0 m*b*xθ Ip]
end

function get_rates(::MyTypicalSection, q, r, p, t)
    # extract structural states
    h, θ, hdot, θdot = q
    # extract aerodynamic loads
    L, M = r
    # extract structural parameters
    a, b, kh, kθ, m, xθ, Ip = p
    # calculate state rates
    return SVector(hdot, θdot, -kh*h - L, -kθ*θ + M + (b/2+a*b)*L)
end

function get_state_jacobian(::MyTypicalSection, q, r, p, t)
    # extract parameters
    a, b, kh, kθ, m, xθ, Ip = p
    # return jacobian
    return @SMatrix [0 0 1 0; 0 0 0 1; -kh 0 0 0; 0 -kθ 0 0]
end

function get_input_jacobian(::MyTypicalSection, q, r, p, t)
    # extract parameters
    a, b, kh, kθ, m, xθ, Ip = p
    # return jacobian
    return @SMatrix [0 0; 0 0; -1 0; b/2+a*b 1]
end</code></pre><h2 id="Defining-an-Aerodynamic-Model"><a class="docs-heading-anchor" href="#Defining-an-Aerodynamic-Model">Defining an Aerodynamic Model</a><a id="Defining-an-Aerodynamic-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-an-Aerodynamic-Model" title="Permalink"></a></h2><p>For demonstrating how to create a new aerodynamic model, we use Peters&#39; finite state aerodynamic model.</p><p>The governing differential equation for the aerodynamic states is</p><p class="math-container">\[\bar{A}\dot{\lambda} + \frac{U}{b}\lambda = \bar{c}\left[ \ddot{h} + U\dot{\theta} + b \left(\frac{1}{2} - a\right) \ddot{\theta} \right]\]</p><p>where</p><p class="math-container">\[\bar{A} = \bar{D} + \bar{d} \bar{b}^T + \bar{c} \bar{d}^T + \frac{1}{2} \bar{c}  \bar{b}^T \\
\bar{D}_{nm} = \begin{cases}
\frac{1}{2n} &amp; n=m+1 \\
\frac{-1}{2n} &amp; n=m-1 \\
0 &amp; n \neq m \pm 1 \\
\end{cases}
\quad
\bar{b}_n = \begin{cases}
\left( -1 \right)^{n-1} \frac{(N+n-1)!}{(N-n-1)!}\frac{1}{\left(n!\right)^2} &amp; n \neq N \\
\left( -1 \right)^{n-1} &amp; n = N
\end{cases}
\quad
\bar{c}_n = \frac{2}{n}
\quad
\bar{d}_n = \begin{cases}
\frac{1}{2} &amp; n = 1 \\
0 &amp; n \neq 1
\end{cases}\]</p><h3 id="Theory-2"><a class="docs-heading-anchor" href="#Theory-2">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-2" title="Permalink"></a></h3><p>Aerodynamic state variables in this package satisfy the ordinary differential equation (or differential algebraic equation in mass matrix form)</p><p class="math-container">\[M_{a}(λ,d,p_a,t)\dot{\lambda} = f_a(λ,d,p_a,t)\]</p><p>where <span>$M_a$</span> is a function which defines the aerodynamic mass matrix, <span>$f_a$</span> is a function which defines the mass matrix multiplied aerodynamic state rates, <span>$\lambda$</span> is a vector of structural states, <span>$d$</span> is a vector of structural deflections, <span>$p_a$</span> is a vector of aerodynamic parameters, and <span>$t$</span> is the current time.</p><p>The equations of motion for Peters&#39; finite state model, when expressed in the form expected by this package are:</p><p class="math-container">\[\bar{A}\dot{\lambda} = -\frac{U}{b}\lambda +
E d\]</p><p>where</p><p class="math-container">\[E = \bar{c} \begin{bmatrix}
U \\
1 \\
b \left(\frac{1}{2} - a\right)
\end{bmatrix}
\quad
d = \begin{bmatrix}
\dot{\theta} \\
\ddot{h} \\
\ddot{\theta}
\end{bmatrix}\]</p><h3 id="Defining-a-New-Type-2"><a class="docs-heading-anchor" href="#Defining-a-New-Type-2">Defining a New Type</a><a class="docs-heading-anchor-permalink" href="#Defining-a-New-Type-2" title="Permalink"></a></h3><p>We start creating our aerodynamic model by defining a new type.  </p><pre><code class="language-julia">&quot;&quot;&quot;
    MyPeters{N,TF,SV,SA} &lt;: AbstractModel

Peters&#39; finite state model with `N` state variables, inputs ``d = \\begin{bmatrix}
\\dot{\\theta} &amp; \\ddot{h} &amp; \\ddot{\\theta}\\end{bmatrix}^T`` and parameters
``p_a = \\begin{bmatrix} a &amp; b &amp; U &amp; \\rho \\end{bmatrix}^T``
&quot;&quot;&quot;
struct MyPeters{N,TF,TV&lt;:SVector{N,TF},TA&lt;:SMatrix{N,N,TF}} &lt;: AbstractModel
    A::TA
    b::TV
    c::TV
end</code></pre><p>Here <code>N</code> is the number of aerodynamic state variables and <code>TF</code> is the floating point type used to represent the constant matrices/vectors <span>$\bar{A}$</span>, <span>$\bar{b}$</span>, and <span>$\bar{c}$</span>.</p><p>For convenience, we create a constructor which initializes matrix <span>$\bar{A}$</span> and vectors <span>$\bar{b}$</span> and <span>$\bar{c}$</span> given the number of aerodynamic state variables and floating point type.</p><pre><code class="language-julia">&quot;&quot;&quot;
    MyPeters{N,TF=Float64}()

Initialize an object of type `MyPeters` which has `N` aerodynamic
degrees of freedom.
&quot;&quot;&quot;
MyPeters{N}() where N = MyPeters{N,Float64}()

function MyPeters{N,TF}() where {N,TF}

    b = zeros(TF, N)
    for n = 1:N-1
        b[n] = (-1)^(n-1)*factorial(big(N + n - 1))/factorial(big(N - n - 1))*
            1/factorial(big(n))^2
    end
    b[N] = (-1)^(N-1)

    c = zeros(TF, N)
    for n = 1:N
        c[n] = 2/n
    end

    d = zeros(TF, N)
    d[1] = 1/2

    D = zeros(TF, N, N)
    for m in 1:N-1
        n = m + 1
        D[n, m] = 1/(2*n)
    end
    for m in 2:N
        n = m - 1
        D[n, m] = -1/(2*n)
    end

    A = D + d*b&#39; + c*d&#39; + 1/2*c*b&#39;

    return MyPeters(SMatrix{N,N,TF}(A), SVector{N,TF}(b), SVector{N,TF}(c))
end</code></pre><h3 id="Defining-Model-Properties-2"><a class="docs-heading-anchor" href="#Defining-Model-Properties-2">Defining Model Properties</a><a class="docs-heading-anchor-permalink" href="#Defining-Model-Properties-2" title="Permalink"></a></h3><p>We now need to define a few model properties.</p><p>To indicate the number of state variables in our model, we define a new method for the <a href="../library/#AerostructuralDynamics.number_of_states"><code>number_of_states</code></a> function.  In our case, we have an arbitrary number of aerodynamic states <span>$\lambda$</span>, though typically 3-10 aerodynamic states are used with Peters&#39; finite state model.  This method must be defined for all models.</p><pre><code class="language-julia">number_of_states(::Type{MyPeters{N,TF,SV,SA}}) where {N,TF,SV,SA} = N</code></pre><p>To indicate the number of inputs, we define a new method for the <a href="../library/#AerostructuralDynamics.number_of_inputs"><code>number_of_inputs</code></a> function.  In our case, we have three inputs <span>$d = \begin{bmatrix} \dot{\theta} &amp; \ddot{h} &amp; \ddot{\theta} \end{bmatrix}^T$</span>.  This method must be defined for all models.</p><pre><code class="language-julia">number_of_inputs(::Type{&lt;:MyPeters}) = 3</code></pre><p>To indicate the number of parameters, we define a new method for the <a href="../library/#AerostructuralDynamics.number_of_parameters"><code>number_of_parameters</code></a> function.  In our case, we have four parameters <span>$p_a = \begin{bmatrix} a &amp; b &amp; U &amp; \rho \end{bmatrix}^T$</span>.  This method must be defined for all models.</p><pre><code class="language-julia">number_of_parameters(::Type{&lt;:MyPeters}) = 4</code></pre><p>To indicate whether we plan to use in-place or out-of-place functions, we define a new method for the <a href="@ref"><code>inplaceness</code></a> function.  This method must be defined for all models.</p><pre><code class="language-julia">inplaceness(::Type{&lt;:MyPeters}) = OutOfPlace()</code></pre><p>To indicate mass matrix properties, we define a new method for the <a href="@ref"><code>mass_matrix_type</code></a> function.  This method must be defined for all models.</p><pre><code class="language-julia">mass_matrix_type(::Type{&lt;:MyPeters}) = Constant()</code></pre><p>To indicate the properties of the jacobian of the state rates with respect to the state variables, we define a new method for the <a href="@ref"><code>state_jacobian_type</code></a> function.</p><pre><code class="language-julia">state_jacobian_type(::Type{&lt;:MyPeters}) = Varying()</code></pre><p>To indicate the properties of the jacobian of the state rates with respect to the inputs, we define a new method for the <a href="@ref"><code>input_jacobian_type</code></a> function.</p><pre><code class="language-julia">input_jacobian_type(::Type{&lt;:MyPeters}) = Varying()</code></pre><p>To indicate whether the state rates are linearly dependent on the inputs, or in other words whether the governing aerodynamic equations can be expressed as  </p><p class="math-container">\[M_a(\lambda,p_a,t)\dot{\lambda} = f_a(\lambda,p_s,t) + D_a(\lambda,p_s,t)d\]</p><p>we define a new method for the <a href="@ref"><code>input_dependence_type</code></a> function.</p><pre><code class="language-julia">input_dependence_type(::Type{&lt;:MyPeters}) = Linear()</code></pre><h3 id="Mass-Matrix-Equation-2"><a class="docs-heading-anchor" href="#Mass-Matrix-Equation-2">Mass Matrix Equation</a><a class="docs-heading-anchor-permalink" href="#Mass-Matrix-Equation-2" title="Permalink"></a></h3><p>For out-of-place models, the mass matrix is calculated using the <a href="../library/#AerostructuralDynamics.get_mass_matrix-Union{Tuple{TM}, Tuple{TM, Vararg{Any, N} where N}} where TM"><code>get_mass_matrix</code></a> function.  For in-place models the mass matrix is calculated using the <a href="../library/#AerostructuralDynamics.get_mass_matrix!-Union{Tuple{TM}, Tuple{Any, TM, Vararg{Any, N} where N}} where TM"><code>get_mass_matrix!</code></a> function.  For constant mass matrices, these functions are called without the <code>λ</code>, <code>d</code>, <code>p</code>, and <code>t</code> arguments.  </p><pre><code class="language-julia">get_mass_matrix(model::MyPeters) = model.A</code></pre><h3 id="State-Rate-Equation-2"><a class="docs-heading-anchor" href="#State-Rate-Equation-2">State Rate Equation</a><a class="docs-heading-anchor-permalink" href="#State-Rate-Equation-2" title="Permalink"></a></h3><p>The right hand side of the governing aerodynamic differential equations is calculated using the <a href="../library/#AerostructuralDynamics.get_rates-Union{Tuple{T}, Tuple{T, Any, Any, Any, Any}} where T"><code>get_rates</code></a> function for out-of-place models and <a href="../library/#AerostructuralDynamics.get_rates!-Union{Tuple{T}, Tuple{Any, T, Any, Any, Any, Any}} where T"><code>get_rates!</code></a> function for in-place models.  </p><pre><code class="language-julia">function get_rates(model::MyPeters{N,TF,SV,SA}, λ, d, p, t) where {N,TF,SV,SA}
    # extract aerodynamic states as statically sized vector
    λ = SVector{N}(λ)
    # extract structural deflections
    θdot, hddot, θddot = d
    # extract parameters
    a, b, U, ρ = p
    # extract model constants
    cbar = model.c
    # calculate rates
    return cbar*(hddot + U*θdot + (b/2-a*b)*θddot) - U/b*λ
end</code></pre><h3 id="State-Rate-Jacobian-2"><a class="docs-heading-anchor" href="#State-Rate-Jacobian-2">State Rate Jacobian</a><a class="docs-heading-anchor-permalink" href="#State-Rate-Jacobian-2" title="Permalink"></a></h3><p>The jacobian of the right hand side of the governing aerodynamic equations with respect to the state variables is calculated using the <a href="../library/#AerostructuralDynamics.get_state_jacobian-Union{Tuple{T}, Tuple{T, Any, Any, Any, Any}} where T"><code>get_state_jacobian</code></a> function for out-of-place models and <a href="../library/#AerostructuralDynamics.get_state_jacobian!-Union{Tuple{T}, Tuple{Any, T, Vararg{Any, N} where N}} where T"><code>get_state_jacobian!</code></a> function for in-place models.</p><pre><code class="language-julia">function get_state_jacobian(model::MyPeters, λ, d, p, t)
    # extract parameters
    a, b, U, ρ = p
    # extract model constants
    cbar = model.c
    # jacobian with respect to aerodynamic states
    return -U/b*Diagonal(one.(cbar))
end</code></pre><h3 id="Structural-Deflection-Jacobian"><a class="docs-heading-anchor" href="#Structural-Deflection-Jacobian">Structural Deflection Jacobian</a><a id="Structural-Deflection-Jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-Deflection-Jacobian" title="Permalink"></a></h3><p>The jacobian of the right hand side of the governing aerodynamic equations with respect to the structural deflections is defined using the <a href="../library/#AerostructuralDynamics.get_input_jacobian-Union{Tuple{TM}, Tuple{TM, Vararg{Any, N} where N}} where TM"><code>get_input_jacobian</code></a> function.</p><pre><code class="language-julia">function get_input_jacobian(model::MyPeters, λ, d, p, t)
    # extract parameters
    a, b, U, ρ = p
    # extract model constants
    cbar = model.c
    # return jacobian
    return hcat(U*cbar, cbar, (b/2-a*b)*cbar)
end</code></pre><h3 id="Aerodynamic-Model-Code"><a class="docs-heading-anchor" href="#Aerodynamic-Model-Code">Aerodynamic Model Code</a><a id="Aerodynamic-Model-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Aerodynamic-Model-Code" title="Permalink"></a></h3><p>Putting it all together, a complete representation Peters&#39; finite state aerodynamic model may be defined using the following block of code.</p><pre><code class="language-julia">&quot;&quot;&quot;
    MyPeters{N,TF,SV,SA} &lt;: AbstractModel

Peter&#39;s finite state model with `N` state variables, inputs ``d = \\begin{bmatrix}
\\dot{\\theta} &amp; \\ddot{h} &amp; \\ddot{\\theta}\\end{bmatrix}^T`` and parameters
``p_a = \\begin{bmatrix} a &amp; b &amp; U &amp; \\rho \\end{bmatrix}^T``
&quot;&quot;&quot;
struct MyPeters{N,TF,TV&lt;:SVector{N,TF},TA&lt;:SMatrix{N,N,TF}} &lt;: AbstractModel
    A::TA
    b::TV
    c::TV
end

# --- Constructors --- #

&quot;&quot;&quot;
    MyPeters{N,TF=Float64}()

Initialize an object of type `MyPeters` which has `N` aerodynamic
degrees of freedom.
&quot;&quot;&quot;
MyPeters{N}() where N = MyPeters{N,Float64}()

function MyPeters{N,TF}() where {N,TF}

    b = zeros(TF, N)
    for n = 1:N-1
        b[n] = (-1)^(n-1)*factorial(big(N + n - 1))/factorial(big(N - n - 1))*
            1/factorial(big(n))^2
    end
    b[N] = (-1)^(N-1)

    c = zeros(TF, N)
    for n = 1:N
        c[n] = 2/n
    end

    d = zeros(TF, N)
    d[1] = 1/2

    D = zeros(TF, N, N)
    for m in 1:N-1
        n = m + 1
        D[n, m] = 1/(2*n)
    end
    for m in 2:N
        n = m - 1
        D[n, m] = -1/(2*n)
    end

    A = D + d*b&#39; + c*d&#39; + 1/2*c*b&#39;

    return MyPeters(SMatrix{N,N,TF}(A), SVector{N,TF}(b), SVector{N,TF}(c))
end

# --- Traits --- #

number_of_states(::Type{MyPeters{N,TF,SV,SA}}) where {N,TF,SV,SA} = N
number_of_inputs(::Type{&lt;:MyPeters}) = 3
number_of_parameters(::Type{&lt;:MyPeters}) = 4
inplaceness(::Type{&lt;:MyPeters}) = OutOfPlace()
mass_matrix_type(::Type{&lt;:MyPeters}) = Constant()
state_jacobian_type(::Type{&lt;:MyPeters}) = Varying()
input_jacobian_type(::Type{&lt;:MyPeters}) = Varying()
input_dependence_type(::Type{&lt;:MyPeters}) = Linear()

# --- Methods --- #

get_mass_matrix(model::MyPeters) = model.A

function get_rates(model::MyPeters{N,TF,SV,SA}, λ, d, p, t) where {N,TF,SV,SA}
    # extract aerodynamic states as statically sized vector
    λ = SVector{N}(λ)
    # extract structural deflections
    θdot, hddot, θddot = d
    # extract parameters
    a, b, U, ρ = p
    # extract model constants
    cbar = model.c
    # calculate rates
    return cbar*(hddot + U*θdot + (b/2-a*b)*θddot) - U/b*λ
end

function get_state_jacobian(model::MyPeters, λ, d, p, t)
    # extract parameters
    a, b, U, ρ = p
    # extract model constants
    cbar = model.c
    # jacobian with respect to aerodynamic states
    return -U/b*Diagonal(one.(cbar))
end

function get_input_jacobian(model::MyPeters, λ, d, p, t)
    # extract parameters
    a, b, U, ρ = p
    # extract model constants
    cbar = model.c
    # return jacobian
    return hcat(U*cbar, cbar, (b/2-a*b)*cbar)
end</code></pre><h2 id="Coupling-Aerodynamic-and-Structural-Models"><a class="docs-heading-anchor" href="#Coupling-Aerodynamic-and-Structural-Models">Coupling Aerodynamic and Structural Models</a><a id="Coupling-Aerodynamic-and-Structural-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Coupling-Aerodynamic-and-Structural-Models" title="Permalink"></a></h2><p>For demonstrating how to couple aerodynamic and structural models together, we use the typical section structural model and Peters&#39; finite state aerodynamic model.  To couple these two models together, we need to define the model inputs (aerodynamic loads and structural deflections) as functions of the states, parameters, and time.</p><h3 id="Theory-3"><a class="docs-heading-anchor" href="#Theory-3">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-3" title="Permalink"></a></h3><p>We assume the aerodynamic loads and structural deflections may be expressed as a function of the aerodynamic and structural state variables and parameters, as well as the current time.</p><p class="math-container">\[d = f_d(u,p,t) \quad r = f_r(u,p,t) \\\]</p><p>where</p><p class="math-container">\[u = \begin{bmatrix} \lambda &amp; q \end{bmatrix}^T \quad
p = \begin{bmatrix} p_a &amp; p_s \end{bmatrix}^T \quad\]</p><p>If the state rates of a given structural model are linearly dependent on the aerodynamic loads, we can expand the expression which defines the aerodynamic loads to</p><p class="math-container">\[r = f_r(u,p,t) - M_{r s}(u,p,t) \dot{q} -
M_{r a}(u,p,t) \dot{\lambda}\]</p><p>where <span>$M_{r s}$</span> is a function which defines the (negative) jacobian of the aerodynamic loads with respect to the structural state rates and <span>$M_{r a}$</span> is a function which defines the (negative) jacobian of the aerodynamic loads with respect to the aerodynamic state rates.  <span>$f_r$</span> is a function which defines the portion of the aerodynamic loads which is independent of the structural and aerodynamic state rates.</p><p>If the state rates of a given aerodynamic model are linearly dependent on the structural deflections, we can expand the expression which defines the structural deflections to</p><p class="math-container">\[d = f_d(u,p,t) - M_{d s}(u,p,t) \dot{q} -
M_{d a}(u,p,t) \dot{\lambda}\]</p><p>where <span>$M_{d s}$</span> is a function which defines the (negative) jacobian of the structural deflections with respect to the structural state rates and <span>$M_{d a}$</span> is a function which defines the (negative) jacobian of the structural deflections with respect to the aerodynamic state rates.  <span>$f_d$</span> is a function which defines the portion of the structural deflections which is independent of the structural and aerodynamic state rates.</p><p>In the most general case, the coupled system of equations may be defined as</p><p class="math-container">\[M_u(u,p,t) \dot{u} = f_u(u,p,t)\]</p><p>where</p><p class="math-container">\[f_u = \begin{bmatrix} f_a \\f_s \end{bmatrix} \quad
M_{u} = \begin{bmatrix} M_a &amp; 0 \\ 0 &amp; M_s \end{bmatrix} + \begin{bmatrix} D_a &amp; 0 \\ 0 &amp; D_s \end{bmatrix} \begin{bmatrix} M_{da} &amp; M_{ds} \\ M_{ra} &amp; M_{rs} \end{bmatrix} \quad\]</p><p>The associated jacobian is</p><p class="math-container">\[\frac{\partial f_u}{\partial u} = \begin{bmatrix} \frac{\partial f_a}{\partial \lambda} \end{bmatrix} &amp; 0 \\ 0 &amp; \frac{\partial f_s}{\partial q} + \begin{bmatrix} D_a &amp; 0 \\ 0 &amp; D_s \end{bmatrix} \begin{bmatrix} \frac{\partial f_d}{\partial \lambda} &amp; \frac{\partial f_d}{\partial q} \\ \frac{\partial f_r}{\partial \lambda} &amp; \frac{\partial f_r}{\partial q} \end{bmatrix}\]</p><p>If we introduce the combined input function</p><p class="math-container">\[y = f_y(u, p, t) - M_y(u, p, t) \dot{u}\]</p><p>where</p><p class="math-container">\[y = \begin{bmatrix} d \\ r \end{bmatrix} \quad f_y = \begin{bmatrix} f_d \\ f_r \end{bmatrix} \quad M_y = \begin{bmatrix} M_{da} &amp; M_{ds} \\ M_{ra} &amp; M_{rs} \end{bmatrix}\]</p><p>the mass matrix and jacobian expressions may be shortened to</p><p class="math-container">\[M_{u} = \begin{bmatrix} M_a &amp; 0 \\ 0 &amp; M_s \end{bmatrix} + \begin{bmatrix} D_a &amp; 0 \\ 0 &amp; D_s \end{bmatrix} M_y\]</p><p class="math-container">\[\frac{\partial f_u}{\partial u} =
\begin{bmatrix}
\frac{\partial f_a}{\partial \lambda} &amp; 0 \\
0 &amp; \frac{\partial f_s}{\partial q}
\end{bmatrix} +
\begin{bmatrix}
D_a &amp; 0 \\
0 &amp; D_s
\end{bmatrix} \frac{\partial f_y}{\partial u}\]</p><p>We have already implemented all of the functions in these expressions with the exception of those associated with the combined input function, so all that is required to couple the aerodynamic and structural models together is to define functions associated with the combined input function.</p><h4 id="Aerodynamic-Model-Inputs"><a class="docs-heading-anchor" href="#Aerodynamic-Model-Inputs">Aerodynamic Model Inputs</a><a id="Aerodynamic-Model-Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Aerodynamic-Model-Inputs" title="Permalink"></a></h4><p>The inputs expected by Peters&#39; finite state model are <span>$d = \begin{bmatrix} \dot{\theta} &amp; \ddot{h} &amp; \ddot{\theta} \end{bmatrix}^T$</span>.  These structural deflections correspond to a subset of the structural states and corresponding rates.</p><p>The structural deflections may be expressed in the form expected by this package as</p><p class="math-container">\[d = J_{ds} q - M_{ds} \dot{q}\]</p><p>where</p><p class="math-container">\[J_{ds} = \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix} \quad
M_{ds} = \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -1 \end{bmatrix}\]</p><h4 id="Structural-Model-Inputs"><a class="docs-heading-anchor" href="#Structural-Model-Inputs">Structural Model Inputs</a><a id="Structural-Model-Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-Model-Inputs" title="Permalink"></a></h4><p>The aerodynamic loads expected by the typical section model are the lift and quarter-chord moment.  The lift and quarter-chord moment, as calculated using Peters&#39; finite state model are</p><p class="math-container">\[L = \pi \rho_\infty b^2 \left( \ddot{h} + U \dot{\theta} - b a \ddot{\theta} \right) + 2 \pi \rho_\infty U b \left[ h + U \theta + b \left( \frac{1}{2} - a \right) \dot{\theta} - \lambda_0 \right]\]</p><p class="math-container">\[M_\frac{1}{4} = - \pi \rho_\infty b^3 \left[ \frac{1}{2} \ddot{h} + U \dot{\theta} + b \left( \frac{1}{8} - \frac{a}{2} \right) \ddot{\theta} \right]\]</p><p>where <span>$U$</span> is the freestream velocity, <span>$\rho_\infty$</span> is the freestream air density, and <span>$\lambda_0$</span> is the induced flow velocity.  The induced flow velocity may be approximated as a function of the aerodynamic states</p><p class="math-container">\[\lambda_0 \approx \frac{1}{2} \sum\limits_{n=1}^{N}\bar{b}_n \lambda_n\]</p><p>The aerodynamic loads calculated by Peters&#39; finite state model when coupled with the typical section model may be expressed in the form expected by this package as</p><p class="math-container">\[r = J_{ra} \lambda + J_{rs} q - M_{rs} \dot{q}\]</p><p>where</p><p class="math-container">\[r =\begin{bmatrix}
L &amp;
M_\frac{1}{4}
\end{bmatrix}^T
\quad
\lambda = \begin{bmatrix}
\lambda_1 &amp;
\lambda_2 &amp;
... &amp;
\lambda_N
\end{bmatrix}^T
\quad
q = \begin{bmatrix}
h &amp;
\theta &amp;
\dot{h} &amp;
\dot{\theta}
\end{bmatrix}^T
\\
J_{rs} = 2 \pi \rho_\infty b U
\begin{bmatrix}
0 &amp; U &amp; 1 &amp;  \frac{b}{2} + b \left(\frac{1}{2} - a\right) \\
0 &amp; 0 &amp; 0 &amp; - \frac{b^2}{2}
\end{bmatrix}
\quad
J_{ra} = - 2 \pi \rho_\infty b U \begin{bmatrix} \bar{b}^T \\ 0_{1 \times N} \end{bmatrix}
\\
M_{rs} = \pi \rho_\infty b^2
\begin{bmatrix}
0 &amp; 0 &amp; -1 &amp; ba \\
0 &amp; 0 &amp; \frac{b}{2} &amp; b^2 \left(\frac{1}{8} - \frac{a}{2}\right)
\end{bmatrix}\]</p><h4 id="Combined-Input-Function"><a class="docs-heading-anchor" href="#Combined-Input-Function">Combined Input Function</a><a id="Combined-Input-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Combined-Input-Function" title="Permalink"></a></h4><p>Upon combining the expressions for the aerodynamic loads and structural deflections, we obtain the following expression for the combined input function.</p><p class="math-container">\[y = J_{y} y - M_{y} \dot{u}\]</p><p>where</p><p class="math-container">\[J_{y} = \begin{bmatrix} 0 &amp; J_{ds} \\ J_{ra} &amp; J_{rs}  \end{bmatrix} \quad
M_{y} = \begin{bmatrix} 0 &amp; M_{ds} \\ 0 &amp; M_{rs} \end{bmatrix}\]</p><h3 id="Defining-Input-Function-Properties"><a class="docs-heading-anchor" href="#Defining-Input-Function-Properties">Defining Input Function Properties</a><a id="Defining-Input-Function-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Input-Function-Properties" title="Permalink"></a></h3><p>Before we define the combined input function (and its associated functions) we need to define a few of its properties.</p><p>To define whether the combined input function should use an in-place or out-of-place format, we define a new method for the <a href="@ref"><code>inplaceness</code></a> function.</p><pre><code class="language-julia">inplaceness(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = OutOfPlace()</code></pre><p>To indicate input function mass matrix properties, we define a new method for the <a href="@ref"><code>mass_matrix_type</code></a> function.</p><pre><code class="language-julia">mass_matrix_type(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = Varying()</code></pre><p>To indicate the properties of the input function jacobian with respect to the state variables, we define a new method for the <a href="@ref"><code>state_jacobian_type</code></a> function.</p><pre><code class="language-julia">state_jacobian_type(::Type{&lt;:MyPeters}, ::Type{MyTypicalSection}) = Varying()</code></pre><h3 id="Input-Mass-Matrix-Equation"><a class="docs-heading-anchor" href="#Input-Mass-Matrix-Equation">Input Mass Matrix Equation</a><a id="Input-Mass-Matrix-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Input-Mass-Matrix-Equation" title="Permalink"></a></h3><p>For out-of-place input functions, the mass matrix is calculated using the <a href="@ref"><code>get_input_mass_matrix</code></a> function.  For in-place combined input functions, the mass matrix is calculated using the <a href="@ref"><code>get_input_mass_matrix!</code></a> function.  For constant mass matrices, these functions are called without the <code>u</code>, <code>p</code>, and <code>t</code> arguments.</p><pre><code class="language-julia">function get_input_mass_matrix(aero::MyPeters{N,TF,SV,SA},
    stru::MyTypicalSection, u, p, t) where {N,TF,SV,SA}
    # extract parameters
    a, b, U, ρ, a, b, kh, kθ, m, xθ, Ip = p
    # construct submatrices
    Mda = zeros(SMatrix{3,N,TF})
    Mds = @SMatrix [0 0 0 0; 0 0 -1 0; 0 0 0 -1]
    Mra = zeros(SMatrix{2,N,TF})
    Mrs = hcat(
        zeros(SVector{2,TF}),
        zeros(SVector{2,TF}),
        -SVector(pi*ρ*b^2, -pi/2*ρ*b^3),
        -SVector(-pi*ρ*a*b^3, -pi/8*ρ*b^4*(1 - 4*a)))
    # assemble mass matrix
    return [Mda Mds; Mra Mrs]
end</code></pre><h3 id="Input-Equation"><a class="docs-heading-anchor" href="#Input-Equation">Input Equation</a><a id="Input-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Input-Equation" title="Permalink"></a></h3><p>The portion of the inputs which is independent of the state rates is calculated using the <a href="../library/#AerostructuralDynamics.get_inputs-Union{Tuple{TM}, Tuple{TM, Any, Any, Any}} where TM"><code>get_inputs</code></a> function for out-of-place aerodynamic load calculations and <a href="../library/#AerostructuralDynamics.get_inputs!-Union{Tuple{T}, Tuple{Any, T, Any, Any, Any}} where T"><code>get_inputs!</code></a> function for in-place aerodynamic load calculations.</p><pre><code class="language-julia">function get_inputs(aero::MyPeters{N,TF,SV,SA}, stru::MyTypicalSection,
    u, p, t) where {N,TF,SV,SA}
    # indices for extracting state variables
    iλ = SVector{N}(1:N)
    iq = SVector{4}(N+1:N+4)
    # separate aerodynamic and structural states
    λ = u[iλ]
    q = u[iq]
    # extract structural state variables
    h, θ, hdot, θdot = q
    # extract parameters
    a, b, U, ρ, a, b, kh, kθ, m, xθ, Ip = p
    # extract model constants
    bbar = aero.b
    # calculate induced flow velocity
    λ0 = 1/2 * bbar&#39;*λ
    # calculate (partial) lift
    L = 2*pi*ρ*U*b*(hdot + U*θ + (b/2-a*b)*θdot - λ0) + pi*ρ*b^2*U*θdot
    # calculate (partial) quarter-chord moment
    M = -pi*ρ*b^3*U*θdot
    # return portion of inputs that is not dependent on the state rates
    return SVector(θdot, 0, 0, L, M)
end</code></pre><h3 id="Input-Jacobian-2"><a class="docs-heading-anchor" href="#Input-Jacobian-2">Input Jacobian</a><a class="docs-heading-anchor-permalink" href="#Input-Jacobian-2" title="Permalink"></a></h3><p>The jacobian of <span>$f_y$</span> with respect to the state variables is calculated using the <a href="@ref"><code>get_input_state_jacobian</code></a> function for out-of-place combined input functions and <a href="@ref"><code>get_input_state_jacobian!</code></a> function for in-place combined inputs functions.</p><pre><code class="language-julia">function get_input_state_jacobian(aero::MyPeters{N,TF,SV,SA},
    stru::MyTypicalSection, u, p, t) where {N,TF,SV,SA}
    # extract parameters
    a, b, U, ρ, a, b, kh, kθ, m, xθ, Ip = p
    # extract model constants
    bbar = aero.b
    # compute jacobian sub-matrices
    Jda = zeros(SMatrix{3,N,TF})
    Jds = @SMatrix [0 0 0 1; 0 0 0 0; 0 0 0 0]
    Jra = -pi*ρ*U*b*vcat(bbar&#39;, zero(bbar)&#39;)
    Jrs = hcat(
        SVector(0, 0),
        SVector(2*pi*ρ*U^2*b, 0),
        SVector(2*pi*ρ*U*b, 0),
        SVector(2*pi*ρ*b^2*U*(1 - a), -pi*ρ*b^3*U)
        )
    # return jacobian
    return [Jda Jds; Jra Jrs]
end</code></pre><h2 id="Model-Ordering"><a class="docs-heading-anchor" href="#Model-Ordering">Model Ordering</a><a id="Model-Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Ordering" title="Permalink"></a></h2><p>In general, we suggest that the following ordering of model state variables, inputs, and parameters is used when constructing input functions.</p><ol><li>Aerodynamics</li><li>Structural</li><li>Rigid Body (when present)</li></ol><h2 id="Avoiding-Mass-Matrices"><a class="docs-heading-anchor" href="#Avoiding-Mass-Matrices">Avoiding Mass Matrices</a><a id="Avoiding-Mass-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Avoiding-Mass-Matrices" title="Permalink"></a></h2><p>In order to take advantage of as many features of the DifferentialEquations package as possible (including local sensitivity analysis) we recommend that the governing differential equations for models be reformulated to avoid using mass matrices whenever possible.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theory/">« Theory</a><a class="docs-footer-nextpage" href="../library/">Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 18 June 2021 01:16">Friday 18 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
